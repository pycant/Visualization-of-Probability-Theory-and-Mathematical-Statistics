<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>区间估计探索 - 概率统计可视化</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="../static/libs/chart/chart.umd.min.js"></script>
    <script src="../static/libs/chart/chartjs-plugin-annotation.min.js"></script>
    <!-- Marked.js for Markdown rendering -->
    <script src="../static/libs/marked/marked.min.js"></script>

    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="../static/libs/katex/css/katex.min.css" />
    <script defer src="../static/libs/katex/js/katex.min.js"></script>
    <script defer src="../static/libs/katex/js/auto-render.min.js"></script>
    <script>
      // 等待页面和所有脚本完全加载后再渲染数学公式
      window.addEventListener("load", function () {
        setTimeout(function () {
          if (typeof renderMathInElement !== "undefined") {
            renderMathInElement(document.body, {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\[", right: "\\]", display: true },
                { left: "\\(", right: "\\)", display: false },
              ],
              throwOnError: false,
              errorColor: "#cc0000",
            });
            console.log("KaTeX渲染完成");
          } else {
            console.error("KaTeX未加载");
          }
        }, 200);
      });
    </script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap");

      :root {
        --dark-bg: #0f172a;
        --dark-card: #1e293b;
        --neon-blue: #00f3ff;
        --neon-purple: #bf00ff;
        --neon-green: #00ff66;
        --neon-orange: #ff8c00;
      }

      body {
        font-family: "Roboto", sans-serif;
        background-color: var(--dark-bg);
        color: #fff;
        overflow-x: hidden;
      }

      .font-future {
        font-family: "Roboto", sans-serif;
        letter-spacing: 0.05em;
      }

      .text-neon-blue {
        color: var(--neon-blue);
      }

      .text-neon-purple {
        color: var(--neon-purple);
      }

      .text-neon-green {
        color: var(--neon-green);
      }

      .text-neon-orange {
        color: var(--neon-orange);
      }

      .bg-neon-blue {
        background-color: var(--neon-blue);
      }

      .bg-neon-purple {
        background-color: var(--neon-purple);
      }

      .bg-neon-green {
        background-color: var(--neon-green);
      }

      .bg-neon-orange {
        background-color: var(--neon-orange);
      }

      .bg-dark-bg {
        background-color: var(--dark-bg);
      }

      .bg-dark-card {
        background-color: var(--dark-card);
      }

      .accent-neon-blue {
        accent-color: var(--neon-blue);
      }

      .accent-neon-purple {
        accent-color: var(--neon-purple);
      }

      .accent-neon-green {
        accent-color: var(--neon-green);
      }

      .accent-neon-orange {
        accent-color: var(--neon-orange);
      }

      .clip-path-slant {
        clip-path: polygon(0 0, 100% 0, 100% 95%, 0 100%);
      }

      .bg-grid {
        background-image: linear-gradient(
            to right,
            rgba(255, 255, 255, 0.05) 1px,
            transparent 1px
          ),
          linear-gradient(
            to bottom,
            rgba(255, 255, 255, 0.05) 1px,
            transparent 1px
          );
        background-size: 20px 20px;
      }

      .hidden {
        display: none;
      }

      /* 贝叶斯控制面板样式 */
      #bayesian-controls {
        display: none; /* 初始隐藏 */
        margin-top: 10px;
        padding: 15px;
        background-color: rgba(0, 243, 255, 0.1);
        border: 1px solid rgba(0, 243, 255, 0.3);
        border-radius: 8px;
        backdrop-filter: blur(10px);
      }

      /* 粒子动画 */
      #particles-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        overflow: hidden;
      }

      .particle {
        position: absolute;
        border-radius: 50%;
        opacity: 0.5;
        animation: float 15s infinite ease-in-out;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0) translateX(0);
        }
        25% {
          transform: translateY(-30px) translateX(15px);
        }
        50% {
          transform: translateY(-15px) translateX(-15px);
        }
        75% {
          transform: translateY(30px) translateX(15px);
        }
      }

      /* 思考动画样式 */
      .thinking-animation {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .thinking-animation .dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background-color: #00f3ff;
        animation: thinking-pulse 1.4s ease-in-out infinite both;
      }

      .thinking-animation .dot:nth-child(1) {
        animation-delay: -0.32s;
      }

      /* 渐进式学习样式 */
      .theory-step.locked {
        position: relative;
      }

      .theory-step.locked .message-content {
        pointer-events: none;
      }

      .theory-step.unlocked {
        animation: unlock-glow 0.5s ease-in-out;
      }

      @keyframes unlock-glow {
        0% {
          box-shadow: 0 0 0 rgba(0, 243, 255, 0.5);
        }
        50% {
          box-shadow: 0 0 20px rgba(0, 243, 255, 0.8);
        }
        100% {
          box-shadow: 0 0 0 rgba(0, 243, 255, 0.5);
        }
      }

      .ai-help-btn {
        background: linear-gradient(45deg, #6366f1, #8b5cf6);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .ai-help-btn:hover {
        background: linear-gradient(45deg, #4f46e5, #7c3aed);
        transform: translateY(-2px);
      }

      .understanding-btn {
        transition: all 0.3s ease;
      }

      .understanding-btn:hover {
        transform: scale(1.1);
      }

      .progressive-hint {
        background: linear-gradient(
          135deg,
          rgba(0, 243, 255, 0.1),
          rgba(139, 92, 246, 0.1)
        );
        border: 1px solid rgba(0, 243, 255, 0.3);
      }

      .thinking-animation .dot:nth-child(2) {
        animation-delay: -0.16s;
      }

      .thinking-animation .dot:nth-child(3) {
        animation-delay: 0s;
      }

      @keyframes thinking-pulse {
        0%,
        80%,
        100% {
          transform: scale(0.8);
          opacity: 0.5;
        }
        40% {
          transform: scale(1.2);
          opacity: 1;
        }
      }

      /* Markdown内容样式 */
      .message-content {
        line-height: 1.6;
      }

      .message-content h1,
      .message-content h2,
      .message-content h3,
      .message-content h4,
      .message-content h5,
      .message-content h6 {
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
        font-weight: 600;
        color: var(--neon-blue);
      }

      .message-content p {
        margin-bottom: 1rem;
      }

      .message-content ul,
      .message-content ol {
        margin-bottom: 1rem;
        padding-left: 1.5rem;
      }

      .message-content li {
        margin-bottom: 0.25rem;
      }

      .message-content table {
        width: 100%;
        border-collapse: collapse;
        margin: 1rem 0;
        background-color: rgba(30, 41, 59, 0.5);
        border-radius: 0.5rem;
        overflow: hidden;
      }

      .message-content th,
      .message-content td {
        padding: 0.75rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .message-content th {
        background-color: rgba(0, 243, 255, 0.1);
        font-weight: 600;
        color: #00f3ff;
      }

      .message-content code {
        background-color: rgba(30, 41, 59, 0.8);
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-family: "Courier New", monospace;
        color: #00ff66;
      }

      .message-content pre {
        background-color: rgba(30, 41, 59, 0.8);
        padding: 1rem;
        border-radius: 0.5rem;
        overflow-x: auto;
        margin: 1rem 0;
      }

      .message-content pre code {
        background: none;
        padding: 0;
      }

      .message-content blockquote {
        border-left: 4px solid #00f3ff;
        padding-left: 1rem;
        margin: 1rem 0;
        font-style: italic;
        color: #cbd5e1;
      }

      .message-content .katex {
        color: #e5e7eb !important;
      }

      .message-content .katex-display {
        margin: 1rem 0;
      }

      /* 糖果盒动画 */
      .candy-box {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        animation: candy-glow 2s ease-in-out infinite alternate;
      }

      @keyframes candy-glow {
        0% {
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        100% {
          box-shadow: 0 10px 30px rgba(255, 107, 107, 0.5),
            0 0 20px rgba(78, 205, 196, 0.3);
        }
      }

      .candy {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin: 2px;
        animation: candy-bounce 0.5s ease-out;
      }

      .candy.red {
        background-color: #ff4757;
      }

      .candy.blue {
        background-color: #3742fa;
      }

      .alarm-record {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin: 3px;
        animation: record-bounce 0.5s ease-out;
        font-size: 12px;
      }

      .alarm-record.rain {
        background: linear-gradient(45deg, #3b82f6, #1d4ed8);
        color: white;
      }

      .alarm-record.no-rain {
        background: linear-gradient(45deg, #fbbf24, #f59e0b);
        color: white;
      }

      @keyframes candy-bounce {
        0% {
          transform: scale(0) rotate(0deg);
        }
        50% {
          transform: scale(1.2) rotate(180deg);
        }
        100% {
          transform: scale(1) rotate(360deg);
        }
      }

      @keyframes record-bounce {
        0% {
          transform: scale(0) rotate(0deg);
        }
        50% {
          transform: scale(1.2) rotate(180deg);
        }
        100% {
          transform: scale(1) rotate(360deg);
        }
      }

      /* 置信区间可视化 */
      .confidence-interval {
        height: 20px;
        border-radius: 10px;
        margin: 5px 0;
        position: relative;
        transition: all 0.3s ease;
      }

      .confidence-interval.contains-true {
        background: linear-gradient(90deg, #00ff66, #00cc52);
        box-shadow: 0 0 10px rgba(0, 255, 102, 0.5);
      }

      .confidence-interval.misses-true {
        background: linear-gradient(90deg, #ff4757, #ff3742);
        box-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
      }

      .true-value-line {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 3px;
        background: #ffd700;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        z-index: 10;
        pointer-events: none;
      }

      #intervals-container {
        position: relative;
      }

      #intervals-container .true-value-line {
        position: absolute;
        margin-left: -1.5px;
      }

      /* 理论推导步骤 */
      .theory-step {
        background: rgba(30, 41, 59, 0.8);
        border: 1px solid rgba(0, 243, 255, 0.3);
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
        transition: all 0.3s ease;
      }

      .theory-step:hover {
        border-color: var(--neon-blue);
        box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
      }

      .understanding-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      .understanding-btn {
        padding: 8px 16px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        background: transparent;
        color: white;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .understanding-btn:hover {
        background: var(--neon-blue);
        color: var(--dark-bg);
      }

      .understanding-btn.selected {
        background: var(--neon-blue);
        color: var(--dark-bg);
        border-color: var(--neon-blue);
      }

      /* 理解度图谱 */
      .understanding-radar {
        background: rgba(30, 41, 59, 0.8);
        border: 1px solid var(--neon-green);
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
      }

      /* 数据点动画效果 */
      .data-point-enter {
        animation: dataPointEnter 0.6s ease-out;
      }

      @keyframes dataPointEnter {
        0% {
          transform: scale(0) rotate(180deg);
          opacity: 0;
        }
        50% {
          transform: scale(1.2) rotate(90deg);
          opacity: 0.8;
        }
        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }
      }

      /* 置信区间动画 */
      .confidence-interval-fade {
        animation: confidenceIntervalFade 1s ease-in-out;
      }

      @keyframes confidenceIntervalFade {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        100% {
          opacity: 0.3;
          transform: scale(1);
        }
      }

      /* 结果显示动画 */
      .result-slide-in {
        animation: resultSlideIn 0.8s ease-out;
      }

      @keyframes resultSlideIn {
        0% {
          transform: translateY(20px);
          opacity: 0;
        }
        100% {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* 按钮点击效果 */
      .button-click-effect {
        animation: buttonClickEffect 0.3s ease-out;
      }

      @keyframes buttonClickEffect {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.95);
        }
        100% {
          transform: scale(1);
        }
      }

      /* 脉冲效果 */
      .pulse-effect {
        animation: pulseEffect 2s ease-in-out infinite;
      }

      @keyframes pulseEffect {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.05);
          opacity: 0.8;
        }
      }

      /* 数据加载动画 */
      .loading-dots {
        display: inline-block;
      }

      .loading-dots::after {
        content: "";
        animation: loadingDots 1.5s steps(4, end) infinite;
      }

      @keyframes loadingDots {
        0%,
        20% {
          content: "";
        }
        40% {
          content: ".";
        }
        60% {
          content: "..";
        }
        80%,
        100% {
          content: "...";
        }
      }

      /* 成功提示动画 */
      .success-flash {
        animation: successFlash 0.6s ease-out;
      }

      @keyframes successFlash {
        0% {
          background-color: transparent;
        }
        50% {
          background-color: rgba(0, 255, 102, 0.2);
        }
        100% {
          background-color: transparent;
        }
      }
    </style>
  </head>
  <body>
    <!-- 粒子背景 -->
    <div id="particles-container"></div>

    <!-- 导航栏 -->
    <nav
      class="bg-dark-bg/80 backdrop-blur-md py-4 sticky top-0 z-50 border-b border-gray-800"
    >
      <div class="container mx-auto px-4 flex justify-between items-center">
        <a
          href="index.html"
          class="text-2xl font-future font-bold flex items-center"
        >
          <span class="text-neon-blue">概率统计</span
          ><span class="ml-2">可视化</span>
        </a>
        <div class="flex space-x-6">
          <a
            href="index.html"
            class="text-gray-300 hover:text-neon-blue transition-colors duration-300"
            >首页</a
          >
          <a
            href="random_variables.html"
            class="text-gray-300 hover:text-neon-blue transition-colors duration-300"
            >随机变量</a
          >
          <a
            href="interval_estimation.html"
            class="text-neon-blue border-b-2 border-neon-blue pb-1"
            >区间估计</a
          >
        </div>
      </div>
    </nav>

    <!-- 页面标题 -->
    <section
      class="py-20 relative bg-gradient-to-b from-dark-bg to-dark-card/50 clip-path-slant"
    >
      <div class="absolute inset-0 bg-grid opacity-10"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-16">
          <h1 class="text-[clamp(2rem,6vw,4rem)] font-future font-bold mb-4">
            <span class="text-neon-blue">区间估计</span>探索
          </h1>
          <p class="text-gray-400 max-w-2xl mx-auto">
            用样本构建一个有信心的范围，探索置信区间的奥秘
          </p>
        </div>
      </div>
    </section>

    <!-- 示例展示部分 -->
    <section id="candy-box-demo" class="py-20 relative">
      <div class="absolute inset-0 bg-grid opacity-10"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-12">
          <h2 class="text-3xl font-future font-bold mb-4">
            <span class="text-neon-orange">神秘糖果盒</span>猜想
          </h2>
          <p class="text-gray-400 max-w-3xl mx-auto">
            通过一个直观的例子，瞬间理解什么是区间估计和置信水平
          </p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-12">
          <!-- 糖果盒交互区 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-cloud-rain text-neon-orange mr-3"></i>
              湿度警报器实验
            </h3>

            <div class="candy-box mb-6 text-center">
              <div class="text-white font-bold mb-4">智能湿度警报器</div>
              <div
                id="candy-display"
                class="min-h-[100px] flex flex-wrap justify-center items-center"
              >
                <div class="text-gray-300">点击"记录样本"开始实验</div>
              </div>
            </div>

            <div class="bg-dark-bg rounded-lg p-4 mb-6">
              <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <label class="block text-gray-300 mb-2">样本量 (n):</label>
                  <select
                    id="sample-size"
                    class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                  >
                    <option value="20">20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                  </select>
                </div>
                <div>
                  <label class="block text-gray-300 mb-2">置信水平:</label>
                  <select
                    id="confidence-level"
                    class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                  >
                    <option value="0.90">90%</option>
                    <option value="0.95">95%</option>
                    <option value="0.99">99%</option>
                  </select>
                </div>
              </div>

              <div class="text-center mb-4">
                <div class="text-gray-300 mb-2">
                  报警后下雨比例:
                  <span
                    id="sample-proportion"
                    class="text-neon-orange font-bold"
                    >--</span
                  >
                </div>
                <div class="text-gray-300 mb-4">
                  置信区间:
                  <span
                    id="confidence-interval-text"
                    class="text-neon-blue font-bold"
                    >--</span
                  >
                </div>
              </div>

              <div class="flex justify-center space-x-4">
                <button
                  id="sample-btn"
                  class="px-6 py-2 bg-neon-orange text-dark-bg font-bold rounded-md hover:bg-neon-orange/80 transition-all duration-300"
                >
                  记录样本 <i class="fa fa-clipboard ml-2"></i>
                </button>
                <button
                  id="reveal-truth-btn"
                  class="px-6 py-2 bg-neon-purple text-dark-bg font-bold rounded-md hover:bg-neon-purple/80 transition-all duration-300"
                >
                  揭示真相 <i class="fa fa-eye ml-2"></i>
                </button>
                <button
                  id="repeat-experiment-btn"
                  class="px-6 py-2 bg-neon-green text-dark-bg font-bold rounded-md hover:bg-neon-green/80 transition-all duration-300"
                >
                  重复100次 <i class="fa fa-repeat ml-2"></i>
                </button>
              </div>
            </div>

            <div class="text-sm text-gray-400">
              <p class="mb-2"><strong>实验说明:</strong></p>
              <p>• 湿度警报器在湿度达到阈值时发出警报</p>
              <p>• 记录警报后一段时间内是否下雨（真实概率0.6）</p>
              <p>• 通过抽样估计报警后下雨的概率</p>
              <p>• 观察置信区间如何"捕捉"真实值</p>
            </div>
          </div>

          <!-- 置信区间可视化 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-chart-line text-neon-blue mr-3"></i>
              置信区间可视化
            </h3>

            <div class="mb-6">
              <div class="text-center mb-4">
                <div class="text-gray-300">
                  成功捕捉真实值的区间:
                  <span id="success-count" class="text-neon-green font-bold"
                    >0</span
                  >
                  / <span id="total-intervals" class="text-gray-400">0</span>
                </div>
                <div class="text-gray-300">
                  成功率:
                  <span id="success-rate" class="text-neon-blue font-bold"
                    >--%</span
                  >
                </div>
              </div>

              <div
                id="intervals-container"
                class="relative bg-dark-bg rounded-lg p-4 min-h-[300px] overflow-y-auto"
              >
                <div class="text-gray-400 text-center py-8">
                  点击"重复100次"查看置信区间分布
                </div>
              </div>
            </div>

            <div
              class="text-sm text-gray-400 sticky bottom-0 bg-dark-bg/90 backdrop-blur-sm p-4 rounded-lg border border-gray-700/50"
            >
              <p class="mb-2"><strong>图例:</strong></p>
              <div class="flex items-center mb-1">
                <div class="w-4 h-4 bg-neon-green rounded mr-2"></div>
                <span>包含真实值的区间</span>
              </div>
              <div class="flex items-center mb-1">
                <div class="w-4 h-4 bg-red-500 rounded mr-2"></div>
                <span>未包含真实值的区间</span>
              </div>
              <div class="flex items-center">
                <div class="w-1 h-4 bg-yellow-400 mr-2"></div>
                <span>真实值位置</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 理论探索部分 -->
    <section
      id="theory-exploration"
      class="py-20 relative bg-gradient-to-b from-dark-bg to-dark-card/50"
    >
      <div class="absolute inset-0 bg-grid opacity-10"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-12">
          <h2 class="text-3xl font-future font-bold mb-4">
            <span class="text-neon-blue">理论</span>探索
          </h2>
          <p class="text-gray-400 max-w-3xl mx-auto">
            揭秘置信区间：从抽样分布到最终公式的推导之旅
          </p>
        </div>

        <div class="max-w-4xl mx-auto">
          <!-- 渐进式学习提示 -->
          <div
            class="bg-neon-blue/10 border border-neon-blue/30 rounded-lg p-4 mb-8"
          >
            <div class="flex items-center mb-2">
              <i class="fa fa-lightbulb text-neon-blue mr-2"></i>
              <h3 class="text-lg font-semibold text-neon-blue">
                渐进式学习模式
              </h3>
            </div>
            <p class="text-gray-300 text-sm">
              每完成一个步骤的理解度评分（≥3分），下一步骤将自动解锁。如果遇到困难，可以点击右侧工具箱中的AI助手寻求帮助。
            </p>
          </div>

          <!-- 步骤1 -->
          <div class="theory-step unlocked" data-step="1">
            <h3
              class="text-xl font-semibold mb-4 text-neon-blue flex items-center"
            >
              <span
                class="bg-neon-blue text-dark-bg rounded-full w-8 h-8 flex items-center justify-center mr-3 text-sm font-bold"
                >1</span
              >
              起点——我们最好的猜测 (点估计)
              <span class="ml-auto text-sm">
                <i class="fa fa-unlock text-neon-green"></i>
              </span>
            </h3>
            <div class="message-content">
              <p>
                要估计一个未知的总体均值
                μ，我们最直接、最好的方法就是计算样本均值 $\bar{X}$。
              </p>
              <div class="bg-dark-bg rounded-lg p-4 my-4">
                <div class="text-center">
                  $$\bar{X} = \frac{1}{n} \sum_{i=1}^{n} X_i$$
                </div>
              </div>
              <p>
                但是，单凭一个
                $\bar{X}$，我们不知道这个估计的'误差'有多大。我们需要用概率的语言来量化这个不确定性。
              </p>
            </div>
            <div class="understanding-section">
              <div class="understanding-buttons">
                <span class="text-sm text-gray-400 mr-4">理解程度：</span>
                <button
                  class="understanding-btn"
                  data-level="1"
                  title="完全不理解"
                >
                  1
                </button>
                <button
                  class="understanding-btn"
                  data-level="2"
                  title="基本不理解"
                >
                  2
                </button>
                <button
                  class="understanding-btn"
                  data-level="3"
                  title="部分理解"
                >
                  3
                </button>
                <button
                  class="understanding-btn"
                  data-level="4"
                  title="基本理解"
                >
                  4
                </button>
                <button
                  class="understanding-btn"
                  data-level="5"
                  title="完全理解"
                >
                  5
                </button>
              </div>
              <div class="mt-3 flex items-center gap-4">
                <button class="ai-help-btn" data-step="1">
                  <i class="fa fa-robot mr-2"></i>需要AI帮助？
                </button>
                <div class="next-step-hint hidden text-sm text-neon-green">
                  <i class="fa fa-check-circle mr-1"></i>很好！下一步已解锁
                </div>
              </div>
            </div>
          </div>

          <!-- 步骤2 -->
          <div class="theory-step locked" data-step="2">
            <h3
              class="text-xl font-semibold mb-4 text-gray-500 flex items-center"
            >
              <span
                class="bg-gray-600 text-gray-400 rounded-full w-8 h-8 flex items-center justify-center mr-3 text-sm font-bold"
                >2</span
              >
              钥匙——抽样分布与中心极限定理 (CLT)
              <span class="ml-auto text-sm">
                <i class="fa fa-lock text-gray-500"></i>
              </span>
            </h3>
            <div class="message-content opacity-50">
              <p>
                神奇的定理来了：中心极限定理（CLT）告诉我们，无论总体是什么分布，只要样本量n足够大，样本均值
                $\bar{X}$ 的分布就会接近一个<strong>正态分布</strong>。
              </p>
              <div class="bg-dark-bg rounded-lg p-4 my-4">
                <div class="text-center">
                  $$\bar{X} \sim N\left(\mu, \frac{\sigma^2}{n}\right)$$
                </div>
              </div>
              <p>
                这个分布以真正的 μ 为中心，其波动范围由
                $\frac{\sigma^2}{n}$（方差除以样本量）决定。n越大，分布越集中，$\bar{X}$
                作为估计就越准。
              </p>
            </div>
            <div class="understanding-section">
              <div class="locked-message text-center py-4">
                <i class="fa fa-lock text-gray-500 text-2xl mb-2"></i>
                <p class="text-gray-500">
                  请先完成上一步骤的理解度评分（≥3分）以解锁此内容
                </p>
              </div>
              <div class="understanding-content hidden">
                <div class="understanding-buttons">
                  <span class="text-sm text-gray-400 mr-4">理解程度：</span>
                  <button
                    class="understanding-btn"
                    data-level="1"
                    title="完全不理解"
                  >
                    1
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="2"
                    title="基本不理解"
                  >
                    2
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="3"
                    title="部分理解"
                  >
                    3
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="4"
                    title="基本理解"
                  >
                    4
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="5"
                    title="完全理解"
                  >
                    5
                  </button>
                </div>
                <div class="mt-3 flex items-center gap-4">
                  <button class="ai-help-btn" data-step="2">
                    <i class="fa fa-robot mr-2"></i>需要AI帮助？
                  </button>
                  <div class="next-step-hint hidden text-sm text-neon-green">
                    <i class="fa fa-check-circle mr-1"></i>很好！下一步已解锁
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- 步骤3 -->
          <div class="theory-step locked" data-step="3">
            <h3
              class="text-xl font-semibold mb-4 text-gray-500 flex items-center"
            >
              <span
                class="bg-gray-600 text-gray-400 rounded-full w-8 h-8 flex items-center justify-center mr-3 text-sm font-bold"
                >3</span
              >
              转换——构造枢轴量 (Pivotal Quantity)
              <span class="ml-auto text-sm">
                <i class="fa fa-lock text-gray-500"></i>
              </span>
            </h3>
            <div class="message-content opacity-50">
              <p>
                既然知道了$\bar{X}$的分布，我们可以通过<strong>标准化</strong>，将其转化为著名的Z值。这个新的量，我们称之为'枢轴量'。
              </p>
              <div class="bg-dark-bg rounded-lg p-4 my-4">
                <div class="text-center">
                  $$Z = \frac{\bar{X} - \mu}{\sigma/\sqrt{n}}$$
                </div>
              </div>
              <p>
                最关键的一点来了：<strong
                  >Z的分布是标准正态分布 N(0,
                  1)，而且它的分布完全已知，不再依赖于任何未知参数（μ或σ）！</strong
                >
                这就为我们构造区间提供了可能。
              </p>
              <div class="bg-dark-bg rounded-lg p-4 my-4">
                <div class="text-center">$$Z \sim N(0, 1)$$</div>
              </div>
            </div>
            <div class="understanding-section">
              <div class="locked-message text-center py-4">
                <i class="fa fa-lock text-gray-500 text-2xl mb-2"></i>
                <p class="text-gray-500">
                  请先完成上一步骤的理解度评分（≥3分）以解锁此内容
                </p>
              </div>
              <div class="understanding-content hidden">
                <div class="understanding-buttons">
                  <span class="text-sm text-gray-400 mr-4">理解程度：</span>
                  <button
                    class="understanding-btn"
                    data-level="1"
                    title="完全不理解"
                  >
                    1
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="2"
                    title="基本不理解"
                  >
                    2
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="3"
                    title="部分理解"
                  >
                    3
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="4"
                    title="基本理解"
                  >
                    4
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="5"
                    title="完全理解"
                  >
                    5
                  </button>
                </div>
                <div class="mt-3 flex items-center gap-4">
                  <button class="ai-help-btn" data-step="3">
                    <i class="fa fa-robot mr-2"></i>需要AI帮助？
                  </button>
                  <div class="next-step-hint hidden text-sm text-neon-green">
                    <i class="fa fa-check-circle mr-1"></i>很好！下一步已解锁
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- 步骤4 -->
          <div class="theory-step locked" data-step="4">
            <h3
              class="text-xl font-semibold mb-4 text-gray-500 flex items-center"
            >
              <span
                class="bg-gray-600 text-gray-400 rounded-full w-8 h-8 flex items-center justify-center mr-3 text-sm font-bold"
                >4</span
              >
              概率表述——找到临界值
              <span class="ml-auto text-sm">
                <i class="fa fa-lock text-gray-500"></i>
              </span>
            </h3>
            <div class="message-content opacity-50">
              <p>
                因为Z服从标准正态分布，我们可以轻松求出，Z值落在$-Z_{\alpha/2}$和$Z_{\alpha/2}$之间的概率是
                $(1-\alpha)$。
              </p>
              <div class="bg-dark-bg rounded-lg p-4 my-4">
                <div class="text-center">
                  $$P\left( -Z_{\alpha/2} \leq Z \leq Z_{\alpha/2} \right) = 1 -
                  \alpha$$
                </div>
              </div>
              <p>现在，我们把步骤3的Z代回去！</p>
              <div class="bg-dark-bg rounded-lg p-4 my-4">
                <div class="text-center">
                  $$P\left( -Z_{\alpha/2} \leq \frac{\bar{X} -
                  \mu}{\sigma/\sqrt{n}} \leq Z_{\alpha/2} \right) = 1 - \alpha$$
                </div>
              </div>
            </div>
            <div class="understanding-section">
              <div class="locked-message text-center py-4">
                <i class="fa fa-lock text-gray-500 text-2xl mb-2"></i>
                <p class="text-gray-500">
                  请先完成上一步骤的理解度评分（≥3分）以解锁此内容
                </p>
              </div>
              <div class="understanding-content hidden">
                <div class="understanding-buttons">
                  <span class="text-sm text-gray-400 mr-4">理解程度：</span>
                  <button
                    class="understanding-btn"
                    data-level="1"
                    title="完全不理解"
                  >
                    1
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="2"
                    title="基本不理解"
                  >
                    2
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="3"
                    title="部分理解"
                  >
                    3
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="4"
                    title="基本理解"
                  >
                    4
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="5"
                    title="完全理解"
                  >
                    5
                  </button>
                </div>
                <div class="mt-3 flex items-center gap-4">
                  <button class="ai-help-btn" data-step="4">
                    <i class="fa fa-robot mr-2"></i>需要AI帮助？
                  </button>
                  <div class="next-step-hint hidden text-sm text-neon-green">
                    <i class="fa fa-check-circle mr-1"></i>很好！下一步已解锁
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- 步骤5 -->
          <div class="theory-step locked" data-step="5">
            <h3
              class="text-xl font-semibold mb-4 text-gray-500 flex items-center"
            >
              <span
                class="bg-gray-600 text-gray-400 rounded-full w-8 h-8 flex items-center justify-center mr-3 text-sm font-bold"
                >5</span
              >
              求解——得到置信区间
              <span class="ml-auto text-sm">
                <i class="fa fa-lock text-gray-500"></i>
              </span>
            </h3>
            <div class="message-content opacity-50">
              <p>
                最后一步！我们对不等式进行代数变形，目的是解出被包围在中间的 μ。
              </p>
              <p>
                <strong
                  >1. 不等式各部分同时乘以 $\frac{\sigma}{\sqrt{n}}$：</strong
                >
              </p>
              <div class="bg-dark-bg rounded-lg p-4 my-2">
                <div class="text-center">
                  $$-Z_{\alpha/2} \cdot \frac{\sigma}{\sqrt{n}} \leq \bar{X} -
                  \mu \leq Z_{\alpha/2} \cdot \frac{\sigma}{\sqrt{n}}$$
                </div>
              </div>
              <p><strong>2. 不等式各部分同时减去 $\bar{X}$：</strong></p>
              <div class="bg-dark-bg rounded-lg p-4 my-2">
                <div class="text-center">
                  $$-\bar{X} - Z_{\alpha/2} \cdot \frac{\sigma}{\sqrt{n}} \leq
                  -\mu \leq -\bar{X} + Z_{\alpha/2} \cdot
                  \frac{\sigma}{\sqrt{n}}$$
                </div>
              </div>
              <p>
                <strong
                  >3. 不等式各部分同时乘以 -1（注意：乘负数要变号！）：</strong
                >
              </p>
              <div class="bg-dark-bg rounded-lg p-4 my-2">
                <div class="text-center">
                  $$\bar{X} + Z_{\alpha/2} \cdot \frac{\sigma}{\sqrt{n}} \geq
                  \mu \geq \bar{X} - Z_{\alpha/2} \cdot
                  \frac{\sigma}{\sqrt{n}}$$
                </div>
              </div>
              <p><strong>4. 改写为传统的区间形式：</strong></p>
              <div
                class="bg-dark-bg rounded-lg p-4 my-4 border border-neon-green"
              >
                <div class="text-center">
                  $$P\left( \bar{X} - Z_{\alpha/2} \cdot \frac{\sigma}{\sqrt{n}}
                  \leq \mu \leq \bar{X} + Z_{\alpha/2} \cdot
                  \frac{\sigma}{\sqrt{n}} \right) = 1 - \alpha$$
                </div>
              </div>
              <p class="text-neon-green font-bold">
                大功告成！这就是置信区间的公式。区间 $\left[\bar{X} \pm
                Z_{\alpha/2} \cdot \frac{\sigma}{\sqrt{n}}\right]$ 以
                $(1-\alpha)$ 的置信水平包含了未知参数 μ。
              </p>
            </div>
            <div class="understanding-section">
              <div class="locked-message text-center py-4">
                <i class="fa fa-lock text-gray-500 text-2xl mb-2"></i>
                <p class="text-gray-500">
                  请先完成上一步骤的理解度评分（≥3分）以解锁此内容
                </p>
              </div>
              <div class="understanding-content hidden">
                <div class="understanding-buttons">
                  <span class="text-sm text-gray-400 mr-4">理解程度：</span>
                  <button
                    class="understanding-btn"
                    data-level="1"
                    title="完全不理解"
                  >
                    1
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="2"
                    title="基本不理解"
                  >
                    2
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="3"
                    title="部分理解"
                  >
                    3
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="4"
                    title="基本理解"
                  >
                    4
                  </button>
                  <button
                    class="understanding-btn"
                    data-level="5"
                    title="完全理解"
                  >
                    5
                  </button>
                </div>
                <div class="mt-3 flex items-center gap-4">
                  <button class="ai-help-btn" data-step="5">
                    <i class="fa fa-robot mr-2"></i>需要AI帮助？
                  </button>
                  <div class="next-step-hint hidden text-sm text-neon-green">
                    <i class="fa fa-check-circle mr-1"></i>恭喜！所有步骤已完成
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- 理解度图谱 -->
          <div id="understanding-radar" class="understanding-radar hidden">
            <h3
              class="text-xl font-semibold mb-4 text-neon-green flex items-center"
            >
              <i class="fa fa-chart-radar text-neon-green mr-3"></i>
              个人理解度图谱与学习分析
            </h3>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <!-- 雷达图 -->
              <div class="bg-dark-bg rounded-lg p-4">
                <h4 class="text-lg font-semibold mb-3 text-white">
                  理解度雷达图
                </h4>
                <div class="h-64">
                  <canvas id="understanding-chart"></canvas>
                </div>
              </div>

              <!-- 学习数据分析 -->
              <div class="bg-dark-bg rounded-lg p-4">
                <h4 class="text-lg font-semibold mb-3 text-white">
                  学习数据分析
                </h4>
                <div id="learning-stats" class="space-y-3">
                  <div class="flex justify-between items-center">
                    <span class="text-gray-300">平均理解度:</span>
                    <span
                      id="avg-understanding"
                      class="text-neon-blue font-bold"
                      >-</span
                    >
                  </div>
                  <div class="flex justify-between items-center">
                    <span class="text-gray-300">最薄弱环节:</span>
                    <span id="weakest-step" class="text-neon-orange font-bold"
                      >-</span
                    >
                  </div>
                  <div class="flex justify-between items-center">
                    <span class="text-gray-300">最强项:</span>
                    <span id="strongest-step" class="text-neon-green font-bold"
                      >-</span
                    >
                  </div>
                  <div class="flex justify-between items-center">
                    <span class="text-gray-300">完成时间:</span>
                    <span
                      id="completion-time"
                      class="text-neon-purple font-bold"
                      >-</span
                    >
                  </div>
                </div>

                <!-- 学习建议 -->
                <div class="mt-4 p-3 bg-gray-800 rounded-lg">
                  <h5 class="text-sm font-semibold text-neon-green mb-2">
                    📚 个性化学习建议
                  </h5>
                  <div id="learning-suggestions" class="text-sm text-gray-300">
                    完成所有步骤后将显示个性化建议
                  </div>
                </div>
              </div>
            </div>

            <div class="text-sm text-gray-400 mt-4">
              <p>
                <i class="fa fa-info-circle mr-1"></i>
                这个图谱记录了您的学习轨迹，帮助识别需要重点复习的内容。数据仅在本地存储，保护您的隐私。
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 实践应用部分 -->
    <section id="practical-applications" class="py-20 relative">
      <div class="absolute inset-0 bg-grid opacity-10"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-12">
          <h2 class="text-3xl font-future font-bold mb-4">
            <span class="text-neon-green">实践</span>应用
          </h2>
          <p class="text-gray-400 max-w-3xl mx-auto">
            将区间估计理论应用到真实场景中
          </p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-12">
          <!-- 军事分析应用 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-crosshairs text-neon-orange mr-3"></i>
              军事分析：寻找遗失的炮弹
            </h3>

            <div class="mb-6">
              <p class="text-gray-300 mb-4">
                一架战机在训练海域遗失一门炮弹。使用声纳浮标进行搜索，每个浮标的探测存在随机误差。
              </p>

              <div class="bg-dark-bg rounded-lg p-4 mb-4">
                <div class="grid grid-cols-3 gap-4 mb-4">
                  <div>
                    <label class="block text-gray-300 mb-2"
                      >声纳精度 (σ):</label
                    >
                    <select
                      id="sonar-accuracy"
                      class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                    >
                      <option value="0.1">高精度 (±0.1km)</option>
                      <option value="0.3" selected>中精度 (±0.3km)</option>
                      <option value="0.5">低精度 (±0.5km)</option>
                      <option value="1.0">极低精度 (±1.0km)</option>
                    </select>
                  </div>
                  <div>
                    <label class="block text-gray-300 mb-2">置信水平:</label>
                    <select
                      id="sonar-confidence"
                      class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                    >
                      <option value="0.90">90%</option>
                      <option value="0.95" selected>95%</option>
                      <option value="0.99">99%</option>
                    </select>
                  </div>
                  <div>
                    <label class="block text-gray-300 mb-2">投放模式:</label>
                    <select
                      id="deployment-mode"
                      class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                    >
                      <option value="single">单次投放</option>
                      <option value="batch" selected>批量投放</option>
                    </select>
                  </div>
                </div>

                <div class="text-center mb-4">
                  <div class="text-gray-300 mb-2">
                    估计位置:
                    <span
                      id="estimated-position"
                      class="text-neon-orange font-bold"
                      >(0.0, 0.0)</span
                    >
                  </div>
                  <div class="text-gray-300 mb-4">
                    搜索区域:
                    <span id="search-area" class="text-neon-blue font-bold"
                      >-- km²</span
                    >
                  </div>
                </div>

                <div class="flex justify-center space-x-3 flex-wrap gap-2">
                  <button
                    id="deploy-single-btn"
                    class="px-4 py-2 bg-neon-orange text-dark-bg font-bold rounded-md hover:bg-neon-orange/80 transition-all duration-300"
                  >
                    投放1个浮标 <i class="fa fa-anchor ml-2"></i>
                  </button>
                  <button
                    id="deploy-batch-btn"
                    class="px-4 py-2 bg-neon-blue text-white font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300"
                  >
                    投放10个浮标 <i class="fa fa-ship ml-2"></i>
                  </button>
                  <button
                    id="reveal-shell-btn"
                    class="px-4 py-2 bg-neon-green text-dark-bg font-bold rounded-md hover:bg-neon-green/80 transition-all duration-300"
                  >
                    揭示真实位置 <i class="fa fa-eye ml-2"></i>
                  </button>
                  <button
                    id="reset-search-btn"
                    class="px-4 py-2 bg-gray-600 text-white font-bold rounded-md hover:bg-gray-500 transition-all duration-300"
                  >
                    重置搜索 <i class="fa fa-refresh ml-2"></i>
                  </button>
                  <button
                    id="debug-btn"
                    class="px-4 py-2 bg-purple-600 text-white font-bold rounded-md hover:bg-purple-500 transition-all duration-300"
                    style="display: none"
                  >
                    调试信息 <i class="fa fa-bug ml-2"></i>
                  </button>
                </div>
              </div>
            </div>

            <div
              class="h-96 bg-dark-bg rounded-lg p-4 relative overflow-hidden"
            >
              <canvas
                id="sonar-map"
                width="800"
                height="600"
                style="
                  width: 100%;
                  height: 100%;
                  image-rendering: auto;
                  cursor: crosshair;
                "
                class="border border-gray-600 rounded"
              >
              </canvas>
              <!-- 坐标显示 -->
              <div
                id="sonar-coordinate-display"
                class="absolute top-2 left-2 bg-black/70 text-white px-2 py-1 rounded text-xs font-mono"
              >
                坐标: (0, 0) km
              </div>
              <!-- 缩放控制 -->
              <div class="absolute top-2 right-2 flex flex-col gap-1">
                <button
                  id="sonar-zoom-in"
                  class="bg-gray-700 hover:bg-gray-600 text-white w-8 h-8 rounded flex items-center justify-center text-sm"
                >
                  +
                </button>
                <button
                  id="sonar-zoom-out"
                  class="bg-gray-700 hover:bg-gray-600 text-white w-8 h-8 rounded flex items-center justify-center text-sm"
                >
                  -
                </button>
                <button
                  id="sonar-reset-view"
                  class="bg-gray-700 hover:bg-gray-600 text-white w-8 h-8 rounded flex items-center justify-center text-xs"
                >
                  ⌂
                </button>
              </div>
            </div>

            <!-- 预测结果分析区域 -->
            <div
              id="prediction-feedback"
              class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600"
              style="display: none"
            >
              <div class="flex items-center justify-between mb-3">
                <h3 class="text-lg font-bold text-neon-green flex items-center">
                  <i class="fa fa-chart-line mr-2"></i>
                  预测结果分析
                </h3>
                <button
                  id="close-feedback"
                  class="text-gray-400 hover:text-white transition-colors"
                >
                  <i class="fa fa-times"></i>
                </button>
              </div>
              <div
                id="feedback-content"
                class="text-sm text-gray-300 space-y-2"
              >
                <!-- 动态内容将在这里显示 -->
              </div>
            </div>

            <div class="mt-4 text-sm text-gray-400">
              <p>
                <strong>核心公式:</strong> $\bar{X} \pm t_{\alpha/2}(n-1) \cdot
                \frac{S}{\sqrt{n}}$
              </p>
              <p>观察置信区域如何随着样本量n的增加而缩小！</p>
            </div>
          </div>

          <!-- 游戏策略应用 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-gamepad text-neon-purple mr-3"></i>
              游戏策略：《我的世界》末地之门定位
            </h3>

            <div class="mb-6">
              <p class="text-gray-300 mb-4">
                玩家投掷末影之眼寻找末地要塞。由于游戏机制，每次投掷都存在随机误差。
              </p>

              <div class="bg-dark-bg rounded-lg p-4 mb-4">
                <div class="grid grid-cols-3 gap-4 mb-4">
                  <div>
                    <label class="block text-gray-300 mb-2">投掷次数:</label>
                    <select
                      id="eye-count"
                      class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                    >
                      <option value="5">5次</option>
                      <option value="12" selected>12次</option>
                      <option value="20">20次</option>
                    </select>
                  </div>
                  <div>
                    <label class="block text-gray-300 mb-2">置信水平:</label>
                    <select
                      id="eye-confidence"
                      class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                    >
                      <option value="0.90">90%</option>
                      <option value="0.95" selected>95%</option>
                      <option value="0.99">99%</option>
                    </select>
                  </div>
                  <div>
                    <label class="block text-gray-300 mb-2">Alpha值 (α):</label>
                    <select
                      id="alpha-level"
                      class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                    >
                      <option value="0.01">0.01</option>
                      <option value="0.05" selected>0.05</option>
                      <option value="0.10">0.10</option>
                    </select>
                  </div>
                  <div>
                    <label class="block text-gray-300 mb-2">统计方法:</label>
                    <select
                      id="statistical-method"
                      class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                    >
                      <option value="classical">经典统计</option>
                      <option value="bayesian" selected>贝叶斯方法</option>
                    </select>
                  </div>
                </div>

                <div id="bayesian-controls" class="mb-4">
                  <div class="grid grid-cols-2 gap-4">
                    <div>
                      <label class="block text-gray-300 mb-2">先验分布:</label>
                      <select
                        id="prior-distribution"
                        class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                      >
                        <option value="uniform" selected>均匀分布</option>
                        <option value="normal">正态分布</option>
                        <option value="informed">有信息先验</option>
                      </select>
                    </div>
                    <div>
                      <label class="block text-gray-300 mb-2">显示模式:</label>
                      <select
                        id="display-mode"
                        class="w-full bg-gray-800 text-white py-2 px-3 rounded-lg border border-gray-700"
                      >
                        <option value="points">点图</option>
                        <option value="contour" selected>等高线</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div class="text-center mb-4">
                  <div class="text-gray-300 mb-2">
                    要塞预测位置:
                    <span
                      id="stronghold-position"
                      class="text-neon-purple font-bold"
                      >(0, 0)</span
                    >
                  </div>
                  <div class="text-gray-300 mb-2">
                    搜寻范围:
                    <span id="search-range" class="text-neon-blue font-bold"
                      >±-- 格</span
                    >
                  </div>
                  <div class="text-gray-300 mb-4">
                    角度置信区间:
                    <span
                      id="angle-confidence-interval"
                      class="text-neon-green font-bold"
                      >--°</span
                    >
                  </div>

                  <!-- 成功信息显示区域 -->
                  <div
                    id="success-info"
                    class="mb-4 p-4 bg-gradient-to-r from-green-600 to-emerald-600 rounded-lg border border-green-400"
                    style="display: none"
                  >
                    <div class="text-center">
                      <div class="text-2xl mb-2">🎉 恭喜找到要塞！ 🎉</div>
                      <div class="text-lg mb-3 text-green-100">
                        距离要塞仅
                        <span
                          id="final-distance"
                          class="font-bold text-yellow-300"
                          >0</span
                        >
                        格
                      </div>
                      <div class="grid grid-cols-2 gap-4 text-sm">
                        <div class="bg-black/20 p-2 rounded">
                          <div class="text-green-200">投掷次数</div>
                          <div class="font-bold text-xl" id="total-throws">
                            0
                          </div>
                        </div>
                        <div class="bg-black/20 p-2 rounded">
                          <div class="text-green-200">使用位置</div>
                          <div class="font-bold text-xl" id="total-positions">
                            0
                          </div>
                        </div>
                        <div class="bg-black/20 p-2 rounded">
                          <div class="text-green-200">平均误差</div>
                          <div class="font-bold text-xl" id="avg-error">0°</div>
                        </div>
                        <div class="bg-black/20 p-2 rounded">
                          <div class="text-green-200">最终精度</div>
                          <div class="font-bold text-xl" id="final-accuracy">
                            0%
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="flex justify-center space-x-4">
                  <button
                    id="throw-eye-btn"
                    class="px-6 py-2 bg-neon-purple text-dark-bg font-bold rounded-md hover:bg-neon-purple/80 transition-all duration-300"
                  >
                    投掷末影之眼 <i class="fa fa-eye ml-2"></i>
                  </button>
                  <button
                    id="move-player-btn"
                    class="px-6 py-2 bg-neon-blue text-white font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300"
                  >
                    移动玩家位置 <i class="fa fa-arrows-alt ml-2"></i>
                  </button>
                  <button
                    id="toggle-stronghold-btn"
                    class="px-6 py-2 bg-neon-orange text-dark-bg font-bold rounded-md hover:bg-neon-orange/80 transition-all duration-300"
                    style="display: none"
                  >
                    显示要塞位置 <i class="fa fa-map-marker ml-2"></i>
                  </button>
                  <button
                    id="reset-game-btn"
                    class="px-6 py-2 bg-red-600 text-white font-bold rounded-md hover:bg-red-700 transition-all duration-300"
                  >
                    重置游戏 <i class="fa fa-refresh ml-2"></i>
                  </button>
                </div>
              </div>
            </div>

            <div
              class="h-96 bg-dark-bg rounded-lg p-4 relative overflow-hidden"
            >
              <canvas
                id="minecraft-map"
                width="800"
                height="600"
                style="
                  width: 100%;
                  height: 100%;
                  image-rendering: pixelated;
                  cursor: crosshair;
                "
                class="border border-gray-600 rounded"
              >
              </canvas>
              <!-- 坐标显示 -->
              <div
                id="coordinate-display"
                class="absolute top-2 left-2 bg-black/70 text-white px-2 py-1 rounded text-xs font-mono"
              >
                坐标: (0, 0)
              </div>
              <!-- 缩放控制 -->
              <div class="absolute top-2 right-2 flex flex-col gap-1">
                <button
                  id="zoom-in"
                  class="bg-gray-700 hover:bg-gray-600 text-white w-8 h-8 rounded flex items-center justify-center text-sm"
                >
                  +
                </button>
                <button
                  id="zoom-out"
                  class="bg-gray-700 hover:bg-gray-600 text-white w-8 h-8 rounded flex items-center justify-center text-sm"
                >
                  -
                </button>
                <button
                  id="reset-view"
                  class="bg-gray-700 hover:bg-gray-600 text-white w-8 h-8 rounded flex items-center justify-center text-xs"
                >
                  ⌂
                </button>
              </div>
            </div>

            <div class="mt-4 text-sm text-gray-400">
              <p><strong>动态提示:</strong></p>
              <div id="minecraft-tips" class="text-neon-green">
                <p>开始投掷末影之眼来定位末地要塞！</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <script src="../static/js/toolbox.js"></script>
    <script>
      // 全局变量
      let rainAfterAlarmRatio = 0.6; // 真实的报警后下雨概率
      let currentSample = [];
      let allIntervals = [];
      let understandingScores = [0, 0, 0, 0, 0];
      let sonarData = [];
      let eyeData = [];
      let playerPosition = { x: 0, z: 0 }; // 玩家当前位置
      let isThrowingEye = false; // 防抖标志，防止快速连续点击
      let isMovingPlayer = false; // 移动玩家模式标志
      let showTruePosition = false; // 控制要塞位置显示

      // 在玩家位置为中心的1800x1800区域内随机生成要塞位置
      function generateRandomStrongholdPosition() {
        const range = 18000; // 1800*20/2 = 18000，以玩家为中心的半径（地图坐标）
        const randomX = playerPosition.x + (Math.random() - 0.5) * 2 * range;
        const randomZ = playerPosition.z + (Math.random() - 0.5) * 2 * range;
        return { x: randomX, z: randomZ };
      }

      // 延迟初始化要塞位置，确保playerPosition已定义
      let strongholdTruePosition = { x: 0, z: 0 }; // 临时初始化
      // 在页面加载完成后重新生成要塞位置
      setTimeout(() => {
        strongholdTruePosition = generateRandomStrongholdPosition();
      }, 100);

      // 声纳探测目标位置（动态获取要塞位置）
      function getSonarTruePosition() {
        // 将要塞位置转换为声纳坐标系统（x, y）
        return {
          x: strongholdTruePosition.x,
          y: strongholdTruePosition.z, // 将z坐标映射为y坐标
        };
      }
      // showTruePosition变量已在上方声明
      let canDeployBuoy = true; // 控制是否可以投放浮标

      // 地图缩放和滑动全局变量
      let mapZoom = 1;
      let mapOffsetX = 0;
      let mapOffsetY = 0;
      let isDragging = false;
      let lastMouseX = 0;
      let lastMouseY = 0;
      let minecraftMapZoom = 1;
      let minecraftMapOffsetX = 0;
      let minecraftMapOffsetY = 0;
      let minecraftIsDragging = false;
      let minecraftLastMouseX = 0;
      let minecraftLastMouseY = 0;
      let eyeThrowColors = [
        "#ff6b6b",
        "#4ecdc4",
        "#45b7d1",
        "#96ceb4",
        "#feca57",
        "#ff9ff3",
        "#54a0ff",
        "#5f27cd",
      ];
      let eyeThrowIndex = 0;

      // 初始化粒子背景
      function initParticles() {
        const container = document.getElementById("particles-container");
        for (let i = 0; i < 50; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";
          particle.style.left = Math.random() * 100 + "%";
          particle.style.top = Math.random() * 100 + "%";
          particle.style.width = Math.random() * 4 + 2 + "px";
          particle.style.height = particle.style.width;
          particle.style.backgroundColor = `hsl(${
            Math.random() * 60 + 180
          }, 70%, 60%)`;
          particle.style.animationDelay = Math.random() * 15 + "s";
          container.appendChild(particle);
        }
      }

      // 湿度警报器实验
      function sampleCandies() {
        const sampleSize = parseInt(
          document.getElementById("sample-size").value
        );
        const confidenceLevel = parseFloat(
          document.getElementById("confidence-level").value
        );

        // 生成样本（警报记录）
        currentSample = [];
        for (let i = 0; i < sampleSize; i++) {
          currentSample.push(
            Math.random() < rainAfterAlarmRatio ? "rain" : "no-rain"
          );
        }

        // 显示警报记录
        const candyDisplay = document.getElementById("candy-display");
        candyDisplay.innerHTML = "";
        currentSample.forEach((result, index) => {
          setTimeout(() => {
            const record = document.createElement("div");
            record.className = `alarm-record ${result}`;
            record.innerHTML =
              result === "rain"
                ? '<i class="fa fa-cloud-rain text-blue-400"></i>'
                : '<i class="fa fa-sun text-yellow-400"></i>';
            candyDisplay.appendChild(record);
          }, index * 50);
        });

        // 计算样本比例
        const rainCount = currentSample.filter((c) => c === "rain").length;
        const sampleProportion = rainCount / sampleSize;

        // 计算置信区间
        const z =
          confidenceLevel === 0.9
            ? 1.645
            : confidenceLevel === 0.95
            ? 1.96
            : 2.576;
        const standardError = Math.sqrt(
          (sampleProportion * (1 - sampleProportion)) / sampleSize
        );
        const marginError = z * standardError;
        const lowerBound = Math.max(0, sampleProportion - marginError);
        const upperBound = Math.min(1, sampleProportion + marginError);

        // 更新显示
        document.getElementById("sample-proportion").textContent =
          sampleProportion.toFixed(3);
        document.getElementById(
          "confidence-interval-text"
        ).textContent = `[${lowerBound.toFixed(3)}, ${upperBound.toFixed(3)}]`;
      }

      // 揭示真相
      function revealTruth() {
        alert(`真实的报警后下雨概率是: ${rainAfterAlarmRatio.toFixed(3)}`);
      }

      // 重复实验100次
      function repeatExperiment() {
        const sampleSize = parseInt(
          document.getElementById("sample-size").value
        );
        const confidenceLevel = parseFloat(
          document.getElementById("confidence-level").value
        );
        const z =
          confidenceLevel === 0.9
            ? 1.645
            : confidenceLevel === 0.95
            ? 1.96
            : 2.576;

        allIntervals = [];
        let successCount = 0;

        for (let exp = 0; exp < 100; exp++) {
          // 生成样本
          let rainCount = 0;
          for (let i = 0; i < sampleSize; i++) {
            if (Math.random() < rainAfterAlarmRatio) rainCount++;
          }

          const sampleProportion = rainCount / sampleSize;
          const standardError = Math.sqrt(
            (sampleProportion * (1 - sampleProportion)) / sampleSize
          );
          const marginError = z * standardError;
          const lowerBound = Math.max(0, sampleProportion - marginError);
          const upperBound = Math.min(1, sampleProportion + marginError);

          const containsTrue =
            lowerBound <= rainAfterAlarmRatio &&
            rainAfterAlarmRatio <= upperBound;
          if (containsTrue) successCount++;

          allIntervals.push({
            lower: lowerBound,
            upper: upperBound,
            containsTrue: containsTrue,
          });
        }

        // 更新显示
        document.getElementById("success-count").textContent = successCount;
        document.getElementById("total-intervals").textContent = "100";
        document.getElementById("success-rate").textContent =
          successCount + "%";

        // 可视化区间
        visualizeIntervals();
      }

      // 可视化置信区间
      function visualizeIntervals() {
        const container = document.getElementById("intervals-container");
        container.innerHTML = "";

        // 添加区间
        allIntervals.forEach((interval, index) => {
          const intervalDiv = document.createElement("div");
          intervalDiv.className = `confidence-interval ${
            interval.containsTrue ? "contains-true" : "misses-true"
          }`;
          intervalDiv.style.left = interval.lower * 100 + "%";
          intervalDiv.style.width =
            (interval.upper - interval.lower) * 100 + "%";
          intervalDiv.style.top = index * 3 + "px";
          intervalDiv.title = `区间 ${index + 1}: [${interval.lower.toFixed(
            3
          )}, ${interval.upper.toFixed(3)}]`;
          container.appendChild(intervalDiv);
        });

        // 设置容器高度 - 这是容器的可视高度
        const containerVisibleHeight = 320; // 固定可视高度
        container.style.height = containerVisibleHeight + "px";
        console.log("容器可视高度设置为:", containerVisibleHeight + "px");
        console.log("置信区间总数:", allIntervals.length);

        // 添加真实值线
        const trueLine = document.createElement("div");
        trueLine.className = "true-value-line";
        trueLine.style.left = rainAfterAlarmRatio * 100 + "%";

        // 等待DOM更新后获取实际的scrollHeight
        setTimeout(() => {
          const actualScrollHeight = container.scrollHeight;
          console.log("容器实际scrollHeight:", actualScrollHeight + "px");

          // 使用实际的scrollHeight设置真实值线高度
          trueLine.style.height = actualScrollHeight + "px";
          console.log("真实值线高度更新为:", actualScrollHeight + "px");
        }, 50);

        console.log("真实值线位置设置为:", rainAfterAlarmRatio * 100 + "%");
        container.appendChild(trueLine);

        // 调试信息：检查容器和线条的实际尺寸
        setTimeout(() => {
          const containerRect = container.getBoundingClientRect();
          const lineRect = trueLine.getBoundingClientRect();
          console.log("容器实际尺寸:", {
            width: containerRect.width,
            height: containerRect.height,
            scrollHeight: container.scrollHeight,
          });
          console.log("真实值线实际尺寸:", {
            width: lineRect.width,
            height: lineRect.height,
            top: lineRect.top,
            left: lineRect.left,
          });
          console.log("内容实际高度:", actualContentHeight + "px");
        }, 100);
      }

      // 理解度评分
      function setUnderstanding(step, level) {
        understandingScores[step - 1] = level;

        // 更新按钮状态
        const buttons = document.querySelectorAll(
          `[data-step="${step}"] .understanding-btn`
        );
        buttons.forEach((btn, index) => {
          btn.classList.toggle("selected", index + 1 === level);
        });

        // 显示下一步提示
        const currentStep = document.querySelector(`[data-step="${step}"]`);
        const nextStepHint = currentStep.querySelector(".next-step-hint");
        if (level >= 3 && nextStepHint) {
          nextStepHint.classList.remove("hidden");
        }

        // 渐进式解锁下一步
        if (level >= 3 && step < 5) {
          unlockNextStep(step + 1);
        }

        // 检查是否所有步骤都已评分
        if (understandingScores.every((score) => score > 0)) {
          showUnderstandingRadar();
        }
      }

      // 解锁下一步
      function unlockNextStep(step) {
        const nextStepElement = document.querySelector(`[data-step="${step}"]`);
        if (nextStepElement && nextStepElement.classList.contains("locked")) {
          // 移除锁定状态
          nextStepElement.classList.remove("locked");
          nextStepElement.classList.add("unlocked");

          // 更新标题样式
          const title = nextStepElement.querySelector("h3");
          const stepNumber = nextStepElement.querySelector("h3 span");
          const lockIcon = nextStepElement.querySelector(".fa-lock");

          title.classList.remove("text-gray-500");
          title.classList.add("text-neon-blue");
          stepNumber.classList.remove("bg-gray-600", "text-gray-400");
          stepNumber.classList.add("bg-neon-blue", "text-dark-bg");

          if (lockIcon) {
            lockIcon.parentElement.innerHTML =
              '<i class="fa fa-unlock text-neon-green"></i>';
          }

          // 恢复内容透明度
          const content = nextStepElement.querySelector(".message-content");
          content.classList.remove("opacity-50");

          // 显示理解度内容，隐藏锁定消息
          const lockedMessage =
            nextStepElement.querySelector(".locked-message");
          const understandingContent = nextStepElement.querySelector(
            ".understanding-content"
          );

          if (lockedMessage) lockedMessage.classList.add("hidden");
          if (understandingContent)
            understandingContent.classList.remove("hidden");
        }
      }

      // AI帮助功能
      function showAIHelp(step) {
        const helpTexts = {
          1: "点估计是用样本统计量来估计总体参数的方法。样本均值是总体均值的无偏估计量，这意味着在多次抽样中，样本均值的期望值等于总体均值。",
          2: "中心极限定理告诉我们，当样本量足够大时，样本均值的分布会趋向于正态分布，无论原总体是什么分布。这为我们构造置信区间提供了理论基础。",
          3: "枢轴量是一个包含未知参数但其分布已知的统计量。通过标准化，我们得到了服从标准正态分布的Z统计量。",
          4: "利用标准正态分布的性质，我们可以找到使得Z落在某个区间内的概率为1-α的临界值。这些临界值帮助我们构造置信区间。",
          5: "通过代数变换，我们将包含Z的不等式转换为包含μ的不等式，从而得到置信区间的最终形式。注意乘以负数时不等号要变向！",
        };

        alert(`AI助手提示：\n\n${helpTexts[step] || "暂无帮助信息"}`);
      }

      // 显示理解度图谱
      function showUnderstandingRadar() {
        const radarSection = document.getElementById("understanding-radar");
        radarSection.classList.remove("hidden");

        // 创建雷达图
        const ctx = document
          .getElementById("understanding-chart")
          .getContext("2d");
        new Chart(ctx, {
          type: "radar",
          data: {
            labels: ["点估计", "CLT", "枢轴量", "概率表述", "求解"],
            datasets: [
              {
                label: "理解程度",
                data: understandingScores,
                backgroundColor: "rgba(0, 243, 255, 0.2)",
                borderColor: "#00f3ff",
                pointBackgroundColor: "#00f3ff",
                pointBorderColor: "#fff",
                pointHoverBackgroundColor: "#fff",
                pointHoverBorderColor: "#00f3ff",
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              r: {
                beginAtZero: true,
                max: 5,
                ticks: {
                  color: "#9ca3af",
                },
                grid: {
                  color: "rgba(156, 163, 175, 0.3)",
                },
                angleLines: {
                  color: "rgba(156, 163, 175, 0.3)",
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "#ffffff",
                },
              },
            },
          },
        });

        // 更新学习数据分析
        updateLearningAnalysis();
      }

      // 更新学习数据分析
      function updateLearningAnalysis() {
        const stepNames = [
          "点估计",
          "中心极限定理",
          "枢轴量构造",
          "概率表述",
          "代数求解",
        ];

        // 计算平均理解度
        const avgScore = (
          understandingScores.reduce((a, b) => a + b, 0) /
          understandingScores.length
        ).toFixed(1);
        document.getElementById("avg-understanding").textContent =
          avgScore + "/5.0";

        // 找出最薄弱和最强的环节
        const minScore = Math.min(...understandingScores);
        const maxScore = Math.max(...understandingScores);
        const weakestIndex = understandingScores.indexOf(minScore);
        const strongestIndex = understandingScores.indexOf(maxScore);

        document.getElementById("weakest-step").textContent =
          stepNames[weakestIndex] + ` (${minScore}/5)`;
        document.getElementById("strongest-step").textContent =
          stepNames[strongestIndex] + ` (${maxScore}/5)`;

        // 计算完成时间（模拟）
        const completionTime = new Date().toLocaleTimeString("zh-CN", {
          hour12: false,
        });
        document.getElementById("completion-time").textContent = completionTime;

        // 生成个性化学习建议
        generateLearningSuggestions(avgScore, weakestIndex, minScore);
      }

      // 生成个性化学习建议
      function generateLearningSuggestions(avgScore, weakestIndex, minScore) {
        const stepNames = [
          "点估计",
          "中心极限定理",
          "枢轴量构造",
          "概率表述",
          "代数求解",
        ];
        const suggestions = [];

        if (avgScore >= 4.0) {
          suggestions.push("🎉 优秀！您已经很好地掌握了区间估计的核心概念。");
          suggestions.push(
            "💡 建议：可以尝试更复杂的置信区间问题，如t分布、卡方分布等。"
          );
        } else if (avgScore >= 3.0) {
          suggestions.push("👍 不错！您对大部分概念有了基本理解。");
          suggestions.push(
            `🔍 重点关注：${stepNames[weakestIndex]}部分需要加强理解。`
          );
        } else {
          suggestions.push("📚 需要更多练习！建议重新学习基础概念。");
          suggestions.push(
            `⚠️ 优先复习：${stepNames[weakestIndex]}是当前的薄弱环节。`
          );
        }

        if (minScore <= 2) {
          const helpTexts = {
            0: "建议复习概率论基础，特别是期望值和无偏估计的概念。",
            1: "建议复习正态分布和极限定理，这是理解CLT的关键。",
            2: "建议复习标准化过程，理解如何构造已知分布的统计量。",
            3: "建议复习概率计算，特别是标准正态分布的性质。",
            4: "建议复习代数运算，特别是不等式变换的规则。",
          };
          suggestions.push(`📖 具体建议：${helpTexts[weakestIndex]}`);
        }

        document.getElementById("learning-suggestions").innerHTML =
          suggestions.join("<br>");
      }

      // 声纳浮标实验
      let sonarDeploymentAnimation = null;

      // 单次投放浮标
      function deploySingleSonar() {
        deployBuoys(1, "single");
      }

      // 批量投放浮标
      function deployBatchSonar() {
        deployBuoys(10, "batch");
      }

      // 通用投放浮标函数
      function deployBuoys(count, mode) {
        // 检查是否可以投放浮标
        if (!canDeployBuoy) {
          return;
        }

        const confidenceLevel = parseFloat(
          document.getElementById("sonar-confidence").value
        );
        const sonarAccuracy = parseFloat(
          document.getElementById("sonar-accuracy").value
        );

        // 禁用投放按钮
        canDeployBuoy = false;
        const singleBtn = document.getElementById("deploy-single-btn");
        const batchBtn = document.getElementById("deploy-batch-btn");

        // 禁用所有投放按钮
        singleBtn.disabled = true;
        batchBtn.disabled = true;

        // 添加部署动画效果
        const activeBtn = mode === "single" ? singleBtn : batchBtn;
        activeBtn.classList.add("button-click-effect");
        setTimeout(
          () => activeBtn.classList.remove("button-click-effect"),
          300
        );

        if (mode === "single") {
          activeBtn.innerHTML =
            '投放中... <i class="fa fa-spinner fa-spin ml-2"></i>';
        } else {
          activeBtn.innerHTML =
            '批量投放中... <i class="fa fa-spinner fa-spin ml-2"></i>';
        }

        // 模拟逐个部署浮标的动画
        let deployedCount = 0;
        const deployInterval = setInterval(
          () => {
            if (deployedCount < count) {
              // 模拟声纳探测，基于选择的精度添加随机误差
              // 使用正态分布生成更真实的声纳误差
              const errorX = normalRandom(0, sonarAccuracy);
              const errorY = normalRandom(0, sonarAccuracy);
              const truePos = getSonarTruePosition();
              sonarData.push({
                x: truePos.x + errorX,
                y: truePos.y + errorY,
                deployed: true,
                timestamp: Date.now() + deployedCount * 100, // 用于动画排序
              });
              deployedCount++;

              // 实时更新地图显示
              if (sonarData.length >= 1) {
                calculateAndDisplayResults(confidenceLevel);
              }

              // 添加数据点动画效果（移除canvas旋转动画）
              // 注释掉canvas动画，避免整个地图旋转
              // const canvas = document.getElementById("sonar-map");
              // if (canvas) {
              //   canvas.classList.add("data-point-enter");
              //   setTimeout(
              //     () => canvas.classList.remove("data-point-enter"),
              //     600
              //   );
              // }
            } else {
              clearInterval(deployInterval);

              // 恢复按钮状态
              singleBtn.innerHTML =
                '投放1个浮标 <i class="fa fa-anchor ml-2"></i>';
              batchBtn.innerHTML =
                '投放10个浮标 <i class="fa fa-ship ml-2"></i>';
              singleBtn.disabled = false;
              batchBtn.disabled = false;

              activeBtn.classList.add("success-flash");
              setTimeout(
                () => activeBtn.classList.remove("success-flash"),
                600
              );

              // 重新启用投放功能
              canDeployBuoy = true;
              calculateAndDisplayResults(confidenceLevel);

              // 显示投放完成提示
              showDeploymentSuccess(count, mode);
            }
          },
          mode === "single" ? 500 : 150
        ); // 单次投放慢一些，批量投放快一些
      }

      // 显示投放成功提示
      function showDeploymentSuccess(count, mode) {
        const message =
          mode === "single"
            ? `成功投放1个声纳浮标！当前共有${sonarData.length}个数据点。`
            : `成功批量投放${count}个声纳浮标！当前共有${sonarData.length}个数据点。`;

        // 创建临时提示元素
        const notification = document.createElement("div");
        notification.className =
          "fixed top-4 right-4 bg-neon-green text-dark-bg px-4 py-2 rounded-lg font-bold z-50 transform translate-x-full transition-transform duration-300";
        notification.textContent = message;
        document.body.appendChild(notification);

        // 显示动画
        setTimeout(() => {
          notification.classList.remove("translate-x-full");
        }, 100);

        // 隐藏动画
        setTimeout(() => {
          notification.classList.add("translate-x-full");
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 300);
        }, 3000);
      }

      function calculateAndDisplayResults(confidenceLevel) {
        if (sonarData.length < 2) return;

        const sonarCount = sonarData.length;

        // 计算平均位置
        const avgX =
          sonarData.reduce((sum, point) => sum + point.x, 0) / sonarCount;
        const avgY =
          sonarData.reduce((sum, point) => sum + point.y, 0) / sonarCount;

        // 计算标准差
        const stdX = Math.sqrt(
          sonarData.reduce(
            (sum, point) => sum + Math.pow(point.x - avgX, 2),
            0
          ) / Math.max(1, sonarCount - 1)
        );
        const stdY = Math.sqrt(
          sonarData.reduce(
            (sum, point) => sum + Math.pow(point.y - avgY, 2),
            0
          ) / Math.max(1, sonarCount - 1)
        );

        // t分布临界值（根据自由度调整）
        const df = Math.max(1, sonarCount - 1);
        let t;
        if (confidenceLevel === 0.9) {
          t =
            df <= 10
              ? [
                  0, 6.314, 2.92, 2.353, 2.132, 2.015, 1.943, 1.895, 1.86,
                  1.833, 1.812,
                ][df] || 1.729
              : 1.645;
        } else if (confidenceLevel === 0.95) {
          t =
            df <= 10
              ? [
                  0, 12.706, 4.303, 3.182, 2.776, 2.571, 2.447, 2.365, 2.306,
                  2.262, 2.228,
                ][df] || 2.093
              : 1.96;
        } else {
          t =
            df <= 10
              ? [
                  0, 63.657, 9.925, 5.841, 4.604, 4.032, 3.707, 3.499, 3.355,
                  3.25, 3.169,
                ][df] || 2.861
              : 2.576;
        }

        const marginX = (t * stdX) / Math.sqrt(sonarCount);
        const marginY = (t * stdY) / Math.sqrt(sonarCount);

        // 更新显示并添加动画效果
        const positionElement = document.getElementById("estimated-position");
        const areaElement = document.getElementById("search-area");

        // 添加结果显示动画
        positionElement.classList.add("result-slide-in");
        areaElement.classList.add("result-slide-in");

        positionElement.textContent = `(${avgX.toFixed(2)}, ${avgY.toFixed(
          2
        )})`;
        const searchArea = 4 * marginX * marginY; // 矩形面积
        areaElement.textContent = searchArea.toFixed(2) + " km²";

        // 移除动画类
        setTimeout(() => {
          positionElement.classList.remove("result-slide-in");
          areaElement.classList.remove("result-slide-in");
        }, 600);

        // 绘制声纳地图
        drawSonarMap(avgX, avgY, marginX, marginY);
      }

      // 揭示真实炮弹位置
      function revealShellPosition() {
        // 检查是否有浮标数据
        if (sonarData.length === 0) {
          alert("请先投放一些声纳浮标再揭示真实位置！");
          return;
        }

        // 显示真实位置
        showTruePosition = true;

        // 添加按钮点击动画
        const revealBtn = document.getElementById("reveal-shell-btn");
        if (revealBtn) {
          revealBtn.classList.add("button-click-effect");
          setTimeout(
            () => revealBtn.classList.remove("button-click-effect"),
            300
          );
        }

        // 重新绘制地图以显示真实位置
        const confidenceLevel = parseFloat(
          document.getElementById("sonar-confidence").value
        );
        calculateAndDisplayResults(confidenceLevel);

        // 添加闪烁效果和教学反馈
        const canvas = document.getElementById("sonar-map");
        const ctx = canvas.getContext("2d");
        let flashCount = 0;
        const flashInterval = setInterval(() => {
          if (flashCount < 6) {
            // 重新绘制地图
            calculateAndDisplayResults(confidenceLevel);

            // 添加闪烁的真实位置
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            ctx.scale(dpr, dpr);

            const toCanvasX = (x) => ((x + 3) * rect.width) / 6;
            const toCanvasY = (y) => ((3 - y) * rect.height) / 6;

            const truePos = getSonarTruePosition();
            ctx.fillStyle = flashCount % 2 === 0 ? "#ffd700" : "#ff4444";
            ctx.beginPath();
            ctx.arc(
              toCanvasX(truePos.x),
              toCanvasY(truePos.y),
              8,
              0,
              2 * Math.PI
            );
            ctx.fill();

            // 添加文字标签
            ctx.fillStyle = "#ffffff";
            ctx.font = "bold 12px Arial";
            ctx.fillText(
              "真实位置",
              toCanvasX(truePos.x) + 12,
              toCanvasY(truePos.y) - 8
            );

            flashCount++;
          } else {
            clearInterval(flashInterval);
            // 显示教学反馈
            showPredictionFeedback();
          }
        }, 400);
      }

      // 显示预测反馈
      function showPredictionFeedback() {
        const truePos = getSonarTruePosition();
        const confidenceLevel = parseFloat(
          document.getElementById("sonar-confidence").value
        );

        if (sonarData.length === 0) return;

        // 计算置信区间
        const n = sonarData.length;
        const avgX = sonarData.reduce((sum, d) => sum + d.x, 0) / n;
        const avgY = sonarData.reduce((sum, d) => sum + d.y, 0) / n;

        const stdX = Math.sqrt(
          sonarData.reduce((sum, d) => sum + Math.pow(d.x - avgX, 2), 0) /
            (n - 1)
        );
        const stdY = Math.sqrt(
          sonarData.reduce((sum, d) => sum + Math.pow(d.y - avgY, 2), 0) /
            (n - 1)
        );

        // 获取t分布临界值
        const alpha = 1 - confidenceLevel;
        const df = n - 1;
        const t =
          df >= 30
            ? 1.96
            : [
                0, 12.706, 4.303, 3.182, 2.776, 2.571, 2.447, 2.365, 2.306,
                2.262, 2.228, 2.201, 2.179, 2.16, 2.145, 2.131, 2.12, 2.11,
                2.101, 2.093, 2.086, 2.08, 2.074, 2.069, 2.064, 2.06, 2.056,
                2.052, 2.048, 2.045, 2.042,
              ][df] || 1.96;

        const marginX = (t * stdX) / Math.sqrt(n);
        const marginY = (t * stdY) / Math.sqrt(n);

        // 检查真实位置是否在置信区间内
        const inConfidenceX =
          truePos.x >= avgX - marginX && truePos.x <= avgX + marginX;
        const inConfidenceY =
          truePos.y >= avgY - marginY && truePos.y <= avgY + marginY;
        const inConfidenceRegion = inConfidenceX && inConfidenceY;

        // 计算估计误差
        const errorX = Math.abs(truePos.x - avgX);
        const errorY = Math.abs(truePos.y - avgY);
        const totalError = Math.sqrt(errorX * errorX + errorY * errorY);

        // 生成反馈消息
        let message = `🎯 **预测结果分析**\n\n`;
        message += `📍 真实炮弹位置: (${truePos.x.toFixed(
          2
        )}, ${truePos.y.toFixed(2)})\n`;
        message += `📊 估计位置: (${avgX.toFixed(2)}, ${avgY.toFixed(2)})\n`;
        message += `📏 估计误差: ${totalError.toFixed(2)} km\n\n`;

        if (inConfidenceRegion) {
          message += `✅ **预测成功！**\n`;
          message += `真实位置落在了${(confidenceLevel * 100).toFixed(
            0
          )}%置信区间内。\n`;
          message += `这证明了区间估计的有效性！\n\n`;
        } else {
          message += `❌ **预测未完全成功**\n`;
          message += `真实位置未完全落在${(confidenceLevel * 100).toFixed(
            0
          )}%置信区间内。\n`;
          message += `这是${((1 - confidenceLevel) * 100).toFixed(
            0
          )}%的小概率事件，属于正常现象。\n\n`;
        }

        message += `💡 **教学要点：**\n`;
        message += `• 样本量越大，估计越准确\n`;
        message += `• 置信水平越高，置信区间越宽\n`;
        message += `• 声纳精度影响测量误差\n`;
        message += `• 即使预测"失败"，也在统计预期内`;

        // 将消息显示在网页中而不是alert弹窗
        displayFeedbackInPage(message);
      }

      // 在网页中显示反馈信息
      function displayFeedbackInPage(message) {
        const feedbackDiv = document.getElementById("prediction-feedback");
        const contentDiv = document.getElementById("feedback-content");

        // 将markdown格式的消息转换为HTML
        let htmlContent = message
          .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>") // 粗体
          .replace(/\n/g, "<br>") // 换行
          .replace(
            /^([🎯📍📊📏✅❌💡].*?):/gm,
            '<div class="mb-2"><span class="text-neon-blue">$1:</span></div>'
          ) // 图标行
          .replace(/^• (.*?)$/gm, '<div class="ml-4 text-gray-400">• $1</div>'); // 列表项

        contentDiv.innerHTML = htmlContent;
        feedbackDiv.style.display = "block";

        // 滚动到反馈区域
        feedbackDiv.scrollIntoView({ behavior: "smooth", block: "nearest" });
      }

      // 绘制声纳地图
      function drawSonarMap(avgX, avgY, marginX, marginY) {
        const canvas = document.getElementById("sonar-map");
        const ctx = canvas.getContext("2d");

        // 获取设备像素比以提升清晰度
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        // 设置canvas实际分辨率（考虑设备像素比）
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;

        // 设置canvas显示尺寸
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";

        // 缩放绘图上下文以匹配设备像素比
        ctx.scale(dpr, dpr);

        // 启用抗锯齿
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        ctx.clearRect(0, 0, rect.width, rect.height);

        // 保存上下文（固定显示，无变换）
        ctx.save();
        // 移除缩放和平移变换以保持固定显示范围
        // ctx.translate(mapOffsetX, mapOffsetY);
        // ctx.scale(mapZoom, mapZoom);

        // 坐标转换函数（固定显示范围）
        // 计算实际数据范围，然后映射到固定的canvas显示区域
        let dataMinX = -3,
          dataMaxX = 3,
          dataMinY = -3,
          dataMaxY = 3;

        if (sonarData.length > 0) {
          // 计算实际数据范围
          dataMinX = Math.min(...sonarData.map((p) => p.x));
          dataMaxX = Math.max(...sonarData.map((p) => p.x));
          dataMinY = Math.min(...sonarData.map((p) => p.y));
          dataMaxY = Math.max(...sonarData.map((p) => p.y));

          // 添加一些边距以确保数据点不会贴边
          const rangeX = dataMaxX - dataMinX || 1;
          const rangeY = dataMaxY - dataMinY || 1;
          const marginX = rangeX * 0.1;
          const marginY = rangeY * 0.1;

          dataMinX -= marginX;
          dataMaxX += marginX;
          dataMinY -= marginY;
          dataMaxY += marginY;
        }

        const padding = 20;
        const scaleX = (rect.width - 2 * padding) / (dataMaxX - dataMinX);
        const scaleY = (rect.height - 2 * padding) / (dataMaxY - dataMinY);

        const toCanvasX = (x) => (x - dataMinX) * scaleX + padding;
        const toCanvasY = (y) =>
          rect.height - ((y - dataMinY) * scaleY + padding);

        // 调试输出坐标转换参数
        console.log("声纳地图坐标转换参数:", {
          canvasWidth: rect.width,
          canvasHeight: rect.height,
          mapZoom: mapZoom,
          mapOffsetX: mapOffsetX,
          mapOffsetY: mapOffsetY,
          dataRange: { dataMinX, dataMaxX, dataMinY, dataMaxY },
          scale: { scaleX, scaleY },
          padding: padding,
        });
        console.log("声纳数据状态:", {
          sonarDataLength: sonarData.length,
          avgX: avgX,
          avgY: avgY,
          showTruePosition: showTruePosition,
        });

        // 绘制网格
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= 6; i++) {
          ctx.beginPath();
          ctx.moveTo((i * rect.width) / 6, 0);
          ctx.lineTo((i * rect.width) / 6, rect.height);
          ctx.stroke();
        }
        for (let i = 0; i <= 6; i++) {
          ctx.beginPath();
          ctx.moveTo(0, (i * rect.height) / 6);
          ctx.lineTo(rect.width, (i * rect.height) / 6);
          ctx.stroke();
        }

        // 绘制坐标轴标签
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";

        // X轴标签
        for (let i = 0; i <= 6; i++) {
          const x = (i * rect.width) / 6;
          const label = (i - 3).toString();
          ctx.fillText(label, x, rect.height - 5);
        }

        // Y轴标签
        ctx.textAlign = "left";
        for (let i = 0; i <= 6; i++) {
          const y = (i * rect.height) / 6;
          const label = (3 - i).toString();
          ctx.fillText(label, 5, y + 4);
        }

        // 绘制坐标轴
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 2;
        // X轴 (y=0)
        ctx.beginPath();
        ctx.moveTo(0, toCanvasY(0));
        ctx.lineTo(rect.width, toCanvasY(0));
        ctx.stroke();
        // Y轴 (x=0)
        ctx.beginPath();
        ctx.moveTo(toCanvasX(0), 0);
        ctx.lineTo(toCanvasX(0), rect.height);
        ctx.stroke();

        // 添加标题
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText("声纳探测区域 (km)", rect.width / 2, 20);

        // 绘制置信区域（仅当有数据时）
        if (sonarData.length > 0 && marginX > 0 && marginY > 0) {
          ctx.fillStyle = "rgba(0, 243, 255, 0.2)";
          ctx.strokeStyle = "#00f3ff";
          ctx.lineWidth = 2;
          const rectX = toCanvasX(avgX - marginX);
          const rectY = toCanvasY(avgY + marginY);
          const rectW = toCanvasX(avgX + marginX) - rectX;
          const rectH = toCanvasY(avgY - marginY) - rectY;
          ctx.fillRect(rectX, rectY, rectW, rectH);
          ctx.strokeRect(rectX, rectY, rectW, rectH);
        }

        // 绘制声纳探测点（添加描边以提高可见性）
        console.log("绘制声纳探测点，数据长度:", sonarData.length);
        sonarData.forEach((point, index) => {
          const canvasX = toCanvasX(point.x);
          const canvasY = toCanvasY(point.y);
          console.log(
            `探测点${index + 1}: 原始坐标(${point.x}, ${
              point.y
            }) -> canvas坐标(${canvasX}, ${canvasY})`
          );

          ctx.fillStyle = "#00ff66";
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();

          // 添加探测点标签
          ctx.fillStyle = "#ffffff";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          ctx.fillText((index + 1).toString(), canvasX, canvasY - 8);
        });

        // 绘制估计位置（仅当有数据时）
        if (sonarData.length > 0) {
          const estCanvasX = toCanvasX(avgX);
          const estCanvasY = toCanvasY(avgY);
          console.log(
            `估计位置: 原始坐标(${avgX}, ${avgY}) -> canvas坐标(${estCanvasX}, ${estCanvasY})`
          );

          ctx.fillStyle = "#00f3ff";
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(estCanvasX, estCanvasY, 6, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();

          // 添加估计位置标签
          ctx.fillStyle = "#ffffff";
          ctx.font = "12px Arial";
          ctx.textAlign = "left";
          ctx.fillText("估计位置", estCanvasX + 10, estCanvasY - 5);
        } else {
          console.log("没有声纳数据，跳过绘制估计位置");
        }

        // 绘制真实位置（仅在显示状态下）
        if (showTruePosition) {
          const truePos = getSonarTruePosition();

          // 如果真实位置超出当前数据范围，扩展范围重新计算坐标转换
          let adjustedMinX = dataMinX,
            adjustedMaxX = dataMaxX,
            adjustedMinY = dataMinY,
            adjustedMaxY = dataMaxY;
          if (
            truePos.x < dataMinX ||
            truePos.x > dataMaxX ||
            truePos.y < dataMinY ||
            truePos.y > dataMaxY
          ) {
            adjustedMinX = Math.min(dataMinX, truePos.x - 0.5);
            adjustedMaxX = Math.max(dataMaxX, truePos.x + 0.5);
            adjustedMinY = Math.min(dataMinY, truePos.y - 0.5);
            adjustedMaxY = Math.max(dataMaxY, truePos.y + 0.5);

            const adjustedScaleX =
              (rect.width - 2 * padding) / (adjustedMaxX - adjustedMinX);
            const adjustedScaleY =
              (rect.height - 2 * padding) / (adjustedMaxY - adjustedMinY);

            const trueCanvasX =
              (truePos.x - adjustedMinX) * adjustedScaleX + padding;
            const trueCanvasY =
              rect.height -
              ((truePos.y - adjustedMinY) * adjustedScaleY + padding);

            console.log(
              `真实位置(扩展范围): 原始坐标(${truePos.x}, ${truePos.y}) -> canvas坐标(${trueCanvasX}, ${trueCanvasY})`
            );

            ctx.fillStyle = "#ffd700";
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(trueCanvasX, trueCanvasY, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // 添加真实位置标签
            ctx.fillStyle = "#ffffff";
            ctx.font = "12px Arial";
            ctx.textAlign = "left";
            ctx.fillText("真实位置", trueCanvasX + 10, trueCanvasY - 5);
          } else {
            const trueCanvasX = toCanvasX(truePos.x);
            const trueCanvasY = toCanvasY(truePos.y);
            console.log(
              `真实位置: 原始坐标(${truePos.x}, ${truePos.y}) -> canvas坐标(${trueCanvasX}, ${trueCanvasY})`
            );

            ctx.fillStyle = "#ffd700";
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(trueCanvasX, trueCanvasY, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();

            // 添加真实位置标签
            ctx.fillStyle = "#ffffff";
            ctx.font = "12px Arial";
            ctx.textAlign = "left";
            ctx.fillText("真实位置", trueCanvasX + 10, trueCanvasY - 5);
          }
        } else {
          console.log("真实位置未显示，showTruePosition =", showTruePosition);
        }

        // 添加图例
        addLegend(ctx, showTruePosition);

        // 恢复变换
        ctx.restore();
      }

      // 更新我的世界提示
      function updateMinecraftTips() {
        const tipsElement = document.getElementById("minecraft-tips");
        const throwCount = eyeData.length;

        if (throwCount === 0) {
          tipsElement.innerHTML = "<p>开始投掷末影之眼来定位末地要塞！</p>";
        } else if (throwCount < 3) {
          tipsElement.innerHTML = `<p>已投掷 ${throwCount} 次，至少需要 3 次才能进行三角定位。</p>`;
        } else if (throwCount < 8) {
          tipsElement.innerHTML = `<p>已投掷 ${throwCount} 次，数据越多定位越准确！建议继续投掷。</p>`;
        } else {
          tipsElement.innerHTML = `<p>已投掷 ${throwCount} 次，数据充足！可以开始挖掘寻找要塞。</p>`;
        }
      }

      // 添加图例函数
      function addLegend(ctx, showTruePosition) {
        ctx.fillStyle = "#ffffff";
        ctx.font = "12px Arial";
        let legendY = 20;
        if (showTruePosition) {
          ctx.fillText("🟡 真实位置", 10, legendY);
          legendY += 15;
        }
        ctx.fillText("🔵 估计位置", 10, legendY);
        legendY += 15;
        ctx.fillText("🟢 声纳探测", 10, legendY);
        legendY += 15;
        ctx.fillText("🔷 置信区域", 10, legendY);
      }

      // 重置搜索
      function resetSearch() {
        sonarData = [];
        showTruePosition = false; // 重置时隐藏真实位置
        canDeployBuoy = true; // 重新启用浮标投放
        document.getElementById("estimated-position").textContent =
          "(0.0, 0.0)";
        document.getElementById("search-area").textContent = "-- km²";

        // 隐藏反馈信息区域
        const feedbackDiv = document.getElementById("prediction-feedback");
        if (feedbackDiv) {
          feedbackDiv.style.display = "none";
        }

        const canvas = document.getElementById("sonar-map");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 重新绘制基础地图
        drawSonarMap(0, 0, 0, 0);

        // 添加按钮点击动画
        const resetBtn = document.getElementById("reset-search-btn");
        if (resetBtn) {
          resetBtn.classList.add("button-click-effect");
          setTimeout(
            () => resetBtn.classList.remove("button-click-effect"),
            300
          );
        }

        // 显示重置提示
        setTimeout(() => {
          ctx.fillStyle = "rgba(0, 150, 255, 0.8)";
          ctx.font = "16px Arial";
          ctx.fillText("搜索已重置，请重新投放浮标", 20, 30);

          setTimeout(() => {
            drawSonarMap(0, 0, 0, 0);
          }, 2000);
        }, 100);
      }

      // 末影之眼实验
      let bayesianPosterior = null;

      function throwEye() {
        // 防抖：防止用户快速连续点击
        if (isThrowingEye) {
          console.log("🚫 防抖：忽略重复点击");
          return;
        }
        isThrowingEye = true;
        console.log("🎯 开始投掷末影之眼，当前投掷次数:", eyeData.length + 1);
        const startTime = performance.now();

        // 添加按钮点击动画效果
        const throwBtn = document.getElementById("throw-eye-btn");
        if (throwBtn) {
          throwBtn.classList.add("button-click-effect");
          setTimeout(
            () => throwBtn.classList.remove("button-click-effect"),
            300
          );
        }

        const eyeCount = parseInt(document.getElementById("eye-count").value);
        const confidenceLevel = parseFloat(
          document.getElementById("eye-confidence").value
        );
        const statisticalMethod =
          document.getElementById("statistical-method").value;
        const priorDistribution =
          document.getElementById("prior-distribution").value;

        // 真实的末影之眼投掷机制：16格圆圈内正态分布角度
        const distance = Math.sqrt(
          Math.pow(strongholdTruePosition.x - playerPosition.x, 2) +
            Math.pow(strongholdTruePosition.z - playerPosition.z, 2)
        );

        // 真实角度（从玩家到要塞）
        const trueAngle = Math.atan2(
          strongholdTruePosition.z - playerPosition.z,
          strongholdTruePosition.x - playerPosition.x
        );

        // 角度误差：符合正态分布，标准差约为π/36（5度）
        const angleError = normalRandom(0, Math.PI / 36);
        const observedAngle = trueAngle + angleError;

        // 末影之眼落在距离玩家16格（地图坐标320）的圆圈上
        const eyeThrowRadius = 320;

        // 计算末影之眼在16格圆圈上的落点
        const eyeX =
          playerPosition.x + Math.cos(observedAngle) * eyeThrowRadius;
        const eyeZ =
          playerPosition.z + Math.sin(observedAngle) * eyeThrowRadius;

        // 记录投掷数据，包含颜色信息用于可视化
        const throwColor =
          eyeThrowColors[eyeThrowIndex % eyeThrowColors.length];
        eyeData.push({
          x: eyeX,
          z: eyeZ,
          angle: observedAngle,
          trueAngle: trueAngle,
          angleError: angleError,
          distance: distance,
          color: throwColor,
          timestamp: Date.now(),
          // 保存投掷时的玩家位置快照，确保角度置信区间独立
          playerPosition: {
            x: playerPosition.x,
            z: playerPosition.z,
          },
        });

        eyeThrowIndex++;

        if (eyeData.length >= 3) {
          console.log("🎯 开始统计计算，方法:", statisticalMethod);
          if (statisticalMethod === "bayesian") {
            calculateBayesianPosition(confidenceLevel, priorDistribution);
            console.log("🎯 贝叶斯计算调用完成");
          } else {
            calculateStrongholdPosition(confidenceLevel);
            console.log("🎯 经典统计计算完成");
          }

          // 计算并显示角度置信区间
          console.log("🎯 开始计算角度置信区间");
          const alpha = parseFloat(
            document.getElementById("alpha-level").value
          );
          const angleCI = calculateAngleConfidenceInterval(alpha);
          console.log("🎯 角度置信区间计算完成");
          if (angleCI && angleCI.length > 0) {
            // 显示最新的置信区间（最后一个）
            const latestCI = angleCI[angleCI.length - 1];
            document.getElementById(
              "angle-confidence-interval"
            ).textContent = `[${latestCI.lowerBoundDegrees.toFixed(
              1
            )}°, ${latestCI.upperBoundDegrees.toFixed(1)}°] (${Math.round(
              (1 - alpha) * 100
            )}%) - 位置${angleCI.length}`;
            console.log(
              "🎯 角度置信区间DOM更新完成，共",
              angleCI.length,
              "个置信区间"
            );
          }
        }

        console.log("🎯 开始调用地图绘制函数");
        drawMinecraftMap();
        console.log("🎯 地图绘制函数调用完成");

        console.log("🎯 开始更新提示信息");
        updateMinecraftTips();
        console.log("🎯 提示信息更新完成");

        // 简化动画效果，减少DOM操作（仅前3次投掷显示动画）
        if (eyeData.length <= 3) {
          const canvas = document.getElementById("minecraft-canvas");
          if (canvas) {
            canvas.classList.add("data-point-enter");
            setTimeout(() => canvas.classList.remove("data-point-enter"), 300);
          }
        }

        // 简化结果显示动画
        if (eyeData.length >= 3) {
          const resultsContainer = document.getElementById(
            "stronghold-position"
          );
          if (resultsContainer) {
            resultsContainer.parentElement.classList.add("result-slide-in");
            setTimeout(
              () =>
                resultsContainer.parentElement.classList.remove(
                  "result-slide-in"
                ),
              400
            );
          }
        }

        // 重置防抖标志（增加延迟确保计算完成）
        setTimeout(
          () => {
            isThrowingEye = false;
            const totalEndTime = performance.now();
            console.log(
              "🎯 投掷完成，总耗时:",
              (totalEndTime - startTime).toFixed(2),
              "ms"
            );
            console.log("---");
          },
          eyeData.length >= 3 ? 500 : 200
        );
      }

      // 计算要塞位置（经典统计方法）
      function calculateStrongholdPosition(confidenceLevel) {
        const n = eyeData.length;
        const avgX = eyeData.reduce((sum, point) => sum + point.x, 0) / n;
        const avgZ = eyeData.reduce((sum, point) => sum + point.z, 0) / n;

        const stdX = Math.sqrt(
          eyeData.reduce((sum, point) => sum + Math.pow(point.x - avgX, 2), 0) /
            Math.max(1, n - 1)
        );
        const stdZ = Math.sqrt(
          eyeData.reduce((sum, point) => sum + Math.pow(point.z - avgZ, 2), 0) /
            Math.max(1, n - 1)
        );

        // 使用精确的t分布临界值计算
        const df = Math.max(1, n - 1);
        const alpha = 1 - confidenceLevel;
        const t = tDistributionInverse(1 - alpha / 2, df);

        const marginX = (t * stdX) / Math.sqrt(n);
        const marginZ = (t * stdZ) / Math.sqrt(n);

        document.getElementById(
          "stronghold-position"
        ).textContent = `(${Math.round(avgX)}, ${Math.round(avgZ)})`;
        document.getElementById("search-range").textContent = `±${Math.round(
          Math.max(marginX, marginZ)
        )} 格`;
      }

      // 贝叶斯统计计算（优化版本）
      function calculateBayesianPosition(confidenceLevel, priorType) {
        console.log("📊 开始贝叶斯计算，数据点数量:", eyeData.length);
        const bayesianStartTime = performance.now();
        const n = eyeData.length;

        // 设置先验分布参数
        let priorMeanX = 0,
          priorMeanZ = 0,
          priorVarX = 10000,
          priorVarZ = 10000;

        if (priorType === "normal") {
          // 基于游戏知识的正态先验
          priorMeanX = 100;
          priorMeanZ = -100;
          priorVarX = 5000;
          priorVarZ = 5000;
        } else if (priorType === "informed") {
          // 有信息先验：基于已知要塞生成规律
          priorMeanX = 150;
          priorMeanZ = -200;
          priorVarX = 2500;
          priorVarZ = 2500;
        }

        // 计算样本统计量（优化：避免重复计算）
        let sumX = 0,
          sumZ = 0;
        for (let i = 0; i < n; i++) {
          sumX += eyeData[i].x;
          sumZ += eyeData[i].z;
        }
        const sampleMeanX = sumX / n;
        const sampleMeanZ = sumZ / n;

        // 假设已知方差（简化处理）
        const likelihoodVarX = 1000;
        const likelihoodVarZ = 1000;

        // 贝叶斯更新（正态-正态共轭）
        const posteriorVarX = 1 / (1 / priorVarX + n / likelihoodVarX);
        const posteriorVarZ = 1 / (1 / priorVarZ + n / likelihoodVarZ);

        const posteriorMeanX =
          posteriorVarX *
          (priorMeanX / priorVarX + (n * sampleMeanX) / likelihoodVarX);
        const posteriorMeanZ =
          posteriorVarZ *
          (priorMeanZ / priorVarZ + (n * sampleMeanZ) / likelihoodVarZ);

        // 计算可信区间
        const z =
          confidenceLevel === 0.9
            ? 1.645
            : confidenceLevel === 0.95
            ? 1.96
            : 2.576;
        const marginX = z * Math.sqrt(posteriorVarX);
        const marginZ = z * Math.sqrt(posteriorVarZ);

        // 存储后验分布（简化版本，不用于复杂绘制）
        bayesianPosterior = {
          meanX: posteriorMeanX,
          meanZ: posteriorMeanZ,
          varX: posteriorVarX,
          varZ: posteriorVarZ,
          marginX: marginX,
          marginZ: marginZ,
        };

        const bayesianEndTime = performance.now();
        console.log(
          "📊 贝叶斯计算完成，耗时:",
          (bayesianEndTime - bayesianStartTime).toFixed(2),
          "ms"
        );

        console.log("📊 开始更新DOM元素");
        document.getElementById(
          "stronghold-position"
        ).textContent = `(${Math.round(posteriorMeanX)}, ${Math.round(
          posteriorMeanZ
        )})`;
        console.log("📊 stronghold-position 更新完成");

        document.getElementById("search-range").textContent = `±${Math.round(
          Math.max(marginX, marginZ)
        )} 格 (${Math.round(confidenceLevel * 100)}% 可信区间)`;
        console.log("📊 search-range 更新完成");
        console.log("📊 贝叶斯函数执行完毕");
      }

      // 计算两个点之间相对于x轴正方向的角度（考虑Canvas缩放）
      function calculateAngleBetweenPoints(fromPoint, toPoint) {
        const dx = toPoint.x - fromPoint.x;
        const dz = toPoint.z - fromPoint.z;

        // 获取Canvas尺寸以计算缩放比例
        const canvas = document.getElementById("minecraft-map");
        const rect = canvas.getBoundingClientRect();

        // 考虑x轴和z轴可能不同的缩放比例
        const xScale = rect.width / 4000; // toCanvasX的缩放因子
        const zScale = rect.height / 4000; // toCanvasZ的缩放因子

        // 调整坐标差值以补偿缩放差异
        const adjustedDx = dx * xScale;
        const adjustedDz = dz * zScale;

        return Math.atan2(adjustedDz, adjustedDx);
      }

      // 计算角度的置信区间 - 支持多个独立的置信区间
      function calculateAngleConfidenceInterval(alpha = 0.05) {
        console.log("📐 开始角度置信区间计算，数据点数量:", eyeData.length);
        const angleStartTime = performance.now();
        if (eyeData.length < 3) return null;

        // 按玩家位置分组投掷点，每个位置独立计算置信区间
        const positionGroups = new Map();
        eyeData.forEach((point, index) => {
          const posKey = `${point.playerPosition.x},${point.playerPosition.z}`;
          if (!positionGroups.has(posKey)) {
            positionGroups.set(posKey, {
              playerPos: point.playerPosition,
              points: [],
            });
          }
          positionGroups
            .get(posKey)
            .points.push({ ...point, originalIndex: index });
        });

        const confidenceIntervals = [];

        // 为每个玩家位置组计算独立的置信区间
        positionGroups.forEach((group, posKey) => {
          const points = group.points;
          const playerPos = group.playerPos;
          const n = points.length;

          if (n < 3) {
            console.log(`📐 位置 ${posKey} 的投掷点不足3个，跳过置信区间计算`);
            return;
          }

          // 重新计算每个投掷点相对于该组玩家位置的角度
          const angles = points.map((point) => {
            return calculateAngleBetweenPoints(playerPos, point);
          });
          console.log(
            `📐 位置 ${posKey} 角度数据重新计算完成，角度数组:`,
            angles.map((a) => ((a * 180) / Math.PI).toFixed(2))
          );

          // 计算角度的平均值（考虑角度的周期性）
          console.log(`📐 位置 ${posKey} 开始计算角度平均值`);
          const sinSum = angles.reduce(
            (sum, angle) => sum + Math.sin(angle),
            0
          );
          const cosSum = angles.reduce(
            (sum, angle) => sum + Math.cos(angle),
            0
          );
          const meanAngle = Math.atan2(sinSum / n, cosSum / n);
          console.log(
            `📐 位置 ${posKey} 角度平均值计算完成:`,
            meanAngle,
            "度数:",
            ((meanAngle * 180) / Math.PI).toFixed(2)
          );

          // 计算角度的标准差（假设角度误差服从正态分布）
          console.log(`📐 位置 ${posKey} 开始计算角度标准差`);
          const angleDeviations = angles.map((angle) => {
            let diff = angle - meanAngle;
            // 处理角度差的周期性
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            return diff;
          });
          console.log(`📐 位置 ${posKey} 角度偏差计算完成`);

          const angleVariance =
            angleDeviations.reduce((sum, dev) => sum + dev * dev, 0) / (n - 1);
          const angleStd = Math.sqrt(angleVariance);
          console.log(
            `📐 位置 ${posKey} 角度标准差计算完成:`,
            angleStd,
            "度数:",
            ((angleStd * 180) / Math.PI).toFixed(2)
          );

          // 使用t分布计算置信区间
          console.log(`📐 位置 ${posKey} 开始t分布计算`);
          const df = n - 1;
          console.log(
            `📐 位置 ${posKey} 自由度df:`,
            df,
            "置信水平参数:",
            1 - alpha / 2
          );

          let t, marginError;
          try {
            t = tDistributionInverse(1 - alpha / 2, df);
            console.log(`📐 位置 ${posKey} t分布计算完成, t值:`, t);

            // 检查t值是否有效
            if (!isFinite(t) || Math.abs(t) > 1000) {
              console.warn(`📐 位置 ${posKey} t值异常，使用备用计算方法`);
              // 使用简化的正态分布近似
              t = 1.96; // 95%置信区间的z值
            }

            marginError = (t * angleStd) / Math.sqrt(n);
            console.log(`📐 位置 ${posKey} 边际误差计算完成:`, marginError);

            // 检查边际误差是否有效
            if (!isFinite(marginError) || marginError > Math.PI) {
              console.warn(`📐 位置 ${posKey} 边际误差异常，使用默认值`);
              marginError = Math.PI / 6; // 30度作为默认值
            }
          } catch (error) {
            console.error(`📐 位置 ${posKey} t分布计算出错:`, error);
            t = 1.96;
            marginError = Math.PI / 6;
          }

          // 计算置信区间边界
          let lowerBound = meanAngle - marginError;
          let upperBound = meanAngle + marginError;

          // 处理角度边界的周期性
          while (lowerBound < -Math.PI) lowerBound += 2 * Math.PI;
          while (upperBound > Math.PI) upperBound -= 2 * Math.PI;

          // 将该位置的置信区间添加到结果数组
          confidenceIntervals.push({
            playerPosition: playerPos,
            meanAngle: meanAngle,
            lowerBound: lowerBound,
            upperBound: upperBound,
            marginError: marginError,
            confidenceLevel: 1 - alpha,
            sampleSize: n,
            positionKey: posKey,
          });
        });

        const angleEndTime = performance.now();
        console.log(
          "📐 角度置信区间计算完成，耗时:",
          (angleEndTime - angleStartTime).toFixed(2),
          "ms",
          "共计算了",
          confidenceIntervals.length,
          "个独立置信区间"
        );

        // 为每个置信区间添加度数转换
        confidenceIntervals.forEach((interval) => {
          interval.meanAngleDegrees = (interval.meanAngle * 180) / Math.PI;
          interval.lowerBoundDegrees = (interval.lowerBound * 180) / Math.PI;
          interval.upperBoundDegrees = (interval.upperBound * 180) / Math.PI;
          interval.marginErrorDegrees = (interval.marginError * 180) / Math.PI;
        });

        return confidenceIntervals;
      }

      // 绘制我的世界地图
      function drawMinecraftMap() {
        console.log("🗺️ 开始绘制地图，投掷数据数量:", eyeData.length);
        const mapStartTime = performance.now();
        const canvas = document.getElementById("minecraft-map");
        const ctx = canvas.getContext("2d");

        // 获取设备像素比以提升清晰度
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        // 设置canvas实际分辨率（考虑设备像素比）
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;

        // 设置canvas显示尺寸
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";

        // 缩放绘图上下文以匹配设备像素比
        ctx.scale(dpr, dpr);

        // 启用抗锯齿
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        ctx.clearRect(0, 0, rect.width, rect.height);

        const displayMode = document.getElementById("display-mode").value;
        const statisticalMethod =
          document.getElementById("statistical-method").value;

        // 应用缩放和平移变换
        ctx.save();
        ctx.translate(
          rect.width / 2 + minecraftMapOffsetX,
          rect.height / 2 + minecraftMapOffsetY
        );
        ctx.scale(minecraftMapZoom, minecraftMapZoom);
        ctx.translate(-rect.width / 2, -rect.height / 2);

        // 坐标转换（考虑缩放和平移）- 扩展到4000格范围
        const toCanvasX = (x) => ((x + 2000) * rect.width) / 4000;
        const toCanvasZ = (z) => ((2000 - z) * rect.height) / 4000;

        // 热力图功能已移除

        // 暂时禁用等高线绘制以解决性能问题
        // 等高线绘制会导致大量的gaussianPDF计算，在某些设备上会造成CPU占满
        // if (statisticalMethod === 'bayesian' && displayMode === 'contour' && bayesianPosterior && eyeData.length <= 5) {
        //   drawContourLines(ctx, canvas, toCanvasX, toCanvasZ, rect);
        // }

        // 绘制网格 - 扩展网格范围以覆盖要塞生成区域
        ctx.strokeStyle =
          displayMode === "heatmap"
            ? "rgba(255, 255, 255, 0.3)"
            : "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        // 扩展到±20000以确保覆盖1800x1800游戏坐标（36000x36000地图坐标）的要塞生成区域
        for (let i = -20000; i <= 20000; i += 500) {
          ctx.beginPath();
          ctx.moveTo(toCanvasX(i), 0);
          ctx.lineTo(toCanvasX(i), rect.height);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, toCanvasZ(i));
          ctx.lineTo(rect.width, toCanvasZ(i));
          ctx.stroke();
        }

        // 绘制末影之眼投掷点和方向线（优化版本）
        eyeData.forEach((point, index) => {
          const color =
            point.color || eyeThrowColors[index % eyeThrowColors.length];

          // 绘制从投掷时的玩家位置到末影之眼落点的方向线
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          // 使用投掷时保存的玩家位置，确保连线独立
          const throwPlayerPos = point.playerPosition || playerPosition;
          ctx.moveTo(toCanvasX(throwPlayerPos.x), toCanvasZ(throwPlayerPos.z));
          ctx.lineTo(toCanvasX(point.x), toCanvasZ(point.z));
          ctx.stroke();
          ctx.setLineDash([]);

          // 简化投掷范围圆圈绘制（减少计算）
          if (eyeData.length <= 5) {
            const rangeRadius = Math.max(8, point.distance / 60);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.2;
            ctx.beginPath();
            ctx.arc(
              toCanvasX(point.x),
              toCanvasZ(point.z),
              rangeRadius,
              0,
              2 * Math.PI
            );
            ctx.stroke();
            ctx.globalAlpha = 1;
          }

          // 绘制末影之眼落点
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(toCanvasX(point.x), toCanvasZ(point.z), 4, 0, 2 * Math.PI);
          ctx.fill();

          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 1;
          ctx.stroke();

          // 显示投掷顺序（简化文本绘制）
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 10px Arial";
          ctx.fillText(
            (index + 1).toString(),
            toCanvasX(point.x) + 6,
            toCanvasZ(point.z) - 6
          );
        });

        // 绘制玩家位置
        ctx.fillStyle = "#00ff00";
        ctx.beginPath();
        ctx.arc(
          toCanvasX(playerPosition.x),
          toCanvasZ(playerPosition.z),
          5,
          0,
          2 * Math.PI
        );
        ctx.fill();

        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();

        // 玩家位置标签
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 12px Arial";
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 3;
        ctx.strokeText(
          "玩家",
          toCanvasX(playerPosition.x) + 8,
          toCanvasZ(playerPosition.z) - 8
        );
        ctx.fillText(
          "玩家",
          toCanvasX(playerPosition.x) + 8,
          toCanvasZ(playerPosition.z) - 8
        );

        // 绘制真实要塞位置（根据showTruePosition控制显示）
        if (showTruePosition) {
          ctx.fillStyle = "#ffd700";
          ctx.beginPath();
          ctx.arc(
            toCanvasX(strongholdTruePosition.x),
            toCanvasZ(strongholdTruePosition.z),
            8,
            0,
            2 * Math.PI
          );
          ctx.fill();

          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.stroke();

          // 添加要塞标签
          ctx.fillStyle = "#ffffff";
          ctx.font = "12px Arial";
          ctx.fillText(
            "要塞",
            toCanvasX(strongholdTruePosition.x) + 10,
            toCanvasZ(strongholdTruePosition.z) - 10
          );
        }

        // 绘制玩家位置（原点）
        ctx.fillStyle = "#00ff66";
        ctx.beginPath();
        ctx.arc(toCanvasX(0), toCanvasZ(0), 5, 0, 2 * Math.PI);
        ctx.fill();

        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();

        // 绘制估计位置（如果有的话）
        if (eyeData.length >= 3) {
          drawEstimatedPosition(ctx, canvas, toCanvasX, toCanvasZ, displayMode);

          // 绘制角度置信区间
          const alpha = parseFloat(
            document.getElementById("alpha-level").value
          );
          const angleCI = calculateAngleConfidenceInterval(alpha);
          if (angleCI) {
            drawAngleConfidenceInterval(
              ctx,
              canvas,
              toCanvasX,
              toCanvasZ,
              angleCI
            );
          }
        }

        // 恢复变换
        ctx.restore();

        // 添加图例（在变换恢复后绘制，保持固定位置）
        ctx.fillStyle = displayMode === "heatmap" ? "#ffffff" : "#ffffff";
        ctx.font = "12px Arial";
        ctx.fillText("🟢 玩家位置", 10, 20);
        ctx.fillText("🟡 真实要塞", 10, 35);
        ctx.fillText("🟣 末影之眼", 10, 50);
        if (eyeData.length >= 3) {
          ctx.fillText(
            statisticalMethod === "bayesian" ? "🔵 贝叶斯估计" : "🔵 经典估计",
            10,
            65
          );
          ctx.fillText("🟢 角度置信区间", 10, 80);
        }

        // 检查玩家是否接近要塞（16格内，对应地图320单位）
        const distanceToStronghold = Math.sqrt(
          Math.pow(playerPosition.x - strongholdTruePosition.x, 2) +
            Math.pow(playerPosition.z - strongholdTruePosition.z, 2)
        );

        if (
          distanceToStronghold <= 320 &&
          eyeData.length >= 3 &&
          !showTruePosition
        ) {
          showTruePosition = true;
          showSuccessAnimation(distanceToStronghold);
        }

        const mapEndTime = performance.now();
        console.log(
          "🗺️ 地图绘制完成，耗时:",
          (mapEndTime - mapStartTime).toFixed(2),
          "ms"
        );
      }

      // 绘制角度置信区间
      function drawAngleConfidenceInterval(
        ctx,
        canvas,
        toCanvasX,
        toCanvasZ,
        angleCI
      ) {
        // 如果angleCI是数组，则绘制多个独立的置信区间
        if (Array.isArray(angleCI)) {
          angleCI.forEach((interval, index) => {
            drawSingleAngleConfidenceInterval(
              ctx,
              canvas,
              toCanvasX,
              toCanvasZ,
              interval,
              index
            );
          });
          return;
        }

        // 兼容旧版本：如果是单个置信区间对象，使用当前玩家位置
        drawSingleAngleConfidenceInterval(
          ctx,
          canvas,
          toCanvasX,
          toCanvasZ,
          angleCI,
          0
        );
      }

      // 绘制单个角度置信区间
      function drawSingleAngleConfidenceInterval(
        ctx,
        canvas,
        toCanvasX,
        toCanvasZ,
        angleCI,
        index = 0
      ) {
        // 使用置信区间中保存的玩家位置，而不是当前玩家位置
        const playerPos = angleCI.playerPosition || playerPosition;
        const playerX = toCanvasX(playerPos.x);
        const playerZ = toCanvasZ(playerPos.z);

        // 计算射线延伸到Canvas边界的最大长度
        // 考虑地图缩放和平移，确保射线能延伸到变换后的可视区域边界
        const canvasRect = canvas.getBoundingClientRect();

        // 考虑当前的地图变换状态
        const transformedWidth = canvasRect.width / mapZoom;
        const transformedHeight = canvasRect.height / mapZoom;

        // 计算从玩家位置到canvas四个角的最大距离
        const corners = [
          { x: -mapOffsetX / mapZoom, z: -mapOffsetY / mapZoom },
          {
            x: (canvasRect.width - mapOffsetX) / mapZoom,
            z: -mapOffsetY / mapZoom,
          },
          {
            x: -mapOffsetX / mapZoom,
            z: (canvasRect.height - mapOffsetY) / mapZoom,
          },
          {
            x: (canvasRect.width - mapOffsetX) / mapZoom,
            z: (canvasRect.height - mapOffsetY) / mapZoom,
          },
        ];

        const maxDistance = Math.max(
          ...corners.map((corner) =>
            Math.sqrt((corner.x - playerX) ** 2 + (corner.z - playerZ) ** 2)
          )
        );

        const radius = Math.max(
          maxDistance * 2,
          Math.sqrt(transformedWidth ** 2 + transformedHeight ** 2)
        ); // 确保射线足够长

        // 直接使用计算出的角度值，适配Canvas坐标系统
        // 由于toCanvasZ使用(2000-z)翻转了Z轴，需要对角度进行相应调整
        const meanAngle = -angleCI.meanAngle;
        const lowerBound = -angleCI.upperBound;
        const upperBound = -angleCI.lowerBound;

        console.log(
          `🎨 绘制角度置信区间 #${index} (位置: ${playerPos.x}, ${playerPos.z}):`,
          {
            meanAngle: ((meanAngle * 180) / Math.PI).toFixed(2) + "°",
            lowerBound: ((lowerBound * 180) / Math.PI).toFixed(2) + "°",
            upperBound: ((upperBound * 180) / Math.PI).toFixed(2) + "°",
          }
        );

        // 为不同的置信区间使用不同的颜色
        const colors = [
          { r: 0, g: 255, b: 100 }, // 绿色
          { r: 255, g: 100, b: 100 }, // 红色
          { r: 100, g: 100, b: 255 }, // 蓝色
          { r: 255, g: 255, b: 100 }, // 黄色
          { r: 255, g: 100, b: 255 }, // 紫色
          { r: 100, g: 255, b: 255 }, // 青色
        ];
        const color = colors[index % colors.length];

        // 创建渐变效果
        const gradient = ctx.createRadialGradient(
          playerX,
          playerZ,
          0,
          playerX,
          playerZ,
          radius
        );
        gradient.addColorStop(
          0,
          `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`
        );
        gradient.addColorStop(
          0.7,
          `rgba(${color.r}, ${color.g}, ${color.b}, 0.2)`
        );
        gradient.addColorStop(
          1,
          `rgba(${color.r}, ${color.g}, ${color.b}, 0.05)`
        );

        // 绘制渐变扇形
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(playerX, playerZ);
        ctx.arc(playerX, playerZ, radius, lowerBound, upperBound, false);
        ctx.closePath();
        ctx.fill();

        // 绘制中轴线（平均角度射线）
        const centerLineColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
        ctx.strokeStyle = centerLineColor;
        ctx.lineWidth = 2; // 减小线条粗细
        ctx.setLineDash([]);
        ctx.shadowColor = centerLineColor;
        ctx.shadowBlur = 6; // 减小发光效果
        ctx.beginPath();
        ctx.moveTo(playerX, playerZ);
        ctx.lineTo(
          playerX + Math.cos(meanAngle) * radius,
          playerZ + Math.sin(meanAngle) * radius
        );
        ctx.stroke();
        ctx.shadowBlur = 0;

        // 绘制置信区间边界射线（渐变效果）
        const drawBoundaryRay = (angle, rayColor) => {
          const rayGradient = ctx.createLinearGradient(
            playerX,
            playerZ,
            playerX + Math.cos(angle) * radius,
            playerZ + Math.sin(angle) * radius
          );
          rayGradient.addColorStop(0, rayColor);
          rayGradient.addColorStop(1, rayColor.replace("1)", "0.3)"));

          ctx.strokeStyle = rayGradient;
          ctx.lineWidth = 1.5; // 减小边界线粗细
          ctx.setLineDash([6, 3]); // 调整虚线样式
          ctx.shadowColor = rayColor;
          ctx.shadowBlur = 4; // 减小阴影效果
          ctx.beginPath();
          ctx.moveTo(playerX, playerZ);
          ctx.lineTo(
            playerX + Math.cos(angle) * radius,
            playerZ + Math.sin(angle) * radius
          );
          ctx.stroke();
          ctx.shadowBlur = 0;
        };

        // 绘制上下边界射线
        const boundaryColor = `rgba(${color.r}, ${color.g}, ${color.b}, 1)`;
        drawBoundaryRay(lowerBound, boundaryColor);
        drawBoundaryRay(upperBound, boundaryColor);

        // 重置线条样式
        ctx.setLineDash([]);
      }

      // 热力图功能已移除

      // 绘制等高线
      function drawContourLines(ctx, canvas, toCanvasX, toCanvasZ, rect) {
        // 减少等高线数量以提高性能
        const levels = [0.0001, 0.0005, 0.001]; // 概率密度等高线
        const colors = ["#FF6B6B", "#45B7D1", "#FFEAA7"];

        levels.forEach((level, index) => {
          ctx.strokeStyle = colors[index];
          ctx.lineWidth = 2;
          drawContour(ctx, canvas, level, toCanvasX, toCanvasZ, rect);
        });
      }

      // 绘制单条等高线
      function drawContour(ctx, canvas, level, toCanvasX, toCanvasZ, rect) {
        // 增加步长以提高性能
        const step = 40;
        ctx.beginPath();

        // 使用显示尺寸而不是实际canvas尺寸来避免性能问题
        const displayWidth = rect.width;
        const displayHeight = rect.height;

        for (let i = 0; i < displayWidth - step; i += step) {
          for (let j = 0; j < displayHeight - step; j += step) {
            const x1 = (i / rect.width) * 4000 - 2000;
            const z1 = 2000 - (j / rect.height) * 4000;
            const x2 = ((i + step) / rect.width) * 4000 - 2000;
            const z2 = 2000 - ((j + step) / rect.height) * 4000;

            const p1 = gaussianPDF(
              x1,
              z1,
              bayesianPosterior.meanX,
              bayesianPosterior.meanZ,
              bayesianPosterior.varX,
              bayesianPosterior.varZ
            );
            const p2 = gaussianPDF(
              x2,
              z2,
              bayesianPosterior.meanX,
              bayesianPosterior.meanZ,
              bayesianPosterior.varX,
              bayesianPosterior.varZ
            );

            if ((p1 <= level && p2 >= level) || (p1 >= level && p2 <= level)) {
              ctx.moveTo(i, j);
              ctx.lineTo(i + step, j + step);
            }
          }
        }
        ctx.stroke();
      }

      // Box-Muller变换生成正态分布随机数
      let normalRandomSpare = null;

      function normalRandom(mean = 0, stdDev = 1) {
        if (normalRandomSpare !== null) {
          const spare = normalRandomSpare;
          normalRandomSpare = null;
          return spare * stdDev + mean;
        }

        let u1, u2;
        do {
          u1 = Math.random();
        } while (u1 === 0); // 确保u1不为0

        u2 = Math.random();

        const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
        const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);

        normalRandomSpare = z1;
        return z0 * stdDev + mean;
      }

      // 伽马函数的近似计算（Lanczos逼近）
      function gamma(z) {
        const g = 7;
        const C = [
          0.99999999999980993, 676.5203681218851, -1259.1392167224028,
          771.32342877765313, -176.61502916214059, 12.507343278686905,
          -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
        ];

        if (z < 0.5) {
          return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
        }

        z -= 1;
        let x = C[0];
        for (let i = 1; i < g + 2; i++) {
          x += C[i] / (z + i);
        }

        const t = z + g + 0.5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
      }

      // 不完全贝塔函数
      function incompleteBeta(x, a, b) {
        if (x === 0) return 0;
        if (x === 1) return 1;

        // 使用连分数展开
        const bt = Math.exp(
          logGamma(a + b) -
            logGamma(a) -
            logGamma(b) +
            a * Math.log(x) +
            b * Math.log(1 - x)
        );

        if (x < (a + 1) / (a + b + 2)) {
          return (bt * betaContinuedFraction(x, a, b)) / a;
        } else {
          return 1 - (bt * betaContinuedFraction(1 - x, b, a)) / b;
        }
      }

      // 对数伽马函数
      function logGamma(z) {
        return Math.log(gamma(z));
      }

      // 贝塔函数的连分数展开
      function betaContinuedFraction(x, a, b) {
        const maxIterations = 100;
        const epsilon = 1e-15;

        const qab = a + b;
        const qap = a + 1;
        const qam = a - 1;
        let c = 1;
        let d = 1 - (qab * x) / qap;

        if (Math.abs(d) < 1e-30) d = 1e-30;
        d = 1 / d;
        let h = d;

        for (let m = 1; m <= maxIterations; m++) {
          const m2 = 2 * m;
          let aa = (m * (b - m) * x) / ((qam + m2) * (a + m2));
          d = 1 + aa * d;
          if (Math.abs(d) < 1e-30) d = 1e-30;
          c = 1 + aa / c;
          if (Math.abs(c) < 1e-30) c = 1e-30;
          d = 1 / d;
          h *= d * c;

          aa = (-(a + m) * (qab + m) * x) / ((a + m2) * (qap + m2));
          d = 1 + aa * d;
          if (Math.abs(d) < 1e-30) d = 1e-30;
          c = 1 + aa / c;
          if (Math.abs(c) < 1e-30) c = 1e-30;
          d = 1 / d;
          const del = d * c;
          h *= del;

          if (Math.abs(del - 1) < epsilon) break;
        }

        return h;
      }

      // t分布逆函数（数值逼近）
      function tDistributionInverse(p, df) {
        if (p <= 0 || p >= 1) {
          throw new Error("概率必须在0和1之间");
        }

        if (df <= 0) {
          throw new Error("自由度必须大于0");
        }

        // 对于大自由度，使用正态分布逼近
        if (df > 1000) {
          return normalInverse(p);
        }

        // 使用牛顿-拉夫逊方法求解
        let x = normalInverse(p); // 初始猜测

        for (let i = 0; i < 10; i++) {
          const fx = tDistributionCDF(x, df) - p;
          const fpx = tDistributionPDF(x, df);

          if (Math.abs(fx) < 1e-10) break;

          x = x - fx / fpx;
        }

        return x;
      }

      // t分布累积分布函数
      function tDistributionCDF(t, df) {
        const x = df / (df + t * t);
        return 0.5 + (t > 0 ? 0.5 : -0.5) * incompleteBeta(x, df / 2, 0.5);
      }

      // t分布概率密度函数
      function tDistributionPDF(t, df) {
        const coeff =
          gamma((df + 1) / 2) / (Math.sqrt(df * Math.PI) * gamma(df / 2));
        return coeff * Math.pow(1 + (t * t) / df, -(df + 1) / 2);
      }

      // 标准正态分布逆函数（Beasley-Springer-Moro算法）
      function normalInverse(p) {
        const a = [
          0, -3.969683028665376e1, 2.209460984245205e2, -2.759285104469687e2,
          1.38357751867269e2, -3.066479806614716e1, 2.506628277459239,
        ];
        const b = [
          0, -5.447609879822406e1, 1.615858368580409e2, -1.556989798598866e2,
          6.680131188771972e1, -1.328068155288572e1,
        ];
        const c = [
          0, -7.784894002430293e-3, -3.223964580411365e-1, -2.400758277161838,
          -2.549732539343734, 4.374664141464968, 2.938163982698783,
        ];
        const d = [
          0, 7.784695709041462e-3, 3.224671290700398e-1, 2.445134137142996,
          3.754408661907416,
        ];

        const pLow = 0.02425;
        const pHigh = 1 - pLow;

        if (p < pLow) {
          const q = Math.sqrt(-2 * Math.log(p));
          return (
            (((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q +
              c[6]) /
            ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1)
          );
        } else if (p <= pHigh) {
          const q = p - 0.5;
          const r = q * q;
          return (
            ((((((a[1] * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * r +
              a[6]) *
              q) /
            (((((b[1] * r + b[2]) * r + b[3]) * r + b[4]) * r + b[5]) * r + 1)
          );
        } else {
          const q = Math.sqrt(-2 * Math.log(1 - p));
          return (
            -(
              ((((c[1] * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) * q +
              c[6]
            ) /
            ((((d[1] * q + d[2]) * q + d[3]) * q + d[4]) * q + 1)
          );
        }
      }

      // 高斯概率密度函数
      function gaussianPDF(x, z, meanX, meanZ, varX, varZ) {
        const dx = x - meanX;
        const dz = z - meanZ;
        const coeff = 1 / (2 * Math.PI * Math.sqrt(varX * varZ));
        const exponent = -((dx * dx) / (2 * varX) + (dz * dz) / (2 * varZ));
        return coeff * Math.exp(exponent);
      }

      // 绘制估计位置
      function drawEstimatedPosition(
        ctx,
        canvas,
        toCanvasX,
        toCanvasZ,
        displayMode
      ) {
        let estimatedX, estimatedZ, marginX, marginZ;

        if (bayesianPosterior) {
          estimatedX = bayesianPosterior.meanX;
          estimatedZ = bayesianPosterior.meanZ;
          marginX = bayesianPosterior.marginX;
          marginZ = bayesianPosterior.marginZ;
        } else {
          const n = eyeData.length;
          estimatedX = eyeData.reduce((sum, point) => sum + point.x, 0) / n;
          estimatedZ = eyeData.reduce((sum, point) => sum + point.z, 0) / n;
          // 简化的置信区间计算
          marginX = marginZ = 50;
        }

        const canvasX = toCanvasX(estimatedX);
        const canvasZ = toCanvasZ(estimatedZ);

        // 绘制置信区间椭圆
        ctx.strokeStyle =
          displayMode === "heatmap"
            ? "rgba(0,191,255,0.8)"
            : "rgba(0,191,255,0.6)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);

        const radiusX = (marginX / 800) * canvas.width;
        const radiusZ = (marginZ / 800) * canvas.height;

        ctx.beginPath();
        ctx.ellipse(canvasX, canvasZ, radiusX, radiusZ, 0, 0, 2 * Math.PI);
        ctx.stroke();

        ctx.setLineDash([]);

        // 绘制估计位置点
        ctx.fillStyle = displayMode === "heatmap" ? "#00BFFF" : "#0080FF";
        ctx.beginPath();
        ctx.arc(canvasX, canvasZ, 5, 0, 2 * Math.PI);
        ctx.fill();

        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // 更新我的世界提示
      function updateMinecraftTips() {
        const tipsDiv = document.getElementById("minecraft-tips");
        const n = eyeData.length;
        const statisticalMethod =
          document.getElementById("statistical-method").value;
        const methodText =
          statisticalMethod === "bayesian" ? "贝叶斯方法" : "经典统计方法";

        if (n === 0) {
          tipsDiv.innerHTML = "<p>开始投掷末影之眼来定位末地要塞！</p>";
        } else if (n < 3) {
          tipsDiv.innerHTML = `<p>已投掷 ${n} 次，至少需要 3 次才能进行统计分析。</p>`;
        } else if (n < 12) {
          tipsDiv.innerHTML = `<p>已投掷 ${n} 次，使用${methodText}进行分析。样本量还可以更大以提高精度。</p>`;
        } else {
          tipsDiv.innerHTML = `<p>已投掷 ${n} 次，使用${methodText}进行分析。样本量充足，定位精度较高！</p>`;
        }

        if (statisticalMethod === "bayesian" && n >= 3) {
          const priorType = document.getElementById("prior-distribution").value;
          const priorText =
            priorType === "uniform"
              ? "无信息先验"
              : priorType === "normal"
              ? "正态先验"
              : "有信息先验";
          tipsDiv.innerHTML += `<p>当前使用${priorText}分布，可尝试不同先验分布观察结果变化。</p>`;
        }
      }

      // 事件监听器
      document.addEventListener("DOMContentLoaded", function () {
        initParticles();

        // 初始化声纳地图
        setTimeout(() => {
          drawSonarMap(0, 0, 0, 0);
        }, 100);

        // 糖果盒实验
        document
          .getElementById("sample-btn")
          .addEventListener("click", sampleCandies);
        document
          .getElementById("reveal-truth-btn")
          .addEventListener("click", revealTruth);
        document
          .getElementById("repeat-experiment-btn")
          .addEventListener("click", repeatExperiment);

        // 理解度评分
        document.querySelectorAll(".understanding-btn").forEach((btn) => {
          btn.addEventListener("click", function () {
            const step = parseInt(this.closest(".theory-step").dataset.step);
            const level = parseInt(this.dataset.level);
            setUnderstanding(step, level);
          });
        });

        // AI帮助按钮
        document.querySelectorAll(".ai-help-btn").forEach((btn) => {
          btn.addEventListener("click", function () {
            const step = parseInt(this.dataset.step);
            showAIHelp(step);
          });
        });

        // 声纳实验
        document
          .getElementById("deploy-single-btn")
          .addEventListener("click", deploySingleSonar);
        document
          .getElementById("deploy-batch-btn")
          .addEventListener("click", deployBatchSonar);
        document
          .getElementById("reveal-shell-btn")
          .addEventListener("click", revealShellPosition);
        document
          .getElementById("reset-search-btn")
          .addEventListener("click", resetSearch);

        // 关闭反馈信息按钮事件监听器
        document
          .getElementById("close-feedback")
          .addEventListener("click", function () {
            const feedbackDiv = document.getElementById("prediction-feedback");
            if (feedbackDiv) {
              feedbackDiv.style.display = "none";
            }
          });

        // 调试按钮事件监听器
        document
          .getElementById("debug-btn")
          .addEventListener("click", function () {
            console.log("=== 调试信息 ===");
            console.log("声纳数据:", sonarData);
            console.log("显示真实位置:", showTruePosition);
            console.log("地图缩放:", mapZoom);
            console.log("地图偏移:", { mapOffsetX, mapOffsetY });

            const canvas = document.getElementById("sonar-map");
            if (canvas) {
              const rect = canvas.getBoundingClientRect();
              console.log("Canvas尺寸:", {
                width: canvas.width,
                height: canvas.height,
                displayWidth: rect.width,
                displayHeight: rect.height,
              });
            }

            if (sonarData.length > 0) {
              const avgX =
                sonarData.reduce((sum, p) => sum + p.x, 0) / sonarData.length;
              const avgY =
                sonarData.reduce((sum, p) => sum + p.y, 0) / sonarData.length;
              console.log("平均位置:", { avgX, avgY });
            }

            const truePos = getSonarTruePosition();
            console.log("真实位置:", truePos);

            // 强制重绘地图
            drawSonarMap();

            alert("调试信息已输出到控制台，请按F12查看Console标签页");
          });

        // 末影之眼实验
        document
          .getElementById("throw-eye-btn")
          .addEventListener("click", throwEye);

        // 显示/隐藏要塞位置
        document
          .getElementById("toggle-stronghold-btn")
          .addEventListener("click", function () {
            showTruePosition = !showTruePosition;
            const btn = document.getElementById("toggle-stronghold-btn");
            if (showTruePosition) {
              btn.innerHTML =
                '隐藏要塞位置 <i class="fa fa-eye-slash ml-2"></i>';
              btn.className =
                "px-6 py-2 bg-red-600 text-white font-bold rounded-md hover:bg-red-700 transition-all duration-300";
            } else {
              btn.innerHTML =
                '显示要塞位置 <i class="fa fa-map-marker ml-2"></i>';
              btn.className =
                "px-6 py-2 bg-neon-orange text-dark-bg font-bold rounded-md hover:bg-neon-orange/80 transition-all duration-300";
            }
            drawMinecraftMap(); // 重新绘制地图
          });

        // 重置游戏
        document
          .getElementById("reset-game-btn")
          .addEventListener("click", function () {
            if (confirm("确定要重置游戏吗？这将清除所有投掷数据。")) {
              // 重置所有数据
              eyeData = [];
              eyeThrowIndex = 0;
              showTruePosition = false;
              isMovingPlayer = false;

              // 重置玩家位置到原点
              playerPosition = { x: 0, z: 0 };

              // 重置UI元素
              document.getElementById("eye-count").value = "3";
              document.getElementById("eye-confidence").value = "0.95";

              // 重置按钮状态
              const moveBtn = document.getElementById("move-player-btn");
              moveBtn.textContent = "移动玩家位置";
              moveBtn.className =
                "px-6 py-2 bg-neon-blue text-white font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300";

              // 隐藏成功信息
              const successInfo = document.getElementById("success-info");
              if (successInfo) {
                successInfo.style.display = "none";
              }

              // 重新生成要塞位置
              strongholdTruePosition = generateRandomStrongholdPosition();

              // 重新绘制地图
              drawMinecraftMap();

              console.log("🔄 游戏已重置");
            }
          });

        // 移动玩家位置
        document
          .getElementById("move-player-btn")
          .addEventListener("click", function () {
            if (!isMovingPlayer) {
              isMovingPlayer = true;
              const btn = document.getElementById("move-player-btn");
              btn.textContent = "点击地图选择新位置";
              btn.className =
                "px-6 py-2 bg-yellow-600 text-white font-bold rounded-md hover:bg-yellow-700 transition-all duration-300";
              // 显示非阻塞提示
              showToast("请在地图上点击选择玩家的新位置", "info");
            } else {
              // 取消移动模式
              isMovingPlayer = false;
              const btn = document.getElementById("move-player-btn");
              btn.textContent = "移动玩家位置";
              btn.className =
                "px-6 py-2 bg-neon-blue text-white font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300";
            }
          });

        // 统计方法切换
        document
          .getElementById("statistical-method")
          .addEventListener("change", function () {
            const bayesianControls =
              document.getElementById("bayesian-controls");
            if (this.value === "bayesian") {
              bayesianControls.style.display = "block";
            } else {
              bayesianControls.style.display = "none";
            }
            // 重新计算和绘制
            if (eyeData.length >= 3) {
              if (this.value === "bayesian") {
                const confidenceLevel = parseFloat(
                  document.getElementById("eye-confidence").value
                );
                const priorDistribution =
                  document.getElementById("prior-distribution").value;
                calculateBayesianPosition(confidenceLevel, priorDistribution);
              } else {
                const confidenceLevel = parseFloat(
                  document.getElementById("eye-confidence").value
                );
                calculateStrongholdPosition(confidenceLevel);
              }
              drawMinecraftMap();
              updateMinecraftTips();
            }
          });

        // 先验分布和显示模式变化
        document
          .getElementById("prior-distribution")
          .addEventListener("change", function () {
            if (
              document.getElementById("statistical-method").value ===
                "bayesian" &&
              eyeData.length >= 3
            ) {
              const confidenceLevel = parseFloat(
                document.getElementById("eye-confidence").value
              );
              calculateBayesianPosition(confidenceLevel, this.value);
              drawMinecraftMap();
              updateMinecraftTips();
            }
          });

        // Alpha值变化监听器
        document
          .getElementById("alpha-level")
          .addEventListener("change", function () {
            if (eyeData.length >= 3) {
              const alpha = parseFloat(this.value);
              const angleCI = calculateAngleConfidenceInterval(alpha);
              if (angleCI && angleCI.length > 0) {
                // 显示最新的置信区间（最后一个）
                const latestCI = angleCI[angleCI.length - 1];
                document.getElementById(
                  "angle-confidence-interval"
                ).textContent = `[${latestCI.lowerBoundDegrees.toFixed(
                  1
                )}°, ${latestCI.upperBoundDegrees.toFixed(1)}°] (${Math.round(
                  (1 - alpha) * 100
                )}%) - 位置${angleCI.length}`;
              }
              drawMinecraftMap();
            }
          });

        // Minecraft地图缩放和拖拽事件
        const minecraftCanvas = document.getElementById("minecraft-map");

        // 缩放按钮事件
        document
          .getElementById("zoom-in")
          .addEventListener("click", function () {
            minecraftMapZoom = Math.min(minecraftMapZoom * 1.2, 5);
            drawMinecraftMap();
          });

        document
          .getElementById("zoom-out")
          .addEventListener("click", function () {
            minecraftMapZoom = Math.max(minecraftMapZoom / 1.2, 0.2);
            drawMinecraftMap();
          });

        document
          .getElementById("reset-view")
          .addEventListener("click", function () {
            minecraftMapZoom = 1;
            minecraftMapOffsetX = 0;
            minecraftMapOffsetY = 0;
            drawMinecraftMap();
          });

        // 鼠标拖拽事件
        minecraftCanvas.addEventListener("mousedown", function (e) {
          minecraftIsDragging = true;
          minecraftLastMouseX = e.clientX;
          minecraftLastMouseY = e.clientY;
          minecraftCanvas.style.cursor = "grabbing";
        });

        minecraftCanvas.addEventListener("mousemove", function (e) {
          const rect = minecraftCanvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          // 更新坐标显示，考虑地图偏移和缩放，并转换为我的世界坐标（除以20）
          const canvasX =
            (x - minecraftMapOffsetX - rect.width / 2) / minecraftMapZoom +
            rect.width / 2;
          const canvasY =
            (y - minecraftMapOffsetY - rect.height / 2) / minecraftMapZoom +
            rect.height / 2;
          const mapX = Math.round((canvasX / rect.width) * 4000 - 2000);
          const mapZ = Math.round(2000 - (canvasY / rect.height) * 4000);
          const worldX = Math.round(mapX / 20);
          const worldZ = Math.round(mapZ / 20);
          document.getElementById(
            "coordinate-display"
          ).innerHTML = `游戏坐标: (${worldX}格, ${worldZ}格)<br>地图坐标: [${mapX}, ${mapZ}]`;

          if (minecraftIsDragging) {
            const deltaX = e.clientX - minecraftLastMouseX;
            const deltaY = e.clientY - minecraftLastMouseY;
            minecraftMapOffsetX += deltaX;
            minecraftMapOffsetY += deltaY;
            minecraftLastMouseX = e.clientX;
            minecraftLastMouseY = e.clientY;
            drawMinecraftMap();
          }
        });

        minecraftCanvas.addEventListener("mouseup", function () {
          minecraftIsDragging = false;
          minecraftCanvas.style.cursor = "crosshair";
        });

        // 地图点击事件监听器 - 处理玩家位置移动
        minecraftCanvas.addEventListener("click", function (e) {
          if (isMovingPlayer && !minecraftIsDragging) {
            const rect = minecraftCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 计算点击位置的地图坐标
            const canvasX =
              (x - minecraftMapOffsetX - rect.width / 2) / minecraftMapZoom +
              rect.width / 2;
            const canvasY =
              (y - minecraftMapOffsetY - rect.height / 2) / minecraftMapZoom +
              rect.height / 2;
            const mapX = Math.round((canvasX / rect.width) * 4000 - 2000);
            const mapZ = Math.round(2000 - (canvasY / rect.height) * 4000);

            // 更新玩家位置
            playerPosition.x = mapX;
            playerPosition.z = mapZ;

            // 退出移动模式
            isMovingPlayer = false;
            document.getElementById("move-player-btn").textContent =
              "移动玩家位置";
            document.getElementById("move-player-btn").className =
              "px-6 py-2 bg-neon-blue text-white font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300";

            // 重新绘制地图
            drawMinecraftMap();

            // 显示移动成功提示
            const worldX = Math.round(mapX / 20);
            const worldZ = Math.round(mapZ / 20);
            showToast(
              `玩家已移动到新位置：游戏坐标 (${worldX}格, ${worldZ}格)`,
              "success"
            );
          }
        });

        minecraftCanvas.addEventListener("mouseleave", function () {
          minecraftIsDragging = false;
          minecraftCanvas.style.cursor = "crosshair";
        });

        // 鼠标滚轮缩放
        minecraftCanvas.addEventListener("wheel", function (e) {
          e.preventDefault();
          const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
          minecraftMapZoom = Math.max(
            0.2,
            Math.min(5, minecraftMapZoom * zoomFactor)
          );
          drawMinecraftMap();
        });

        // 声纳地图缩放和拖拽事件
        const sonarCanvas = document.getElementById("sonar-map");

        // 声纳地图缩放按钮事件
        document
          .getElementById("sonar-zoom-in")
          .addEventListener("click", function () {
            mapZoom = Math.min(mapZoom * 1.2, 5);
            if (sonarData.length > 0) {
              const avgX =
                sonarData.reduce((sum, p) => sum + p.x, 0) / sonarData.length;
              const avgY =
                sonarData.reduce((sum, p) => sum + p.y, 0) / sonarData.length;
              const marginX =
                1.96 *
                Math.sqrt(
                  sonarData.reduce(
                    (sum, p) => sum + Math.pow(p.x - avgX, 2),
                    0
                  ) / sonarData.length
                );
              const marginY =
                1.96 *
                Math.sqrt(
                  sonarData.reduce(
                    (sum, p) => sum + Math.pow(p.y - avgY, 2),
                    0
                  ) / sonarData.length
                );
              drawSonarMap(avgX, avgY, marginX, marginY);
            } else {
              drawSonarMap(0, 0, 0, 0);
            }
          });

        document
          .getElementById("sonar-zoom-out")
          .addEventListener("click", function () {
            mapZoom = Math.max(mapZoom / 1.2, 0.2);
            if (sonarData.length > 0) {
              const avgX =
                sonarData.reduce((sum, p) => sum + p.x, 0) / sonarData.length;
              const avgY =
                sonarData.reduce((sum, p) => sum + p.y, 0) / sonarData.length;
              const marginX =
                1.96 *
                Math.sqrt(
                  sonarData.reduce(
                    (sum, p) => sum + Math.pow(p.x - avgX, 2),
                    0
                  ) / sonarData.length
                );
              const marginY =
                1.96 *
                Math.sqrt(
                  sonarData.reduce(
                    (sum, p) => sum + Math.pow(p.y - avgY, 2),
                    0
                  ) / sonarData.length
                );
              drawSonarMap(avgX, avgY, marginX, marginY);
            } else {
              drawSonarMap(0, 0, 0, 0);
            }
          });

        document
          .getElementById("sonar-reset-view")
          .addEventListener("click", function () {
            mapZoom = 1;
            mapOffsetX = 0;
            mapOffsetY = 0;
            if (sonarData.length > 0) {
              const avgX =
                sonarData.reduce((sum, p) => sum + p.x, 0) / sonarData.length;
              const avgY =
                sonarData.reduce((sum, p) => sum + p.y, 0) / sonarData.length;
              const marginX =
                1.96 *
                Math.sqrt(
                  sonarData.reduce(
                    (sum, p) => sum + Math.pow(p.x - avgX, 2),
                    0
                  ) / sonarData.length
                );
              const marginY =
                1.96 *
                Math.sqrt(
                  sonarData.reduce(
                    (sum, p) => sum + Math.pow(p.y - avgY, 2),
                    0
                  ) / sonarData.length
                );
              drawSonarMap(avgX, avgY, marginX, marginY);
            } else {
              drawSonarMap(0, 0, 0, 0);
            }
          });

        // 声纳地图拖拽功能已禁用（固定显示范围）
        // 保留坐标显示功能
        sonarCanvas.addEventListener("mousemove", function (e) {
          const rect = sonarCanvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          // 更新坐标显示（基于固定范围-3到3）
          const worldX = (mouseX / rect.width) * 6 - 3;
          const worldY = 3 - (mouseY / rect.height) * 6;
          document.getElementById(
            "sonar-coordinate-display"
          ).textContent = `坐标: (${worldX.toFixed(1)}, ${worldY.toFixed(
            1
          )}) km`;
        });

        // 其他鼠标事件已禁用
        // sonarCanvas.addEventListener("mousedown", function (e) {
        //   // 拖拽功能已禁用
        // });
        // sonarCanvas.addEventListener("mouseup", function () {
        //   // 拖拽功能已禁用
        // });
        // sonarCanvas.addEventListener("mouseleave", function () {
        //   // 拖拽功能已禁用
        // });

        // 声纳地图滚轮缩放事件已禁用（固定显示范围）
        // sonarCanvas.addEventListener("wheel", function (e) {
        //   // 缩放功能已禁用以保持固定显示范围
        // });

        document
          .getElementById("display-mode")
          .addEventListener("change", function () {
            drawMinecraftMap();
          });
      });

      // 非阻塞提示函数
      function showToast(message, type = "info", duration = 3000) {
        // 创建提示元素
        const toast = document.createElement("div");
        toast.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 transform transition-all duration-300 translate-x-full opacity-0`;

        // 根据类型设置样式
        const styles = {
          info: "bg-blue-600 text-white",
          success: "bg-green-600 text-white",
          warning: "bg-yellow-600 text-white",
          error: "bg-red-600 text-white",
        };

        toast.className += ` ${styles[type] || styles.info}`;
        toast.textContent = message;

        // 添加到页面
        document.body.appendChild(toast);

        // 显示动画
        setTimeout(() => {
          toast.classList.remove("translate-x-full", "opacity-0");
        }, 10);

        // 自动隐藏
        setTimeout(() => {
          toast.classList.add("translate-x-full", "opacity-0");
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        }, duration);
      }

      // 成功动画函数
      function showSuccessAnimation(distance) {
        console.log(
          "🎉 玩家接近要塞，触发成功动画！距离:",
          (distance / 20).toFixed(1),
          "格"
        );

        // 显示成功信息
        const successInfo = document.getElementById("success-info");
        successInfo.style.display = "block";

        // 计算统计信息
        const uniquePositions = new Set();
        let totalAngleError = 0;

        eyeData.forEach((point) => {
          const posKey = `${point.playerPosition.x},${point.playerPosition.z}`;
          uniquePositions.add(posKey);
          totalAngleError += Math.abs(point.angleError);
        });

        const avgError = totalAngleError / eyeData.length;
        const accuracy = Math.max(0, 100 - (distance / 320) * 100);

        // 更新统计信息（转换为游戏格数）
        const distanceInBlocks = distance / 20;
        document.getElementById("final-distance").textContent =
          distanceInBlocks.toFixed(1);
        document.getElementById("total-throws").textContent = eyeData.length;
        document.getElementById("total-positions").textContent =
          uniquePositions.size;
        document.getElementById("avg-error").textContent = (
          (avgError * 180) /
          Math.PI
        ).toFixed(1);
        document.getElementById("final-accuracy").textContent =
          accuracy.toFixed(1);

        // 添加闪烁动画
        successInfo.style.animation = "pulse 2s ease-in-out infinite";

        // 添加CSS动画样式（如果不存在）
        if (!document.getElementById("success-animation-style")) {
          const style = document.createElement("style");
          style.id = "success-animation-style";
          style.textContent = `
              @keyframes pulse {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.05); opacity: 0.9; }
              }
              @keyframes bounce {
                0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
                40% { transform: translateY(-10px); }
                60% { transform: translateY(-5px); }
              }
            `;
          document.head.appendChild(style);
        }

        // 播放成功音效（如果浏览器支持）
        try {
          const audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
          oscillator.frequency.setValueAtTime(
            659.25,
            audioContext.currentTime + 0.1
          ); // E5
          oscillator.frequency.setValueAtTime(
            783.99,
            audioContext.currentTime + 0.2
          ); // G5

          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + 0.5
          );

          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.5);
        } catch (e) {
          console.log("音效播放失败（正常现象）:", e.message);
        }
      }
    </script>

    <!-- 页脚 -->
    <footer class="bg-dark-card py-12 border-t border-gray-800">
      <div class="container mx-auto px-4">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8">
          <div>
            <div class="flex items-center space-x-2 mb-6">
              <div
                class="w-10 h-10 rounded-full bg-gradient-to-r from-neon-blue to-neon-purple flex items-center justify-center"
              >
                <i class="fa fa-calculator text-white text-xl"></i>
              </div>
              <h2 class="text-xl font-future font-bold text-white">
                <span class="text-neon-blue">概率</span
                ><span class="text-white">维度</span>
              </h2>
            </div>
            <p class="text-gray-400 mb-6">
              探索概率与数理统计的奇妙世界，揭示数据背后的规律。
            </p>
            <div class="flex space-x-4">
              <a
                href="https://www.douyin.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-red-500 hover:to-pink-500 hover:text-white transition-all duration-300 transform hover:scale-110 hover:rotate-12"
                title="抖音 - 记录美好生活"
              >
                <img
                  src="../static/img/tiktok.svg"
                  alt="抖音"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
              <a
                href="https://www.bilibili.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-pink-400 hover:to-pink-600 hover:text-white transition-all duration-300 transform hover:scale-110 hover:-rotate-12"
                title="哔哩哔哩 - 你感兴趣的视频都在B站"
              >
                <img
                  src="../static/img/bilibili.svg"
                  alt="哔哩哔哩"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
              <a
                href="https://weixin.qq.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-green-400 hover:to-green-600 hover:text-white transition-all duration-300 transform hover:scale-110 hover:rotate-12"
                title="微信 - 是一个生活方式"
              >
                <img
                  src="../static/img/wechat.svg"
                  alt="微信"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
              <a
                href="https://weibo.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-orange-400 hover:to-red-500 hover:text-white transition-all duration-300 transform hover:scale-110 hover:-rotate-12"
                title="微博 - 随时随地发现新鲜事"
              >
                <img
                  src="../static/img/weibo.svg"
                  alt="微博"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
            </div>
          </div>

          <div>
            <h3 class="text-white font-future font-semibold mb-6">快速链接</h3>
            <ul class="space-y-3">
              <li>
                <a
                  href="index.html#concepts"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >核心概念</a
                >
              </li>
              <li>
                <a
                  href="index.html#simulations"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >概率模拟</a
                >
              </li>
              <li>
                <a
                  href="index.html#visualizations"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >数据可视化</a
                >
              </li>
              <li>
                <a
                  href="index.html#applications"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >应用场景</a
                >
              </li>
            </ul>
          </div>

          <div>
            <h3 class="text-white font-future font-semibold mb-6">学习资源</h3>
            <ul class="space-y-3">
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >教程与指南</a
                >
              </li>
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >在线课程</a
                >
              </li>
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >书籍推荐</a
                >
              </li>
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >研究论文</a
                >
              </li>
            </ul>
          </div>

          <div>
            <h3 class="text-white font-future font-semibold mb-6">联系我们</h3>
            <ul class="space-y-3">
              <li class="flex items-start">
                <i class="fa fa-envelope text-neon-blue mt-1 mr-3"></i>
                <span class="text-gray-400">WangHouxiong9558@outlook.com</span>
              </li>
              <li class="flex items-start">
                <i class="fa fa-map-marker text-neon-blue mt-1 mr-3"></i>
                <span class="text-gray-400"
                  >江西省南昌市高新技术开发区天祥大道289号</span
                >
              </li>
              <li class="flex items-start">
                <i class="fa fa-phone text-neon-blue mt-1 mr-3"></i>
                <span class="text-gray-400">+86 173 5709 8869</span>
              </li>
            </ul>
          </div>
        </div>

        <div
          class="pt-8 border-t border-gray-800 flex flex-col md:flex-row justify-between items-center"
        >
          <p class="text-gray-500 text-sm mb-4 md:mb-0">
            © 2025 概率维度. 保留所有权利.
          </p>
          <div class="flex space-x-6">
            <a href="#" class="text-gray-500 hover:text-gray-300 text-sm"
              >隐私政策</a
            >
            <a href="#" class="text-gray-500 hover:text-gray-300 text-sm"
              >服务条款</a
            >
            <a href="#" class="text-gray-500 hover:text-gray-300 text-sm"
              >Cookie政策</a
            >
          </div>
        </div>
        
        <!-- 备案信息 -->
        <div class="pt-4 text-center">
          <p class="text-gray-500 text-sm">
            <a 
              href="http://beian.miit.gov.cn/" 
              target="_blank" 
              rel="noopener noreferrer"
              class="text-gray-500 hover:text-gray-300 transition-colors underline cursor-pointer inline-block py-1 px-2"
              style="z-index: 999; position: relative;"
            >
              赣ICP备2025074925号
            </a>
          </p>
          <p class="text-gray-600 text-xs mt-1">
            审核通过日期：2025-10-27
          </p>
        </div>
      </div>
    </footer>
  </body>
</html>
