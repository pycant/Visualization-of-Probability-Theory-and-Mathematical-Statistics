<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>概率维度 | Probability Dimensions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="../static/js/url-click-handler.js"></script>

    <!-- Markdown和LaTeX渲染库 -->
    <script src="../static/libs/marked/marked.min.js"></script>
    <script src="../static/libs/katex/js/katex.min.js"></script>
    <link rel="stylesheet" href="../static/libs/katex/css/katex.min.css" />
    <script src="../static/libs/katex/js/auto-render.min.js"></script>

    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              "neon-blue": "#00f3ff",
              "neon-purple": "#bf00ff",
              "neon-green": "#00ff66",
              "neon-orange": "#ff8c00",
              "dark-bg": "#050a1a",
              "dark-card": "#0f1730",
            },
            fontFamily: {
              future: ["Orbitron", "sans-serif"],
              data: ["Rajdhani", "sans-serif"],
            },
            animation: {
              "pulse-slow": "pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite",
              glow: "glow 2s ease-in-out infinite alternate",
            },
            keyframes: {
              glow: {
                "0%": {
                  textShadow:
                    "0 0 5px #fff, 0 0 10px #00f3ff, 0 0 15px #00f3ff",
                },
                "100%": {
                  textShadow:
                    "0 0 10px #fff, 0 0 20px #00f3ff, 0 0 30px #00f3ff, 0 0 40px #00f3ff",
                },
              },
            },
          },
        },
      };
    </script>

    <style type="text/tailwindcss">
      @layer utilities {
        .text-shadow-neon {
          text-shadow: 0 0 10px rgba(0, 243, 255, 0.7),
            0 0 20px rgba(0, 243, 255, 0.5);
        }
        .text-shadow-purple {
          text-shadow: 0 0 10px rgba(191, 0, 255, 0.7),
            0 0 20px rgba(191, 0, 255, 0.5);
        }
        .border-glow {
          box-shadow: 0 0 5px theme("colors.neon-blue"),
            0 0 10px theme("colors.neon-blue/30");
        }
        .bg-grid {
          background-image: linear-gradient(
              rgba(0, 243, 255, 0.1) 1px,
              transparent 1px
            ),
            linear-gradient(90deg, rgba(0, 243, 255, 0.1) 1px, transparent 1px);
          background-size: 20px 20px;
        }
        .clip-path-slant {
          /* 移除裁剪路径以避免内容被切除 */
          /* clip-path: polygon(0 0, 100% 0, 100% 95%, 0 100%); */
        }
        .glass-effect {
          backdrop-filter: blur(10px);
          background-color: rgba(15, 23, 48, 0.6);
        }

        /* 社交媒体图标动画效果 */
        .social-icon {
          position: relative;
          overflow: hidden;
        }

        .social-icon::before {
          content: "";
          position: absolute;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;
          background: linear-gradient(
            90deg,
            transparent,
            rgba(255, 255, 255, 0.3),
            transparent
          );
          transition: left 0.5s;
        }

        .social-icon:hover::before {
          left: 100%;
        }

        .social-icon:hover img {
          transform: scale(1.1);
          filter: brightness(1.2);
        }

        @keyframes pulse-glow {
          0%,
          100% {
            box-shadow: 0 0 5px rgba(0, 243, 255, 0.3);
          }
          50% {
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.6),
              0 0 30px rgba(0, 243, 255, 0.4);
          }
        }

        .social-icon:hover {
          animation: pulse-glow 2s infinite;
        }

        /* Markdown内容样式 */
        .message-content h1,
        .message-content h2,
        .message-content h3,
        .message-content h4,
        .message-content h5,
        .message-content h6 {
          color: #00f3ff;
          font-weight: 600;
          margin: 0.5rem 0;
        }

        .message-content h1 {
          font-size: 1.25rem;
        }
        .message-content h2 {
          font-size: 1.125rem;
        }
        .message-content h3 {
          font-size: 1rem;
        }

        .message-content p {
          margin: 0.5rem 0;
          line-height: 1.6;
        }

        .message-content ul,
        .message-content ol {
          margin: 0.5rem 0;
          padding-left: 1.5rem;
        }

        .message-content li {
          margin: 0.25rem 0;
        }

        .message-content code {
          background-color: rgba(55, 65, 81, 0.8);
          color: #fbbf24;
          padding: 0.125rem 0.25rem;
          border-radius: 0.25rem;
          font-family: "Courier New", monospace;
          font-size: 0.875rem;
        }

        .message-content pre {
          background-color: rgba(31, 41, 55, 0.9);
          border: 1px solid rgba(75, 85, 99, 0.5);
          border-radius: 0.5rem;
          padding: 1rem;
          margin: 0.5rem 0;
          overflow-x: auto;
        }

        .message-content pre code {
          background: none;
          padding: 0;
          color: #e5e7eb;
        }

        .message-content blockquote {
          border-left: 4px solid #00f3ff;
          padding-left: 1rem;
          margin: 0.5rem 0;
          color: #d1d5db;
          font-style: italic;
        }

        .message-content table {
          border-collapse: collapse;
          width: 100%;
          margin: 0.5rem 0;
        }

        .message-content th,
        .message-content td {
          border: 1px solid rgba(75, 85, 99, 0.5);
          padding: 0.5rem;
          text-align: left;
        }

        .message-content th {
          background-color: rgba(55, 65, 81, 0.8);
          color: #00f3ff;
          font-weight: 600;
        }

        .message-content a {
          color: #00f3ff;
          text-decoration: underline;
        }

        .message-content a:hover {
          color: #bf00ff;
        }

        /* KaTeX公式样式调整 */
        .message-content .katex {
          color: #e5e7eb !important;
        }

        .message-content .katex-display {
          margin: 1rem 0;
        }

        /* 思考动画样式 */
        .thinking-animation {
          display: flex;
          align-items: center;
          gap: 4px;
        }

        .thinking-animation .dot {
          width: 6px;
          height: 6px;
          border-radius: 50%;
          background-color: #00f3ff;
          animation: thinking-pulse 1.4s ease-in-out infinite both;
        }

        .thinking-animation .dot:nth-child(1) {
          animation-delay: -0.32s;
        }

        .thinking-animation .dot:nth-child(2) {
          animation-delay: -0.16s;
        }

        .thinking-animation .dot:nth-child(3) {
          animation-delay: 0s;
        }

        @keyframes thinking-pulse {
          0%,
          80%,
          100% {
            transform: scale(0.8);
            opacity: 0.5;
          }
          40% {
            transform: scale(1.2);
            opacity: 1;
          }
        }
      }
    </style>

    <!-- 引入Google字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Rajdhani:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
  </head>

  <body class="bg-dark-bg text-gray-200 font-data overflow-x-hidden">
    <!-- 粒子背景容器 -->
    <div id="particles-container" class="fixed inset-0 z-0 opacity-30"></div>

    <!-- 导航栏 -->
    <nav
      class="glass-effect fixed w-full z-50 transition-all duration-300"
      id="main-nav"
    >
      <div
        class="container mx-auto px-4 py-3 flex justify-between items-center"
      >
        <div class="flex items-center space-x-2">
          <div
            class="w-10 h-10 rounded-full bg-gradient-to-r from-neon-blue to-neon-purple flex items-center justify-center"
          >
            <i class="fa fa-calculator text-white text-xl"></i>
          </div>
          <h1 class="text-xl md:text-2xl font-future font-bold text-white">
            <span class="text-neon-blue">概率</span
            ><span class="text-white">维度</span>
          </h1>
        </div>

        <!-- 桌面导航 -->
        <div class="hidden md:flex items-center space-x-8">
          <a
            href="#concepts"
            class="hover:text-neon-blue transition-colors duration-300"
            >核心概念</a
          >
          <a
            href="#simulations"
            class="hover:text-neon-blue transition-colors duration-300"
            >概率模拟</a
          >
          <a
            href="#visualizations"
            class="hover:text-neon-blue transition-colors duration-300"
            >数据可视化</a
          >
          <a
            href="#applications"
            class="hover:text-neon-blue transition-colors duration-300"
            >应用场景</a
          >
        </div>

        <!-- 移动端菜单按钮 -->
        <button
          class="md:hidden text-white text-2xl"
          id="menu-toggle"
          aria-label="打开导航菜单"
          title="打开导航菜单"
        >
          <i class="fa fa-bars"></i>
        </button>
      </div>

      <!-- 移动端导航菜单 -->
      <div
        class="md:hidden hidden glass-effect absolute w-full"
        id="mobile-menu"
      >
        <div class="container mx-auto px-4 py-4 flex flex-col space-y-4">
          <a
            href="#concepts"
            class="hover:text-neon-blue transition-colors duration-300 py-2"
            >核心概念</a
          >
          <a
            href="#simulations"
            class="hover:text-neon-blue transition-colors duration-300 py-2"
            >概率模拟</a
          >
          <a
            href="#visualizations"
            class="hover:text-neon-blue transition-colors duration-300 py-2"
            >数据可视化</a
          >
          <a
            href="#applications"
            class="hover:text-neon-blue transition-colors duration-300 py-2"
            >应用场景</a
          >
        </div>
      </div>
    </nav>

    <!-- 英雄区域 -->
    <header
      class="relative min-h-screen flex items-center justify-center overflow-hidden bg-grid pt-16"
    >
      <div
        class="absolute inset-0 bg-gradient-to-b from-dark-bg/70 via-dark-bg/50 to-dark-bg"
      ></div>

      <!-- 动态图形元素 -->
      <div
        class="absolute w-64 h-64 rounded-full bg-neon-blue/20 blur-3xl -top-20 -left-20 animate-pulse-slow"
      ></div>
      <div
        class="absolute w-96 h-96 rounded-full bg-neon-purple/20 blur-3xl -bottom-40 -right-20 animate-pulse-slow"
        style="animation-delay: 1s"
      ></div>

      <div class="container mx-auto px-4 z-10 text-center">
        <h1
          class="text-[clamp(2.5rem,8vw,5rem)] font-future font-bold leading-tight mb-6 animate-glow"
        >
          <span class="block text-white">概率论与</span>
          <span class="text-neon-blue">数理统计</span>
        </h1>
        <p
          class="text-[clamp(1rem,3vw,1.5rem)] text-gray-300 max-w-3xl mx-auto mb-10"
        >
          探索数据背后的规律，揭示宇宙的概率法则，预测未来的可能路径
        </p>
        <div class="flex flex-col sm:flex-row justify-center gap-4">
          <a
            href="#simulations"
            class="px-8 py-3 bg-neon-blue text-dark-bg font-bold rounded-md hover:bg-white transition-all duration-300 transform hover:scale-105 border-glow"
          >
            开始模拟 <i class="fa fa-rocket ml-2"></i>
          </a>
          <a
            href="#concepts"
            class="px-8 py-3 bg-transparent border border-neon-blue text-neon-blue font-bold rounded-md hover:bg-neon-blue/10 transition-all duration-300"
          >
            了解概念 <i class="fa fa-book ml-2"></i>
          </a>
        </div>

        <!-- 滚动指示器 -->
        <div
          class="absolute bottom-10 left-1/2 transform -translate-x-1/2 animate-bounce"
        >
          <i class="fa fa-angle-down text-neon-blue text-3xl"></i>
        </div>
      </div>
    </header>

    <!-- 核心概念部分 -->
    <section id="concepts" class="py-20 relative">
      <div class="absolute inset-0 bg-grid opacity-20"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-16">
          <h2 class="text-[clamp(1.8rem,5vw,3rem)] font-future font-bold mb-4">
            <span class="text-neon-blue">核心</span>概念
          </h2>
          <p class="text-gray-400 max-w-2xl mx-auto">
            探索概率论与数理统计的基础构建模块，这些概念是理解随机世界的关键
          </p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
          <!-- 概念卡片1 -->
          <div
            class="bg-dark-card rounded-xl p-6 border border-gray-800 hover:border-neon-blue transition-all duration-300 transform hover:-translate-y-2 group"
          >
            <!-- 微缩预览：随机变量 -->
            <div
              class="relative h-[225px] overflow-hidden rounded-lg border border-gray-800 mb-4 group concept-preview cursor-pointer"
              data-target-url="random_variables.html"
              aria-label="打开随机变量页面"
              role="button"
            >
              <iframe
                src="random_variables.html"
                class="pointer-events-none"
                style="
                  position: absolute;
                  left: 50%;
                  top: 50%;
                  transform: translate(-50%, -50%) scale(0.25);
                  transform-origin: center center;
                  width: 1600px;
                  height: 900px;
                "
              ></iframe>
              <div
                class="absolute bottom-2 left-2 bg-dark-card/70 px-3 py-1 rounded text-sm text-gray-300"
              >
                随机变量 · 预览
              </div>
            </div>
            <div
              class="w-14 h-14 rounded-lg bg-neon-blue/10 flex items-center justify-center mb-6 group-hover:bg-neon-blue/20 transition-colors"
            >
              <i class="fa fa-random text-neon-blue text-2xl"></i>
            </div>
            <h3 class="text-xl font-future font-semibold mb-3 text-white">
              随机变量
            </h3>
            <p class="text-gray-400">
              表示随机现象结果的变量，是概率理论的基础。分为离散型和连续型，描述了不确定性的数学表达。
            </p>
            <div class="mt-6 pt-4 border-t border-gray-800">
              <a
                href="random_variables.html"
                class="text-neon-blue hover:text-white transition-colors flex items-center"
              >
                深入了解 <i class="fa fa-arrow-right ml-2 text-sm"></i>
              </a>
            </div>
          </div>

          <!-- 概念卡片2 -->
          <div
            class="bg-dark-card rounded-xl p-6 border border-gray-800 hover:border-neon-purple transition-all duration-300 transform hover:-translate-y-2 group"
          >
            <!-- 微缩预览：概率分布 -->
            <div
              class="relative h-[225px] overflow-hidden rounded-lg border border-gray-800 mb-4 group concept-preview cursor-pointer"
              data-target-url="probability_distributions.html"
              aria-label="打开概率分布页面"
              role="button"
            >
              <iframe
                src="probability_distributions.html"
                class="pointer-events-none"
                style="
                  position: absolute;
                  left: 50%;
                  top: 50%;
                  transform: translate(-50%, -50%) scale(0.25);
                  transform-origin: center center;
                  width: 1600px;
                  height: 900px;
                "
              ></iframe>
              <div
                class="absolute bottom-2 left-2 bg-dark-card/70 px-3 py-1 rounded text-sm text-gray-300"
              >
                概率分布 · 预览
              </div>
            </div>
            <div
              class="w-14 h-14 rounded-lg bg-neon-purple/10 flex items-center justify-center mb-6 group-hover:bg-neon-purple/20 transition-colors"
            >
              <i class="fa fa-area-chart text-neon-purple text-xl mr-1"></i>
              <i class="fa fa-infinity text-neon-purple text-xl"></i>
            </div>
            <h3 class="text-xl font-future font-semibold mb-3 text-white">
              概率分布
            </h3>
            <p class="text-gray-400">
              描述随机变量取值的概率规律，如正态分布、泊松分布等。是数据分析和预测的核心工具。
            </p>
            <div class="mt-6 pt-4 border-t border-gray-800">
              <a
                href="probability_distributions.html"
                class="text-neon-purple hover:text-white transition-colors flex items-center"
              >
                深入了解 <i class="fa fa-arrow-right ml-2 text-sm"></i>
              </a>
            </div>
          </div>

          <!-- 概念卡片3 -->
          <div
            class="bg-dark-card rounded-xl p-6 border border-gray-800 hover:border-neon-green transition-all duration-300 transform hover:-translate-y-2 group"
          >
            <!-- 微缩预览：期望与方差 -->
            <div
              class="relative h-[225px] overflow-hidden rounded-lg border border-gray-800 mb-4 group concept-preview cursor-pointer"
              data-target-url="expectation_variance.html"
              aria-label="打开期望与方差页面"
              role="button"
            >
              <iframe
                src="expectation_variance.html"
                class="pointer-events-none"
                style="
                  position: absolute;
                  left: 50%;
                  top: 50%;
                  transform: translate(-50%, -50%) scale(0.25);
                  transform-origin: center center;
                  width: 1600px;
                  height: 900px;
                "
              ></iframe>
              <div
                class="absolute bottom-2 left-2 bg-dark-card/70 px-3 py-1 rounded text-sm text-gray-300"
              >
                期望与方差 · 预览
              </div>
            </div>
            <div
              class="w-14 h-14 rounded-lg bg-neon-green/10 flex items-center justify-center mb-6 group-hover:bg-neon-green/20 transition-colors"
            >
              <i class="fa fa-calculator text-neon-green text-2xl"></i>
            </div>
            <h3 class="text-xl font-future font-semibold mb-3 text-white">
              期望与方差
            </h3>
            <p class="text-gray-400">
              描述随机变量的集中趋势和离散程度，是概率分布的重要数字特征，用于风险评估和决策分析。
            </p>
            <div class="mt-6 pt-4 border-t border-gray-800">
              <a
                href="expectation_variance.html"
                class="text-neon-green hover:text-white transition-colors flex items-center"
              >
                深入了解 <i class="fa fa-arrow-right ml-2 text-sm"></i>
              </a>
            </div>
          </div>

          <!-- 概念卡片4 - 区间估计 -->
          <div
            class="bg-dark-card rounded-xl p-6 border border-gray-800 hover:border-neon-orange transition-all duration-300 transform hover:-translate-y-2 group"
          >
            <!-- 微缩预览：区间估计 -->
            <div
              class="relative h-[225px] overflow-hidden rounded-lg border border-gray-800 mb-4 group concept-preview cursor-pointer"
              data-target-url="interval_estimation.html"
              aria-label="打开区间估计页面"
              role="button"
            >
              <iframe
                src="interval_estimation.html"
                class="pointer-events-none"
                style="
                  position: absolute;
                  left: 50%;
                  top: 50%;
                  transform: translate(-50%, -50%) scale(0.25);
                  transform-origin: center center;
                  width: 1600px;
                  height: 900px;
                "
              ></iframe>
              <div
                class="absolute bottom-2 left-2 bg-dark-card/70 px-3 py-1 rounded text-sm text-gray-300"
              >
                区间估计 · 预览
              </div>
            </div>
            <div
              class="w-14 h-14 rounded-lg bg-orange-500/10 flex items-center justify-center mb-6 group-hover:bg-orange-500/20 transition-colors"
            >
              <i class="fa fa-chart-bar text-orange-500 text-2xl"></i>
            </div>
            <h3 class="text-xl font-future font-semibold mb-3 text-white">
              区间估计
            </h3>
            <p class="text-gray-400">
              用样本统计量构造包含未知参数的区间，给出参数估计的精度和可信度，是统计推断的核心方法。
            </p>
            <div class="mt-6 pt-4 border-t border-gray-800">
              <a
                href="interval_estimation.html"
                class="text-orange-500 hover:text-white transition-colors flex items-center"
              >
                深入了解 <i class="fa fa-arrow-right ml-2 text-sm"></i>
              </a>
            </div>
          </div>

          <!-- 概念卡片5 - 假设检验 -->
          <div
            class="bg-dark-card rounded-xl p-6 border border-gray-800 hover:border-neon-blue transition-all duration-300 transform hover:-translate-y-2 group"
          >
            <!-- 微缩预览：假设检验 -->
            <div
              class="relative h-[225px] overflow-hidden rounded-lg border border-gray-800 mb-4 group concept-preview cursor-pointer"
              data-target-url="hypothesis_testing.html"
              aria-label="打开假设检验页面"
              role="button"
            >
              <iframe
                src="hypothesis_testing.html"
                class="pointer-events-none"
                style="
                  position: absolute;
                  left: 50%;
                  top: 50%;
                  transform: translate(-50%, -50%) scale(0.25);
                  transform-origin: center center;
                  width: 1600px;
                  height: 900px;
                "
              ></iframe>
              <div
                class="absolute bottom-2 left-2 bg-dark-card/70 px-3 py-1 rounded text-sm text-gray-300"
              >
                假设检验 · 预览
              </div>
            </div>
            <div
              class="w-14 h-14 rounded-lg bg-neon-blue/10 flex items-center justify-center mb-6 group-hover:bg-neon-blue/20 transition-colors"
            >
              <i class="fa fa-flask text-neon-blue text-2xl"></i>
            </div>
            <h3 class="text-xl font-future font-semibold mb-3 text-white">
              假设检验
            </h3>
            <p class="text-gray-400">
              统计推断的重要方法，通过样本数据判断关于总体的假设是否成立，是科学研究的关键工具。
            </p>
            <div class="mt-6 pt-4 border-t border-gray-800">
              <a
                href="hypothesis_testing.html"
                class="text-neon-blue hover:text-white transition-colors flex items-center"
              >
                深入了解 <i class="fa fa-arrow-right ml-2 text-sm"></i>
              </a>
            </div>
          </div>

          <!-- 概念卡片7 -->
          <div
            class="bg-dark-card rounded-xl p-6 border border-gray-800 hover:border-neon-green transition-all duration-300 transform hover:-translate-y-2 group"
          >
            <!-- 微缩预览：大数定律 -->
            <div
              class="relative h-[225px] overflow-hidden rounded-lg border border-gray-800 mb-4 group concept-preview cursor-pointer"
              data-target-url="law_of_large_numbers.html"
              aria-label="打开大数定律页面"
              role="button"
            >
              <iframe
                src="law_of_large_numbers.html"
                class="pointer-events-none"
                style="
                  position: absolute;
                  left: 50%;
                  top: 50%;
                  transform: translate(-50%, -50%) scale(0.25);
                  transform-origin: center center;
                  width: 1600px;
                  height: 900px;
                "
              ></iframe>
              <div
                class="absolute bottom-2 left-2 bg-dark-card/70 px-3 py-1 rounded text-sm text-gray-300"
              >
                大数定律 · 预览
              </div>
            </div>
            <div
              class="w-14 h-14 rounded-lg bg-neon-green/10 flex items-center justify-center mb-6 group-hover:bg-neon-green/20 transition-colors"
            >
              <i class="fa fa-random text-neon-green text-2xl"></i>
            </div>
            <h3 class="text-xl font-future font-semibold mb-3 text-white">
              大数定律
            </h3>
            <p class="text-gray-400">
              描述大量重复试验中随机现象的统计规律性，是频率趋近于概率的理论基础，支撑着统计推断。
            </p>
            <div class="mt-6 pt-4 border-t border-gray-800">
              <a
                href="law_of_large_numbers.html"
                class="text-neon-green hover:text-white transition-colors flex items-center"
              >
                深入了解 <i class="fa fa-arrow-right ml-2 text-sm"></i>
              </a>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 概念卡片点击放大并跳转脚本 -->
    <script>
      function expandPreviewAndNavigate(el, url) {
        try {
          const rect = el.getBoundingClientRect();
          const clone = el.cloneNode(true);
          const overlay = document.createElement("div");
          overlay.style.position = "fixed";
          overlay.style.inset = "0";
          overlay.style.background = "rgba(0,0,0,0.6)";
          overlay.style.zIndex = "9998";
          document.body.appendChild(overlay);

          clone.style.position = "fixed";
          clone.style.left = rect.left + "px";
          clone.style.top = rect.top + "px";
          clone.style.width = rect.width + "px";
          clone.style.height = rect.height + "px";
          clone.style.zIndex = "9999";
          clone.classList.remove("group");
          document.body.appendChild(clone);

          const go = () => {
            window.location.href = url;
          };
          if (window.gsap) {
            gsap.to(clone, { duration: 0.35, ease: "power2.out", scale: 1.2 });
            gsap.to(overlay, {
              duration: 0.35,
              ease: "power2.out",
              opacity: 0.9,
              onComplete: go,
            });
          } else {
            setTimeout(go, 280);
          }
        } catch (e) {
          window.location.href = url;
        }
      }

      function setupConceptPreviewCards() {
        document.querySelectorAll(".concept-preview").forEach((el) => {
          const url = el.getAttribute("data-target-url");
          el.addEventListener("click", () => expandPreviewAndNavigate(el, url));
        });
      }

      document.addEventListener("DOMContentLoaded", setupConceptPreviewCards);
    </script>

    <!-- 概率模拟部分 -->
    <section
      id="simulations"
      class="py-20 relative bg-gradient-to-b from-dark-bg to-dark-card/50 clip-path-slant"
    >
      <div class="absolute inset-0 bg-grid opacity-10"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-16">
          <h2 class="text-[clamp(1.8rem,5vw,3rem)] font-future font-bold mb-4">
            概率<span class="text-neon-purple">模拟</span>实验室
          </h2>
          <p class="text-gray-400 max-w-2xl mx-auto">
            通过交互式模拟实验，直观感受概率规律的神奇之处
          </p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-12">
          <!-- 掷骰子模拟器 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-dice text-neon-purple mr-3"></i> 掷骰子模拟
            </h3>

            <div class="mb-6">
              <label for="dice-trials" class="block text-gray-300 mb-2"
                >试验次数:</label
              >
              <div class="flex items-center">
                <input
                  type="range"
                  id="dice-trials"
                  min="10"
                  max="10000"
                  step="10"
                  value="1000"
                  class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-purple"
                />
                <span
                  id="dice-trials-value"
                  class="ml-4 text-neon-purple font-bold"
                  >1000</span
                >
              </div>
            </div>

            <div class="flex justify-center mb-6">
              <button
                id="roll-dice"
                class="px-6 py-2 bg-neon-purple text-white font-bold rounded-md hover:bg-neon-purple/80 transition-all duration-300 transform hover:scale-105"
              >
                开始模拟 <i class="fa fa-play ml-2"></i>
              </button>
            </div>

            <div class="h-64">
              <canvas id="dice-chart"></canvas>
            </div>

            <div
              class="mt-6 pt-4 border-t border-gray-800 text-sm text-gray-400"
            >
              <p>
                模拟掷骰子的随机过程，随着试验次数增加，各点数出现的频率会逐渐趋近于理论概率(1/6)。
              </p>
            </div>
          </div>

          <!-- 正态分布模拟器 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-bell text-neon-blue mr-3"></i> 正态分布生成
            </h3>

            <div class="grid grid-cols-2 gap-4 mb-6">
              <div>
                <label for="normal-sim-mean" class="block text-gray-300 mb-2"
                  >均值 (μ):</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="normal-sim-mean"
                    min="-10"
                    max="10"
                    step="0.5"
                    value="0"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue"
                  />
                  <span
                    id="normal-sim-mean-value"
                    class="ml-4 text-neon-blue font-bold"
                    >0</span
                  >
                </div>
              </div>
              <div>
                <label for="normal-sim-std" class="block text-gray-300 mb-2"
                  >标准差 (σ):</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="normal-sim-std"
                    min="0.5"
                    max="5"
                    step="0.5"
                    value="1"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue"
                  />
                  <span
                    id="normal-sim-std-value"
                    class="ml-4 text-neon-blue font-bold"
                    >1</span
                  >
                </div>
              </div>
            </div>

            <div class="flex justify-center mb-6">
              <button
                id="generate-normal"
                class="px-6 py-2 bg-neon-blue text-dark-bg font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300 transform hover:scale-105"
              >
                生成分布 <i class="fa fa-refresh ml-2"></i>
              </button>
            </div>

            <div class="h-64">
              <canvas id="normal-chart"></canvas>
            </div>

            <div
              class="mt-6 pt-4 border-t border-gray-800 text-sm text-gray-400"
            >
              <p>
                正态分布是自然界中最常见的分布之一，由均值和标准差决定其形状，呈现典型的"钟形曲线"。
              </p>
            </div>
          </div>

          <!-- 蒙特卡洛模拟 -->
          <div
            class="bg-dark-card rounded-xl p-6 border border-gray-800 lg:col-span-2"
          >
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-calculator text-neon-green mr-3"></i> 蒙特卡洛 π
              值计算
            </h3>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
              <div class="md:col-span-1">
                <div class="mb-6">
                  <label
                    for="monte-carlo-samples"
                    class="block text-gray-300 mb-2"
                    >样本数量:</label
                  >
                  <div class="flex items-center">
                    <input
                      type="range"
                      id="monte-carlo-samples"
                      min="100"
                      max="10000"
                      step="100"
                      value="1000"
                      class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-green"
                    />
                    <span
                      id="monte-carlo-samples-value"
                      class="ml-4 text-neon-green font-bold"
                      >1000</span
                    >
                  </div>
                </div>

                <div class="flex justify-center mb-6">
                  <button
                    id="calculate-pi"
                    class="px-6 py-2 bg-neon-green text-dark-bg font-bold rounded-md hover:bg-neon-green/80 transition-all duration-300 transform hover:scale-105"
                  >
                    计算 π 值 <i class="fa fa-calculator ml-2"></i>
                  </button>
                </div>

                <div class="bg-dark-bg rounded-lg p-4 border border-gray-700">
                  <h4 class="text-gray-300 mb-2 font-semibold">计算结果:</h4>
                  <div class="flex justify-between items-center mb-2">
                    <span class="text-gray-400">估计值:</span>
                    <span id="pi-estimate" class="text-neon-green font-bold"
                      >3.1416</span
                    >
                  </div>
                  <div class="flex justify-between items-center mb-2">
                    <span class="text-gray-400">精确值:</span>
                    <span class="text-white font-bold">3.1415926535</span>
                  </div>
                  <div class="flex justify-between items-center">
                    <span class="text-gray-400">误差:</span>
                    <span id="pi-error" class="text-neon-green font-bold"
                      >0.0000%</span
                    >
                  </div>
                </div>
              </div>

              <div class="md:col-span-2 h-64">
                <canvas id="monte-carlo-chart"></canvas>
              </div>
            </div>

            <div
              class="mt-6 pt-4 border-t border-gray-800 text-sm text-gray-400"
            >
              <p>
                蒙特卡洛方法通过随机采样估算π值：在正方形内随机生成点，计算落在四分之一圆内的点的比例，乘以4即可得到π的近似值。样本量越大，结果越精确。
              </p>
            </div>
          </div>

          <!-- 高尔顿（道尔顿）板模拟 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-diagram-project text-neon-blue mr-3"></i>
              高尔顿板（豆子机）
            </h3>

            <div class="grid grid-cols-2 gap-4 mb-6">
              <div>
                <label for="galton-rows" class="block text-gray-300 mb-2"
                  >层数（行数）:</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="galton-rows"
                    min="5"
                    max="12"
                    step="1"
                    value="10"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue"
                  />
                  <span
                    id="galton-rows-value"
                    class="ml-4 text-neon-blue font-bold"
                    >10</span
                  >
                </div>
              </div>
              <div>
                <label for="galton-balls" class="block text-gray-300 mb-2"
                  >小球数量:</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="galton-balls"
                    min="100"
                    max="5000"
                    step="100"
                    value="1000"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue"
                  />
                  <span
                    id="galton-balls-value"
                    class="ml-4 text-neon-blue font-bold"
                    >1000</span
                  >
                </div>
              </div>
            </div>

            <!-- 动画与理论曲线控制 -->
            <div class="grid grid-cols-2 gap-4 mb-6">
              <div>
                <label class="block text-gray-300 mb-2">动画设置:</label>
                <div
                  class="bg-dark-bg rounded-lg p-4 border border-gray-700 space-y-3"
                >
                  <label class="inline-flex items-center space-x-2">
                    <input
                      type="checkbox"
                      id="galton-anim-enable"
                      class="form-checkbox accent-neon-blue"
                    />
                    <span class="text-gray-300">启用动画</span>
                  </label>
                  <div>
                    <label for="galton-speed" class="block text-gray-300 mb-2"
                      >播放速度（倍速）:</label
                    >
                    <div class="flex items-center">
                      <input
                        type="range"
                        id="galton-speed"
                        min="0.5"
                        max="3"
                        step="0.1"
                        value="1"
                        class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue"
                      />
                      <span
                        id="galton-speed-value"
                        class="ml-4 text-neon-blue font-bold"
                        >1.0x</span
                      >
                    </div>
                  </div>
                </div>
              </div>
              <div>
                <label class="block text-gray-300 mb-2">理论近似:</label>
                <div
                  class="bg-dark-bg rounded-lg p-4 border border-gray-700 space-y-3"
                >
                  <label class="inline-flex items-center space-x-2">
                    <input
                      type="checkbox"
                      id="galton-show-theory"
                      checked
                      class="form-checkbox accent-neon-blue"
                    />
                    <span class="text-gray-300"
                      >显示理论近似曲线（正态近似）</span
                    >
                  </label>
                </div>
              </div>
            </div>

            <!-- 动画区域（位于柱状图正上方） -->
            <div
              class="h-48 mb-4 relative bg-gray-900 rounded-md border border-gray-800 overflow-hidden"
            >
              <canvas id="galton-anim" class="w-full h-full"></canvas>
            </div>

            <div class="flex justify-center mb-6">
              <button
                id="run-galton"
                class="px-6 py-2 bg-neon-blue text-dark-bg font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300 transform hover:scale-105"
              >
                开始模拟 <i class="fa fa-play ml-2"></i>
              </button>
            </div>

            <div class="h-64">
              <canvas id="galton-chart"></canvas>
            </div>

            <div
              class="mt-6 pt-4 border-t border-gray-800 text-sm text-gray-400"
            >
              <p>
                通过在每层随机向左/右的决策，最终落点呈现近似正态的二项分布（中心极限定理的直观体现）。
              </p>
            </div>
          </div>

          <!-- 蒲丰投针（估算 π） -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-ruler-combined text-neon-orange mr-3"></i>
              蒲丰投针
            </h3>

            <div class="grid grid-cols-2 gap-4 mb-6">
              <div>
                <label for="buffon-needles" class="block text-gray-300 mb-2"
                  >投针次数:</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="buffon-needles"
                    min="200"
                    max="5000"
                    step="100"
                    value="2000"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-orange"
                  />
                  <span
                    id="buffon-needles-value"
                    class="ml-4 text-neon-orange font-bold"
                    >2000</span
                  >
                </div>
              </div>
              <div>
                <label class="block text-gray-300 mb-2">结果:</label>
                <div class="bg-dark-bg rounded-lg p-4 border border-gray-700">
                  <div class="flex justify-between items-center mb-2">
                    <span class="text-gray-400">π 估计:</span>
                    <span id="buffon-pi" class="text-neon-orange font-bold"
                      >3.1416</span
                    >
                  </div>
                  <div class="flex justify-between items-center">
                    <span class="text-gray-400">误差:</span>
                    <span id="buffon-error" class="text-neon-orange font-bold"
                      >0.0000%</span
                    >
                  </div>
                </div>
              </div>
            </div>

            <div class="flex justify-center mb-6">
              <button
                id="buffon-throw"
                class="px-6 py-2 bg-neon-orange text-dark-bg font-bold rounded-md hover:bg-neon-orange/80 transition-all duration-300 transform hover:scale-105"
              >
                投针模拟 <i class="fa fa-play ml-2"></i>
              </button>
            </div>

            <div class="h-64">
              <canvas id="buffon-canvas"></canvas>
            </div>

            <div
              class="mt-6 pt-4 border-t border-gray-800 text-sm text-gray-400"
            >
              <p>
                当针长小于板条间距时，穿越概率与 π 存在解析关系，利用频率估计
                π。
              </p>
              <div
                class="mt-3 bg-dark-bg rounded-lg p-4 border border-gray-700"
              >
                <div class="text-gray-300 mb-2">计算公式：</div>
                <div id="buffon-formula-p" class="text-white"></div>
                <div id="buffon-formula-pi" class="text-white mt-2"></div>
                <div id="buffon-formula-special" class="text-white mt-2"></div>
                <div class="text-gray-400 mt-2">
                  变量含义：L=针长，d=板条间距，N=投针次数，X=穿越次数。
                </div>
              </div>
            </div>
          </div>

          <!-- 生日悖论 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-cake-candles text-neon-purple mr-3"></i> 生日悖论
            </h3>

            <div class="grid grid-cols-2 gap-4 mb-6">
              <div>
                <label for="birthday-group" class="block text-gray-300 mb-2"
                  >组人数:</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="birthday-group"
                    min="2"
                    max="100"
                    step="1"
                    value="23"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-purple"
                  />
                  <span
                    id="birthday-group-value"
                    class="ml-4 text-neon-purple font-bold"
                    >23</span
                  >
                </div>
              </div>
              <div>
                <label for="birthday-trials" class="block text-gray-300 mb-2"
                  >模拟次数:</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="birthday-trials"
                    min="200"
                    max="10000"
                    step="200"
                    value="2000"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-purple"
                  />
                  <span
                    id="birthday-trials-value"
                    class="ml-4 text-neon-purple font-bold"
                    >2000</span
                  >
                </div>
              </div>
            </div>

            <div class="flex justify-center mb-6 gap-4">
              <button
                id="birthday-calc"
                class="px-6 py-2 bg-neon-purple text-dark-bg font-bold rounded-md hover:bg-neon-purple/80 transition-all duration-300 transform hover:scale-105"
              >
                计算概率 <i class="fa fa-calculator ml-2"></i>
              </button>
              <button
                id="birthday-sim"
                class="px-6 py-2 bg-neon-purple/60 text-white font-bold rounded-md hover:bg-neon-purple/80 transition-all duration-300 transform hover:scale-105"
              >
                蒙特卡洛模拟 <i class="fa fa-play ml-2"></i>
              </button>
            </div>

            <!-- 动画演示：15×25表格日历 -->
            <div class="mb-6">
              <div class="flex items-center justify-between mb-3">
                <div class="text-gray-300">
                  动画演示（15×25 网格，映射 365 天，余下 10 格为空）
                </div>
                <div class="flex gap-2">
                  <button
                    id="birthday-anim-play"
                    class="px-3 py-1 bg-neon-purple text-dark-bg rounded hover:bg-neon-purple/80"
                  >
                    <i class="fa fa-play mr-1"></i>播放
                  </button>
                  <button
                    id="birthday-anim-step"
                    class="px-3 py-1 bg-neon-purple/70 text-white rounded hover:bg-neon-purple/80"
                  >
                    <i class="fa fa-step-forward mr-1"></i>逐个取人
                  </button>
                  <button
                    id="birthday-fill-group"
                    class="px-3 py-1 bg-neon-purple/60 text-white rounded hover:bg-neon-purple/80"
                  >
                    <i class="fa fa-forward mr-1"></i>填满当前组
                  </button>
                  <button
                    id="birthday-fast-all"
                    class="px-3 py-1 bg-neon-purple/50 text-white rounded hover:bg-neon-purple/80"
                  >
                    <i class="fa fa-forward-fast mr-1"></i>跳过逐个取组
                  </button>
                  <button
                    id="birthday-reset"
                    class="px-3 py-1 bg-gray-700 text-white rounded hover:bg-gray-600"
                  >
                    <i class="fa fa-rotate-left mr-1"></i>重置
                  </button>
                </div>
              </div>
              <div
                class="h-64 bg-dark-bg rounded-lg p-2 border border-gray-700"
              >
                <canvas id="birthday-grid" class="w-full h-full"></canvas>
              </div>
              <div class="mt-2 text-sm text-gray-400 flex justify-between">
                <span
                  >当前组进度：<span
                    id="birthday-progress"
                    class="text-neon-purple"
                    >0 / 0</span
                  ></span
                >
                <span
                  >已完成组：<span
                    id="birthday-completed"
                    class="text-neon-purple"
                    >0</span
                  >，出现重复：<span
                    id="birthday-success"
                    class="text-neon-purple"
                    >0</span
                  ></span
                >
              </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
              <div class="bg-dark-bg rounded-lg p-4 border border-gray-700">
                <div class="flex justify-between items-center mb-2">
                  <span class="text-gray-400">至少一对同生日（解析）:</span>
                  <span id="birthday-exact" class="text-neon-purple font-bold"
                    >0.5073</span
                  >
                </div>
                <div class="flex justify-between items-center">
                  <span class="text-gray-400">蒙特卡洛估计:</span>
                  <span
                    id="birthday-estimate"
                    class="text-neon-purple font-bold"
                    >0.5000</span
                  >
                </div>
              </div>
              <div class="h-48">
                <canvas id="birthday-chart"></canvas>
              </div>
            </div>

            <div
              class="mt-6 pt-4 border-t border-gray-800 text-sm text-gray-400"
            >
              <p>
                令人直觉惊讶的结论：只需约 23 人，出现至少一组同生日的概率就超过
                50%。
              </p>
            </div>
          </div>

          <!-- 二维随机游走 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-shoe-prints text-neon-green mr-3"></i>
              二维随机游走
            </h3>

            <div class="grid grid-cols-2 gap-4 mb-6">
              <div>
                <label for="walk-steps" class="block text-gray-300 mb-2"
                  >步数:</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="walk-steps"
                    min="100"
                    max="5000"
                    step="100"
                    value="1000"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-green"
                  />
                  <span
                    id="walk-steps-value"
                    class="ml-4 text-neon-green font-bold"
                    >1000</span
                  >
                </div>
              </div>
              <div>
                <label for="walk-step-length" class="block text-gray-300 mb-2"
                  >步长:</label
                >
                <div class="flex items-center">
                  <input
                    type="range"
                    id="walk-step-length"
                    min="1"
                    max="10"
                    step="1"
                    value="3"
                    class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-green"
                  />
                  <span
                    id="walk-step-length-value"
                    class="ml-4 text-neon-green font-bold"
                    >3</span
                  >
                </div>
              </div>
            </div>

            <div class="flex justify-center mb-6">
              <div class="grid grid-cols-2 gap-4 w-full">
                <div class="flex items-center space-x-4">
                  <label class="text-gray-300">动画:</label>
                  <label class="inline-flex items-center cursor-pointer">
                    <input
                      type="checkbox"
                      id="walk-anim-enable"
                      class="accent-neon-green mr-2"
                    />
                    <span class="text-gray-300">启用动画</span>
                  </label>
                </div>
                <div>
                  <label for="walk-speed" class="block text-gray-300 mb-2"
                    >速度:</label
                  >
                  <div class="flex items-center">
                    <input
                      type="range"
                      id="walk-speed"
                      min="0.5"
                      max="4"
                      step="0.1"
                      value="1.0"
                      class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-green"
                    />
                    <span
                      id="walk-speed-value"
                      class="ml-4 text-neon-green font-bold"
                      >1.0x</span
                    >
                  </div>
                </div>
              </div>
            </div>

            <div class="flex flex-wrap gap-3 mb-4">
              <button
                id="run-walk"
                class="px-4 py-2 bg-neon-green text-dark-bg font-bold rounded-md hover:bg-neon-green/80 transition-all duration-300"
              >
                开始/重新生成
              </button>
              <button
                id="walk-play"
                class="px-4 py-2 bg-gray-700 text-white font-bold rounded-md hover:bg-gray-600 transition-all duration-300"
              >
                <i class="fa fa-play mr-1"></i> 播放
              </button>
              <button
                id="walk-pause"
                class="px-4 py-2 bg-gray-700 text-white font-bold rounded-md hover:bg-gray-600 transition-all duration-300"
              >
                <i class="fa fa-pause mr-1"></i> 暂停
              </button>
              <button
                id="walk-step"
                class="px-4 py-2 bg-gray-700 text-white font-bold rounded-md hover:bg-gray-600 transition-all duration-300"
              >
                <i class="fa fa-step-forward mr-1"></i> 单步
              </button>
              <button
                id="walk-reset"
                class="px-4 py-2 bg-gray-700 text-white font-bold rounded-md hover:bg-gray-600 transition-all duration-300"
              >
                <i class="fa fa-undo mr-1"></i> 重置
              </button>
            </div>

            <div class="h-64 bg-dark-bg rounded-lg border border-gray-700 mb-4">
              <canvas id="walk-canvas"></canvas>
            </div>

            <div class="bg-dark-bg rounded-lg border border-gray-700 p-4 mb-2">
              <div class="flex justify-between items-center mb-2">
                <div class="text-gray-300">
                  进度: <span id="walk-progress">0 / 0</span>
                </div>
                <div class="text-gray-300">
                  位移距离 R:
                  <span id="walk-R" class="text-neon-green font-bold"
                    >0.00</span
                  >
                </div>
              </div>
              <div class="w-full h-2 bg-gray-800 rounded overflow-hidden">
                <div
                  id="walk-progress-bar"
                  class="h-2 bg-neon-green"
                  style="width: 0%"
                ></div>
              </div>
              <div class="grid grid-cols-2 gap-4 mt-3">
                <div class="text-gray-300">
                  归一化 R/√n:
                  <span id="walk-Rn" class="text-neon-green font-bold"
                    >0.00</span
                  >
                </div>
                <div class="text-gray-300">
                  当前位置 (x, y):
                  <span id="walk-pos" class="text-neon-green font-bold"
                    >(0.00, 0.00)</span
                  >
                </div>
              </div>
            </div>

            <div
              class="mt-6 pt-4 border-t border-gray-800 text-sm text-gray-400"
            >
              <p>
                路径在平面上随机前进，终点到原点的距离随步数增长按 √n
                规模变化（扩散行为）。
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 数据可视化部分 -->
    <section id="visualizations" class="py-20 relative">
      <div class="absolute inset-0 bg-grid opacity-20"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-16">
          <h2 class="text-[clamp(1.8rem,5vw,3rem)] font-future font-bold mb-4">
            数据<span class="text-neon-green">可视化</span>
          </h2>
          <p class="text-gray-400 max-w-2xl mx-auto">
            通过直观的图表展示概率统计的核心理论和应用
          </p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-12">
          <!-- 分布比较 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-bar-chart text-neon-green mr-3"></i> 概率分布比较
            </h3>

            <div class="mb-6">
              <label for="distribution-select" class="block text-gray-300 mb-3"
                >选择分布:</label
              >
              <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
                <button
                  class="distribution-btn active px-3 py-2 bg-neon-green/20 text-neon-green rounded-md hover:bg-neon-green/30 transition-colors text-sm"
                  data-distribution="normal"
                >
                  正态分布
                </button>
                <button
                  class="distribution-btn px-3 py-2 bg-gray-800 text-gray-300 rounded-md hover:bg-gray-700 transition-colors text-sm"
                  data-distribution="poisson"
                >
                  泊松分布
                </button>
                <button
                  class="distribution-btn px-3 py-2 bg-gray-800 text-gray-300 rounded-md hover:bg-gray-700 transition-colors text-sm"
                  data-distribution="binomial"
                >
                  二项分布
                </button>
                <button
                  class="distribution-btn px-3 py-2 bg-gray-800 text-gray-300 rounded-md hover:bg-gray-700 transition-colors text-sm"
                  data-distribution="exponential"
                >
                  指数分布
                </button>
              </div>
            </div>

            <!-- 分布参数控制区域 -->
            <div id="distribution-params" class="mb-6">
              <!-- 正态分布参数 -->
              <div id="normal-params" class="distribution-params">
                <div class="grid grid-cols-2 gap-4">
                  <div>
                    <label
                      for="normal-mean"
                      class="block text-gray-300 mb-2 text-sm"
                      >均值 (μ):</label
                    >
                    <div class="flex items-center">
                      <input
                        type="range"
                        id="normal-mean"
                        min="-3"
                        max="3"
                        step="0.1"
                        value="0"
                        class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-green"
                      />
                      <span
                        id="normal-mean-value"
                        class="ml-4 text-neon-green font-bold"
                        >0</span
                      >
                    </div>
                  </div>
                  <div>
                    <label
                      for="normal-std"
                      class="block text-gray-300 mb-2 text-sm"
                      >标准差 (σ):</label
                    >
                    <div class="flex items-center">
                      <input
                        type="range"
                        id="normal-std"
                        min="0.1"
                        max="2"
                        step="0.1"
                        value="1"
                        class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-green"
                      />
                      <span
                        id="normal-std-value"
                        class="ml-4 text-neon-green font-bold"
                        >1</span
                      >
                    </div>
                  </div>
                </div>
              </div>

              <!-- 泊松分布参数 -->
              <div id="poisson-params" class="distribution-params hidden">
                <div>
                  <label
                    for="poisson-lambda"
                    class="block text-gray-300 mb-2 text-sm"
                    >λ 参数:</label
                  >
                  <div class="flex items-center">
                    <input
                      type="range"
                      id="poisson-lambda"
                      min="1"
                      max="10"
                      step="0.5"
                      value="3"
                      class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue"
                    />
                    <span
                      id="poisson-lambda-value"
                      class="ml-4 text-neon-blue font-bold"
                      >3</span
                    >
                  </div>
                </div>
              </div>

              <!-- 二项分布参数 -->
              <div id="binomial-params" class="distribution-params hidden">
                <div class="grid grid-cols-2 gap-4">
                  <div>
                    <label
                      for="binomial-n"
                      class="block text-gray-300 mb-2 text-sm"
                      >试验次数 (n):</label
                    >
                    <div class="flex items-center">
                      <input
                        type="range"
                        id="binomial-n"
                        min="5"
                        max="30"
                        step="1"
                        value="10"
                        class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-purple"
                      />
                      <span
                        id="binomial-n-value"
                        class="ml-4 text-neon-purple font-bold"
                        >10</span
                      >
                    </div>
                  </div>
                  <div>
                    <label
                      for="binomial-p"
                      class="block text-gray-300 mb-2 text-sm"
                      >成功概率 (p):</label
                    >
                    <div class="flex items-center">
                      <input
                        type="range"
                        id="binomial-p"
                        min="0.1"
                        max="0.9"
                        step="0.05"
                        value="0.5"
                        class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-purple"
                      />
                      <span
                        id="binomial-p-value"
                        class="ml-4 text-neon-purple font-bold"
                        >0.5</span
                      >
                    </div>
                  </div>
                </div>
              </div>

              <!-- 指数分布参数 -->
              <div id="exponential-params" class="distribution-params hidden">
                <div>
                  <label
                    for="exponential-lambda"
                    class="block text-gray-300 mb-2 text-sm"
                    >λ 参数:</label
                  >
                  <div class="flex items-center">
                    <input
                      type="range"
                      id="exponential-lambda"
                      min="0.5"
                      max="3"
                      step="0.1"
                      value="1"
                      class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-orange-500"
                    />
                    <span
                      id="exponential-lambda-value"
                      class="ml-4 text-orange-500 font-bold"
                      >1</span
                    >
                  </div>
                </div>
              </div>
            </div>

            <div class="h-72">
              <canvas id="distributions-chart"></canvas>
            </div>
          </div>

          <!-- 相关性分析 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3
              class="text-xl font-future font-semibold mb-6 text-white flex items-center"
            >
              <i class="fa fa-link text-neon-blue mr-3"></i> 变量相关性分析
            </h3>

            <div class="mb-6">
              <label for="correlation-coeff" class="block text-gray-300 mb-2"
                >相关系数:</label
              >
              <div class="flex items-center">
                <input
                  type="range"
                  id="correlation-coeff"
                  min="-1"
                  max="1"
                  step="0.1"
                  value="0.8"
                  class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue"
                />
                <span
                  id="correlation-coeff-value"
                  class="ml-4 text-neon-blue font-bold"
                  >0.8</span
                >
              </div>
            </div>

            <div class="h-72">
              <canvas id="correlation-chart"></canvas>
            </div>

            <div class="mt-4 text-sm text-gray-400">
              <p>
                相关系数r衡量两个变量线性相关的强度和方向，取值范围为[-1,
                1]。r越接近1表示强正相关，越接近-1表示强负相关，接近0表示几乎无相关。
              </p>
            </div>
          </div>

          <!-- PCA降维投影 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3 class="text-xl font-future font-semibold mb-6 text-white flex items-center">
              <i class="fa fa-compass text-neon-blue mr-3"></i> PCA 降维投影
            </h3>

            <div class="grid grid-cols-3 gap-4 mb-6">
              <div>
                <label for="pca-samples" class="block text-gray-300 mb-2">样本数:</label>
                <div class="flex items-center">
                  <input type="range" id="pca-samples" min="200" max="3000" step="100" value="800" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue" />
                  <span id="pca-samples-value" class="ml-4 text-neon-blue font-bold">800</span>
                </div>
              </div>
              <div>
                <label for="pca-angle" class="block text-gray-300 mb-2">旋转角度(°):</label>
                <div class="flex items-center">
                  <input type="range" id="pca-angle" min="0" max="180" step="1" value="30" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue" />
                  <span id="pca-angle-value" class="ml-4 text-neon-blue font-bold">30</span>
                </div>
              </div>
              <div>
                <label for="pca-noise" class="block text-gray-300 mb-2">噪声强度:</label>
                <div class="flex items-center">
                  <input type="range" id="pca-noise" min="0" max="2" step="0.1" value="0.4" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-blue" />
                  <span id="pca-noise-value" class="ml-4 text-neon-blue font-bold">0.4</span>
                </div>
              </div>
            </div>

            <div class="flex justify-start gap-3 mb-4">
              <button id="pca-generate" class="px-4 py-2 bg-neon-blue text-dark-bg font-bold rounded-md hover:bg-neon-blue/80 transition-all duration-300">生成数据</button>
              <label class="inline-flex items-center space-x-2">
                <input type="checkbox" id="pca-show-axes" checked class="accent-neon-blue" />
                <span class="text-gray-300">显示主轴</span>
              </label>
            </div>

            <div class="h-72">
              <canvas id="pca-chart"></canvas>
            </div>
          </div>

          <!-- 相关矩阵热图 -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3 class="text-xl font-future font-semibold mb-6 text-white flex items-center">
              <i class="fa fa-th text-neon-purple mr-3"></i> 相关矩阵热图
            </h3>

            <div class="grid grid-cols-3 gap-4 mb-4">
              <div>
                <label for="heat-dim" class="block text-gray-300 mb-2">维度:</label>
                <div class="flex items-center">
                  <input type="range" id="heat-dim" min="5" max="12" step="1" value="8" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-purple" />
                  <span id="heat-dim-value" class="ml-4 text-neon-purple font-bold">8</span>
                </div>
              </div>
              <div class="flex items-end">
                <button id="heat-generate" class="px-4 py-2 bg-neon-purple text-dark-bg font-bold rounded-md hover:bg-neon-purple/80 transition-all duration-300">随机生成</button>
              </div>
              <div class="flex items-end">
                <button id="heat-cluster" class="px-4 py-2 bg-neon-purple/70 text-white font-bold rounded-md hover:bg-neon-purple/80 transition-all duration-300">聚类排序</button>
              </div>
            </div>

            <div class="relative h-72 border border-gray-800 rounded-md bg-gray-900">
              <canvas id="heatmap-canvas" class="w-full h-full"></canvas>
              <div id="heatmap-tooltip" class="absolute hidden bg-dark-bg/80 text-white text-xs px-2 py-1 rounded border border-gray-700"></div>
            </div>
          </div>

          <!-- 直方图 vs KDE -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3 class="text-xl font-future font-semibold mb-6 text-white flex items-center">
              <i class="fa fa-chart-area text-neon-orange mr-3"></i> 直方图与KDE对比
            </h3>

            <div class="grid grid-cols-3 gap-4 mb-6">
              <div>
                <label class="block text-gray-300 mb-2">分布:</label>
                <div class="grid grid-cols-3 gap-2">
                  <button class="kde-dist-btn active px-3 py-1 bg-neon-orange/20 text-neon-orange rounded-md" data-dist="normal">正态</button>
                  <button class="kde-dist-btn px-3 py-1 bg-gray-800 text-gray-300 rounded-md" data-dist="uniform">均匀</button>
                  <button class="kde-dist-btn px-3 py-1 bg-gray-800 text-gray-300 rounded-md" data-dist="exponential">指数</button>
                </div>
              </div>
              <div>
                <label for="kde-samples" class="block text-gray-300 mb-2">样本数:</label>
                <div class="flex items-center">
                  <input type="range" id="kde-samples" min="500" max="5000" step="100" value="1000" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-orange" />
                  <span id="kde-samples-value" class="ml-4 text-neon-orange font-bold">1000</span>
                </div>
              </div>
              <div>
                <label for="kde-bandwidth" class="block text-gray-300 mb-2">带宽:</label>
                <div class="flex items-center">
                  <input type="range" id="kde-bandwidth" min="0.1" max="1.0" step="0.05" value="0.3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-orange" />
                  <span id="kde-bandwidth-value" class="ml-4 text-neon-orange font-bold">0.3</span>
                </div>
              </div>
            </div>

            <div class="flex justify-start gap-3 mb-4">
              <button id="kde-stream" class="px-4 py-2 bg-neon-orange text-dark-bg font-bold rounded-md hover:bg-neon-orange/80 transition-all duration-300">开始流式采样</button>
              <button id="kde-stop" class="px-4 py-2 bg-gray-700 text-white font-bold rounded-md hover:bg-gray-600 transition-all duration-300">停止</button>
              <button id="kde-reset" class="px-4 py-2 bg-gray-700 text-white font-bold rounded-md hover:bg-gray-600 transition-all duration-300">重置</button>
            </div>

            <div class="h-72">
              <canvas id="kde-chart" class="w-full h-full"></canvas>
            </div>
          </div>

          <!-- 比例树图 Treemap -->
          <div class="bg-dark-card rounded-xl p-6 border border-gray-800">
            <h3 class="text-xl font-future font-semibold mb-6 text-white flex items-center">
              <i class="fa fa-sitemap text-neon-green mr-3"></i> 比例树图 Treemap
            </h3>

            <div class="grid grid-cols-3 gap-4 mb-4">
              <div>
                <label for="treemap-cats" class="block text-gray-300 mb-2">类别数:</label>
                <div class="flex items-center">
                  <input type="range" id="treemap-cats" min="5" max="12" step="1" value="8" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-neon-green" />
                  <span id="treemap-cats-value" class="ml-4 text-neon-green font-bold">8</span>
                </div>
              </div>
              <div class="flex items-end">
                <button id="treemap-randomize" class="px-4 py-2 bg-neon-green text-dark-bg font-bold rounded-md hover:bg-neon-green/80 transition-all duration-300">随机权重</button>
              </div>
              <div>
                <label for="treemap-mode" class="block text-gray-300 mb-2">布局模式:</label>
                <select id="treemap-mode" class="w-full bg-gray-800 text-gray-300 rounded-md p-2 border border-gray-700">
                  <option value="slice">Slice-Dice</option>
                  <option value="slice">Squarify(简化)</option>
                </select>
              </div>
            </div>

            <div class="relative h-72 border border-gray-800 rounded-md bg-gray-900">
              <canvas id="treemap-canvas" class="w-full h-full"></canvas>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 应用场景部分 -->
    <section
      id="applications"
      class="py-20 relative bg-gradient-to-b from-dark-card/50 to-dark-bg"
    >
      <div class="absolute inset-0 bg-grid opacity-10"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div class="text-center mb-16">
          <h2 class="text-[clamp(1.8rem,5vw,3rem)] font-future font-bold mb-4">
            概率统计的<span class="text-neon-blue">应用</span>场景
          </h2>
          <p class="text-gray-400 max-w-2xl mx-auto">
            探索概率与统计在现实世界和科幻场景中的广泛应用
          </p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
          <!-- 应用卡片1 -->
          <div class="group relative overflow-hidden rounded-xl">
            <img
              src="../static/img/weather-forecast.svg"
              alt="天气预报中的概率模型"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div
              class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"
            ></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div
                class="w-12 h-12 rounded-full bg-neon-blue/20 flex items-center justify-center mb-4"
              >
                <i class="fa fa-cloud text-neon-blue text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">
                天气预报
              </h3>
              <p class="text-gray-300 text-sm">
                使用概率模型预测降水概率、温度范围等气象要素，为决策提供科学依据。
              </p>
            </div>
          </div>

          <!-- 应用卡片2 -->
          <div class="group relative overflow-hidden rounded-xl">
            <img
              src="../static/img/machine-learning.svg"
              alt="机器学习中的统计方法"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div
              class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"
            ></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div
                class="w-12 h-12 rounded-full bg-neon-purple/20 flex items-center justify-center mb-4"
              >
                <i class="fa fa-brain text-neon-purple text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">
                机器学习
              </h3>
              <p class="text-gray-300 text-sm">
                统计学习理论是机器学习的基础，贝叶斯方法、最大似然估计等广泛应用于模型训练。
              </p>
            </div>
          </div>

          <!-- 应用卡片3 -->
          <div class="group relative overflow-hidden rounded-xl">
            <img
              src="../static/img/quantum-physics.svg"
              alt="量子力学中的概率解释"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div
              class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"
            ></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div
                class="w-12 h-12 rounded-full bg-neon-green/20 flex items-center justify-center mb-4"
              >
                <i class="fa fa-atom text-neon-green text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">
                量子力学
              </h3>
              <p class="text-gray-300 text-sm">
                量子世界的行为本质上是概率性的，波函数描述了粒子状态的概率分布。
              </p>
            </div>
          </div>

          <!-- 应用卡片4 -->
          <div class="group relative overflow-hidden rounded-xl">
            <img
              src="../static/img/risk-assessment.svg"
              alt="金融风险评估中的概率模型"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div
              class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"
            ></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div
                class="w-12 h-12 rounded-full bg-neon-blue/20 flex items-center justify-center mb-4"
              >
                <i class="fa fa-chart-line text-neon-blue text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">
                风险评估
              </h3>
              <p class="text-gray-300 text-sm">
                金融领域使用VaR（风险价值）等概率模型评估投资组合的潜在损失风险。
              </p>
            </div>
          </div>

          <!-- 应用卡片5 -->
          <div class="group relative overflow-hidden rounded-xl">
            <img
              src="../static/img/cosmology.svg"
              alt="宇宙学中的概率分布"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div
              class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"
            ></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div
                class="w-12 h-12 rounded-full bg-neon-purple/20 flex items-center justify-center mb-4"
              >
                <img
                  src="../static/img/cosmology-icon.svg"
                  alt="宇宙学图标"
                  class="w-6 h-6"
                />
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">
                宇宙学
              </h3>
              <p class="text-gray-300 text-sm">
                概率模型用于描述宇宙结构形成、暗物质分布等宇宙学现象。
              </p>
            </div>
          </div>

          <!-- 应用卡片6 -->
          <div class="group relative overflow-hidden rounded-xl">
            <img
              src="../static/img/medical-diagnosis.svg"
              alt="医疗诊断中的统计方法"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div
              class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"
            ></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div
                class="w-12 h-12 rounded-full bg-neon-green/20 flex items-center justify-center mb-4"
              >
                <i class="fa fa-heartbeat text-neon-green text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">
                医疗诊断
              </h3>
              <p class="text-gray-300 text-sm">
                统计方法用于疾病风险预测、诊断准确性评估和临床试验设计。
              </p>
            </div>
          </div>

          <!-- 新增应用卡片：洪水频率分析与极值分布（概率分布页面） -->
          <a href="probability_distributions.html#practice-applications" class="group relative overflow-hidden rounded-xl block">
            <img
              src="../static/img/cover-flood-extreme.svg"
              alt="洪水频率分析与极值分布"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div class="w-12 h-12 rounded-full bg-neon-blue/20 flex items-center justify-center mb-4">
                <i class="fa fa-tint text-neon-blue text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">洪水频率分析与极值分布</h3>
              <p class="text-gray-300 text-sm">基于极值分布进行洪水风险评估与工程设计。</p>
            </div>
          </a>

          <!-- 新增应用卡片：军事分析（区间估计页面） -->
          <a href="interval_estimation.html#practical-applications" class="group relative overflow-hidden rounded-xl block">
            <img
              src="../static/img/cover-interval-military.svg"
              alt="军事分析：寻找遗失的炮弹"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div class="w-12 h-12 rounded-full bg-neon-orange/20 flex items-center justify-center mb-4">
                <i class="fa fa-crosshairs text-neon-orange text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">军事分析：寻找遗失的炮弹</h3>
              <p class="text-gray-300 text-sm">利用置信区间搜索目标位置，动态调整搜索策略。</p>
            </div>
          </a>

          <!-- 新增应用卡片：游戏策略（区间估计页面） -->
          <a href="interval_estimation.html#practical-applications" class="group relative overflow-hidden rounded-xl block">
            <img
              src="../static/img/cover-interval-game.svg"
              alt="游戏策略：末地之门定位"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div class="w-12 h-12 rounded-full bg-neon-purple/20 flex items-center justify-center mb-4">
                <i class="fa fa-gamepad text-neon-purple text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">游戏策略：末地之门定位</h3>
              <p class="text-gray-300 text-sm">用区间估计定位末地要塞，提高探索效率。</p>
            </div>
          </a>

          <!-- 新增应用卡片：假设检验（假设检验页面） -->
          <a href="hypothesis_testing.html#practical-applications" class="group relative overflow-hidden rounded-xl block">
            <img
              src="../static/img/cover-hypothesis-hero.svg"
              alt="假设检验应用示例"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div class="w-12 h-12 rounded-full bg-neon-green/20 flex items-center justify-center mb-4">
                <i class="fa fa-flask text-neon-green text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">假设检验：英雄平衡与农业评估</h3>
              <p class="text-gray-300 text-sm">将假设检验应用到游戏平衡与作物效果评估。</p>
            </div>
          </a>

          <!-- 新增应用卡片：直播打赏异常检测（大数定律页面） -->
          <a href="law_of_large_numbers.html#practical-applications" class="group relative overflow-hidden rounded-xl block">
            <img
              src="../static/img/cover-lln-streaming.svg"
              alt="直播打赏异常检测"
              class="w-full h-64 object-cover transition-transform duration-500 group-hover:scale-110"
            />
            <div class="absolute inset-0 bg-gradient-to-t from-dark-bg via-dark-bg/70 to-transparent"></div>
            <div class="absolute bottom-0 left-0 p-6">
              <div class="w-12 h-12 rounded-full bg-neon-orange/20 flex items-center justify-center mb-4">
                <i class="fa fa-video text-neon-orange text-xl"></i>
              </div>
              <h3 class="text-xl font-future font-semibold mb-2 text-white">直播打赏异常检测</h3>
              <p class="text-gray-300 text-sm">用大数定律监控打赏数据，识别异常行为。</p>
            </div>
          </a>
        </div>
      </div>
    </section>

    <!-- 订阅区域 -->
    <section class="py-16 relative">
      <div class="absolute inset-0 bg-grid opacity-20"></div>
      <div class="container mx-auto px-4 relative z-10">
        <div
          class="max-w-4xl mx-auto bg-gradient-to-r from-dark-card to-dark-bg p-8 md:p-12 rounded-2xl border border-gray-800 border-glow"
        >
          <div class="text-center mb-8">
            <h2
              class="text-[clamp(1.5rem,4vw,2.5rem)] font-future font-bold mb-4 text-white"
            >
              探索更多概率<span class="text-neon-blue">维度</span>
            </h2>
            <p class="text-gray-400">
              订阅我们的通讯，获取最新的概率统计知识和工具更新
            </p>
          </div>

          <form
            id="email-form"
            class="flex flex-col sm:flex-row gap-4 max-w-xl mx-auto"
            novalidate
          >
            <input
              id="email"
              type="email"
              required
              placeholder="输入您的邮箱地址"
              aria-invalid="false"
              class="flex-1 px-4 py-3 bg-dark-bg border border-gray-700 rounded-md focus:outline-none focus:border-neon-blue text-white transition-colors"
            />
            <button
              id="subscribe-btn"
              type="submit"
              class="px-6 py-3 bg-neon-blue text-dark-bg font-bold rounded-md hover:bg-white transition-all duration-300 whitespace-nowrap flex items-center gap-2"
            >
              <span>立即订阅</span>
              <i class="fa fa-paper-plane"></i>
              <i id="loading-icon" class="fa fa-spinner fa-spin hidden"></i>
            </button>
            <div
              id="form-feedback"
              role="alert"
              aria-live="polite"
              class="hidden sm:col-span-2 mt-2 text-sm rounded-md border p-3 bg-dark-bg border-gray-700 text-gray-300"
            ></div>
            <script>
              (function () {
                const form = document.getElementById("email-form");
                const emailInput = document.getElementById("email");
                const feedback = document.getElementById("form-feedback");
                const btn = document.getElementById("subscribe-btn");
                const loadingIcon = document.getElementById("loading-icon");

                const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/i;

                function setLoading(loading) {
                  btn.disabled = loading;
                  loadingIcon.classList.toggle("hidden", !loading);
                  btn.classList.toggle("opacity-60", loading);
                  btn.classList.toggle("cursor-not-allowed", loading);
                }

                function setInputValid(isValid) {
                  emailInput.setAttribute("aria-invalid", String(!isValid));
                  emailInput.classList.toggle("border-neon-orange", !isValid);
                  emailInput.classList.toggle("border-gray-700", isValid);
                }

                function showFeedback(type, text) {
                  // type: 'info' | 'error' | 'success'
                  const base =
                    "mt-2 text-sm rounded-md border p-3 bg-dark-bg transition-all duration-300 flex items-center gap-2";
                  let color = "border-gray-700 text-gray-300";
                  let icon = "fa-info-circle text-gray-300";
                  if (type === "error") {
                    color = "border-neon-orange text-neon-orange";
                    icon = "fa-circle-exclamation";
                  } else if (type === "success") {
                    color = "border-neon-green text-neon-green";
                    icon = "fa-circle-check";
                  } else if (type === "info") {
                    color = "border-neon-blue text-neon-blue";
                    icon = "fa-info-circle";
                  }
                  feedback.className = base + " " + color;
                  feedback.innerHTML = `<i class="fa ${icon}"></i><span>${text}</span>`;
                  feedback.classList.remove("hidden");
                }

                function validateEmailValue(value) {
                  const v = value.trim();
                  if (!v) return { valid: false, reason: "empty" };
                  if (!EMAIL_REGEX.test(v))
                    return { valid: false, reason: "format" };
                  return { valid: true };
                }

                emailInput.addEventListener("input", () => {
                  const { valid, reason } = validateEmailValue(
                    emailInput.value
                  );
                  if (!valid) {
                    setInputValid(false);
                    showFeedback(
                      "error",
                      reason === "empty"
                        ? "邮箱地址不能为空"
                        : "请输入有效的邮箱地址"
                    );
                  } else {
                    setInputValid(true);
                    showFeedback("info", "邮箱格式看起来不错，现在可以订阅");
                  }
                });

                form.addEventListener("submit", async (e) => {
                  e.preventDefault();
                  const email = emailInput.value.trim();
                  const { valid, reason } = validateEmailValue(email);
                  if (!valid) {
                    setInputValid(false);
                    showFeedback(
                      "error",
                      reason === "empty"
                        ? "邮箱地址不能为空"
                        : "请输入有效的邮箱地址"
                    );
                    return;
                  }

                  try {
                    setLoading(true);
                    showFeedback("info", "正在检查订阅状态...");

                    // 重复订阅检查
                    const checkResp = await fetch("submit_email.php", {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                      },
                      body: `email_check=${encodeURIComponent(email)}`,
                    });
                    const checkText = await checkResp.text();

                    if (checkText.trim() === "duplicate") {
                      setInputValid(false);
                      showFeedback("error", "该邮箱已订阅");
                      setLoading(false);
                      return;
                    }

                    // 提交订阅
                    showFeedback("info", "正在提交订阅...");
                    const subResp = await fetch("submit_email.php", {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/x-www-form-urlencoded",
                      },
                      body: `email=${encodeURIComponent(email)}`,
                    });
                    const subText = await subResp.text();

                    if (subResp.ok) {
                      setInputValid(true);
                      showFeedback(
                        "success",
                        (subText || "订阅成功").replace(/\s+/g, "")
                      );
                      emailInput.value = "";
                    } else {
                      showFeedback("error", "提交失败，请稍后重试");
                    }
                  } catch (err) {
                    showFeedback("error", "网络异常，请稍后重试");
                    console.error(err);
                  } finally {
                    setLoading(false);
                  }
                });
              })();
            </script>
          </form>
        </div>
      </div>
    </section>

    <!-- 页脚 -->
    <footer class="bg-dark-card py-12 border-t border-gray-800">
      <div class="container mx-auto px-4">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-8 mb-8">
          <div>
            <div class="flex items-center space-x-2 mb-6">
              <div
                class="w-10 h-10 rounded-full bg-gradient-to-r from-neon-blue to-neon-purple flex items-center justify-center"
              >
                <i class="fa fa-calculator text-white text-xl"></i>
              </div>
              <h2 class="text-xl font-future font-bold text-white">
                <span class="text-neon-blue">概率</span
                ><span class="text-white">维度</span>
              </h2>
            </div>
            <p class="text-gray-400 mb-6">
              探索概率与数理统计的奇妙世界，揭示数据背后的规律。
            </p>
            <div class="flex space-x-4">
              <a
                href="https://www.douyin.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-red-500 hover:to-pink-500 hover:text-white transition-all duration-300 transform hover:scale-110 hover:rotate-12"
                title="抖音 - 记录美好生活"
              >
                <img
                  src="../static/img/tiktok.svg"
                  alt="抖音"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
              <a
                href="https://www.bilibili.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-pink-400 hover:to-pink-600 hover:text-white transition-all duration-300 transform hover:scale-110 hover:-rotate-12"
                title="哔哩哔哩 - 你感兴趣的视频都在B站"
              >
                <img
                  src="../static/img/bilibili.svg"
                  alt="哔哩哔哩"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
              <a
                href="https://weixin.qq.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-green-400 hover:to-green-600 hover:text-white transition-all duration-300 transform hover:scale-110 hover:rotate-12"
                title="微信 - 是一个生活方式"
              >
                <img
                  src="../static/img/wechat.svg"
                  alt="微信"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
              <a
                href="https://weibo.com/"
                target="_blank"
                rel="noopener noreferrer"
                class="social-icon w-10 h-10 rounded-full bg-gray-800 flex items-center justify-center text-gray-400 hover:bg-gradient-to-r hover:from-orange-400 hover:to-red-500 hover:text-white transition-all duration-300 transform hover:scale-110 hover:-rotate-12"
                title="微博 - 随时随地发现新鲜事"
              >
                <img
                  src="../static/img/weibo.svg"
                  alt="微博"
                  class="w-5 h-5 transition-transform duration-300"
                />
              </a>
            </div>
          </div>

          <div>
            <h3 class="text-white font-future font-semibold mb-6">快速链接</h3>
            <ul class="space-y-3">
              <li>
                <a
                  href="#concepts"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >核心概念</a
                >
              </li>
              <li>
                <a
                  href="#simulations"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >概率模拟</a
                >
              </li>
              <li>
                <a
                  href="#visualizations"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >数据可视化</a
                >
              </li>
              <li>
                <a
                  href="#applications"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >应用场景</a
                >
              </li>
            </ul>
          </div>

          <div>
            <h3 class="text-white font-future font-semibold mb-6">学习资源</h3>
            <ul class="space-y-3">
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >教程与指南</a
                >
              </li>
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >在线课程</a
                >
              </li>
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >书籍推荐</a
                >
              </li>
              <li>
                <a
                  href="#"
                  class="text-gray-400 hover:text-neon-blue transition-colors"
                  >研究论文</a
                >
              </li>
            </ul>
          </div>

          <div>
            <h3 class="text-white font-future font-semibold mb-6">联系我们</h3>
            <ul class="space-y-3">
              <li class="flex items-start">
                <i class="fa fa-envelope text-neon-blue mt-1 mr-3"></i>
                <span class="text-gray-400">WangHouxiong9558@outlook.com</span>
              </li>
              <li class="flex items-start">
                <i class="fa fa-map-marker text-neon-blue mt-1 mr-3"></i>
                <span class="text-gray-400"
                  >江西省南昌市高新技术开发区天祥大道289号</span
                >
              </li>
              <li class="flex items-start">
                <i class="fa fa-phone text-neon-blue mt-1 mr-3"></i>
                <span class="text-gray-400">+86 173 5709 8869</span>
              </li>
            </ul>
          </div>
        </div>

        <div
          class="pt-8 border-t border-gray-800 flex flex-col md:flex-row justify-between items-center"
        >
          <p class="text-gray-500 text-sm mb-4 md:mb-0">
            © 2025 概率维度. 保留所有权利.
          </p>
          <div class="flex space-x-6">
            <a href="#" class="text-gray-500 hover:text-gray-300 text-sm"
              >隐私政策</a
            >
            <a href="#" class="text-gray-500 hover:text-gray-300 text-sm"
              >服务条款</a
            >
            <a href="#" class="text-gray-500 hover:text-gray-300 text-sm"
              >Cookie政策</a
            >
          </div>
        </div>

        <!-- 备案信息 -->
        <div class="pt-4 text-center">
          <p class="text-gray-500 text-sm">
            <a
              href="http://beian.miit.gov.cn/"
              target="_blank"
              rel="noopener noreferrer"
              class="text-gray-500 hover:text-gray-300 transition-colors underline cursor-pointer inline-block py-1 px-2"
              style="z-index: 999; position: relative"
            >
              赣ICP备2025074925号
            </a>
          </p>
          <p class="text-gray-600 text-xs mt-1">审核通过日期：2025-10-27</p>
        </div>
      </div>
    </footer>

    <!-- JavaScript -->
    <script>
      // 导航栏滚动效果
      const nav = document.getElementById("main-nav");
      window.addEventListener("scroll", () => {
        if (window.scrollY > 50) {
          nav.classList.add("py-2", "shadow-lg", "shadow-neon-blue/10");
          nav.classList.remove("py-3");
        } else {
          nav.classList.add("py-3");
          nav.classList.remove("py-2", "shadow-lg", "shadow-neon-blue/10");
        }
      });

      // 移动端菜单切换
      const menuToggle = document.getElementById("menu-toggle");
      const mobileMenu = document.getElementById("mobile-menu");

      menuToggle.addEventListener("click", () => {
        mobileMenu.classList.toggle("hidden");
        const icon = menuToggle.querySelector("i");
        if (icon.classList.contains("fa-bars")) {
          icon.classList.replace("fa-bars", "fa-times");
        } else {
          icon.classList.replace("fa-times", "fa-bars");
        }
      });

      // 平滑滚动
      document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
        anchor.addEventListener("click", function (e) {
          e.preventDefault();

          // 关闭移动菜单（如果打开）
          if (!mobileMenu.classList.contains("hidden")) {
            mobileMenu.classList.add("hidden");
            const icon = menuToggle.querySelector("i");
            icon.classList.replace("fa-times", "fa-bars");
          }

          const href = this.getAttribute("href");
          if (href && href !== "#") {
            const target = document.querySelector(href);
            if (target) {
              target.scrollIntoView({
                behavior: "smooth",
              });
            }
          }
        });
      });

      // 创建粒子背景
      function createParticles() {
        const container = document.getElementById("particles-container");
        const particleCount = 50;

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");

          // 随机大小和位置
          const size = Math.random() * 3 + 1;
          const posX = Math.random() * 100;
          const posY = Math.random() * 100;
          const delay = Math.random() * 5;
          const duration = Math.random() * 20 + 10;

          // 随机颜色
          const colors = ["bg-neon-blue", "bg-neon-purple", "bg-neon-green"];
          const color = colors[Math.floor(Math.random() * colors.length)];

          // 设置样式
          particle.classList.add(
            "absolute",
            "rounded-full",
            color,
            "opacity-50"
          );
          particle.style.width = `${size}px`;
          particle.style.height = `${size}px`;
          particle.style.left = `${posX}%`;
          particle.style.top = `${posY}%`;
          particle.style.animation = `float ${duration}s ease-in-out ${delay}s infinite`;

          container.appendChild(particle);
        }
      }

      // 添加浮动动画
      const style = document.createElement("style");
      style.textContent = `
            @keyframes float {
                0% { transform: translateY(0) translateX(0); }
                50% { transform: translateY(-20px) translateX(10px); }
                100% { transform: translateY(0) translateX(0); }
            }
        `;
      document.head.appendChild(style);

      // 掷骰子模拟
      let diceChart;
      function initDiceChart() {
        const ctx = document.getElementById("dice-chart").getContext("2d");
        diceChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["1", "2", "3", "4", "5", "6"],
            datasets: [
              {
                label: "出现次数",
                data: [0, 0, 0, 0, 0, 0],
                backgroundColor: "rgba(191, 0, 255, 0.7)",
                borderColor: "rgba(191, 0, 255, 1)",
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
              x: {
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
          },
        });
      }

      function rollDice(trials) {
        // 守护：Chart或图表未初始化时直接返回，避免阻塞其他交互逻辑
        if (
          typeof window.Chart === "undefined" ||
          typeof window.diceChart === "undefined" ||
          !window.diceChart ||
          !window.diceChart.data ||
          typeof window.diceChart.update !== "function"
        ) {
          console.warn("Chart.js 未加载或骰子图未初始化，跳过 rollDice()");
          return;
        }
        const results = [0, 0, 0, 0, 0, 0];
        for (let i = 0; i < trials; i++) {
          const roll = Math.floor(Math.random() * 6);
          results[roll]++;
        }
        window.diceChart.data.datasets[0].data = results;
        window.diceChart.update();
      }

      // 正态分布模拟
      let normalChart;
      function initNormalChart(mean = 0, std = 1) {
        const ctx = document.getElementById("normal-chart").getContext("2d");

        // 生成正态分布数据
        const generateNormalData = (mean, std, count = 10000) => {
          const data = [];
          for (let i = 0; i < count; i++) {
            // 使用Box-Muller变换生成正态分布随机数
            let u1 = 1 - Math.random();
            let u2 = Math.random();
            let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            data.push(z0 * std + mean);
          }
          return data;
        };

        const data = generateNormalData(mean, std);
        const bins = 50;
        const min = Math.min(...data);
        const max = Math.max(...data);
        const binWidth = (max - min) / bins;
        const frequencies = new Array(bins).fill(0);

        data.forEach((value) => {
          const binIndex = Math.min(
            Math.floor((value - min) / binWidth),
            bins - 1
          );
          frequencies[binIndex]++;
        });

        const labels = Array.from({ length: bins }, (_, i) =>
          (min + i * binWidth).toFixed(1)
        );

        if (normalChart) {
          normalChart.destroy();
        }

        normalChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: [
              {
                label: "正态分布",
                data: frequencies,
                backgroundColor: "rgba(0, 243, 255, 0.2)",
                borderColor: "rgba(0, 243, 255, 1)",
                borderWidth: 2,
                fill: true,
                tension: 0.4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
              x: {
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                  maxTicksLimit: 10,
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
          },
        });
      }

      // 蒙特卡洛模拟计算π
      let monteCarloChart;
      function initMonteCarloChart() {
        const ctx = document
          .getElementById("monte-carlo-chart")
          .getContext("2d");

        if (monteCarloChart) {
          monteCarloChart.destroy();
        }

        monteCarloChart = new Chart(ctx, {
          type: "scatter",
          data: {
            datasets: [
              {
                label: "圆内点",
                data: [],
                backgroundColor: "rgba(0, 255, 102, 0.6)",
                pointRadius: 3,
              },
              {
                label: "圆外点",
                data: [],
                backgroundColor: "rgba(255, 255, 255, 0.3)",
                pointRadius: 3,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                min: 0,
                max: 1,
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
              x: {
                min: 0,
                max: 1,
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
              annotation: {
                annotations: {
                  circle: {
                    type: "circle",
                    xMin: 0,
                    xMax: 1,
                    yMin: 0,
                    yMax: 1,
                    backgroundColor: "rgba(0, 255, 102, 0.1)",
                    borderColor: "rgba(0, 255, 102, 0.5)",
                    borderWidth: 2,
                  },
                },
              },
            },
          },
        });
      }

      function calculatePi(samples) {
        const insidePoints = [];
        const outsidePoints = [];
        let insideCount = 0;

        for (let i = 0; i < samples; i++) {
          const x = Math.random();
          const y = Math.random();
          const distance = x * x + y * y;

          if (distance <= 1) {
            insidePoints.push({ x, y });
            insideCount++;
          } else {
            outsidePoints.push({ x, y });
          }
        }

        // 计算π的估计值
        const piEstimate = (insideCount / samples) * 4;
        const piExact = Math.PI;
        const error = Math.abs((piEstimate - piExact) / piExact) * 100;

        // 更新图表（守护：Chart缺失或未初始化则跳过图表更新）
        if (
          typeof window.monteCarloChart !== "undefined" &&
          window.monteCarloChart &&
          window.monteCarloChart.data &&
          typeof window.monteCarloChart.update === "function"
        ) {
          window.monteCarloChart.data.datasets[0].data = insidePoints;
          window.monteCarloChart.data.datasets[1].data = outsidePoints;
          window.monteCarloChart.update();
        } else {
          console.warn("Chart.js 未加载或蒙特卡洛图未初始化，跳过图表更新");
        }

        // 更新显示
        const estEl = document.getElementById("pi-estimate");
        const errEl = document.getElementById("pi-error");
        if (estEl) estEl.textContent = piEstimate.toFixed(6);
        if (errEl) errEl.textContent = error.toFixed(4) + "%";
      }

      // 分布比较图表
      let distributionsChart;
      let currentDistribution = "normal";

      function initDistributionsChart() {
        const ctx = document
          .getElementById("distributions-chart")
          .getContext("2d");

        const normalData = generateDistributionData("normal");

        distributionsChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: normalData.labels,
            datasets: [
              {
                label: "概率密度",
                data: normalData.data,
                backgroundColor: "rgba(0, 255, 102, 0.2)",
                borderColor: "rgba(0, 255, 102, 1)",
                borderWidth: 2,
                fill: true,
                tension: 0.4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
              x: {
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
          },
        });

        // 初始化参数滑块事件监听
        initDistributionParamEvents();
      }

      function updateDistributionChart(type) {
        currentDistribution = type;

        // 隐藏所有参数控制区域
        document.querySelectorAll(".distribution-params").forEach((el) => {
          el.classList.add("hidden");
        });

        // 显示当前分布的参数控制区域
        const paramsEl = document.getElementById(`${type}-params`);
        if (paramsEl) {
          paramsEl.classList.remove("hidden");
        }

        const data = generateDistributionData(type);
        distributionsChart.data.labels = data.labels;
        distributionsChart.data.datasets[0].data = data.data;

        // 更新标题和颜色
        switch (type) {
          case "normal":
            distributionsChart.data.datasets[0].borderColor =
              "rgba(0, 255, 102, 1)";
            distributionsChart.data.datasets[0].backgroundColor =
              "rgba(0, 255, 102, 0.2)";
            break;
          case "poisson":
            distributionsChart.data.datasets[0].borderColor =
              "rgba(0, 243, 255, 1)";
            distributionsChart.data.datasets[0].backgroundColor =
              "rgba(0, 243, 255, 0.2)";
            break;
          case "binomial":
            distributionsChart.data.datasets[0].borderColor =
              "rgba(191, 0, 255, 1)";
            distributionsChart.data.datasets[0].backgroundColor =
              "rgba(191, 0, 255, 0.2)";
            break;
          case "exponential":
            distributionsChart.data.datasets[0].borderColor =
              "rgba(255, 102, 0, 1)";
            distributionsChart.data.datasets[0].backgroundColor =
              "rgba(255, 102, 0, 0.2)";
            break;
        }

        distributionsChart.update();
      }

      // 初始化分布参数滑块事件
      function initDistributionParamEvents() {
        // 正态分布参数
        const normalMean = document.getElementById("normal-mean");
        const normalStd = document.getElementById("normal-std");
        const normalMeanValue = document.getElementById("normal-mean-value");
        const normalStdValue = document.getElementById("normal-std-value");

        if (normalMean && normalStd) {
          normalMean.addEventListener("input", function () {
            normalMeanValue.textContent = this.value;
            if (currentDistribution === "normal") {
              updateChart();
            }
          });

          normalStd.addEventListener("input", function () {
            normalStdValue.textContent = this.value;
            if (currentDistribution === "normal") {
              updateChart();
            }
          });
        }

        // 泊松分布参数
        const poissonLambda = document.getElementById("poisson-lambda");
        const poissonLambdaValue = document.getElementById(
          "poisson-lambda-value"
        );

        if (poissonLambda) {
          poissonLambda.addEventListener("input", function () {
            poissonLambdaValue.textContent = this.value;
            if (currentDistribution === "poisson") {
              updateChart();
            }
          });
        }

        // 二项分布参数
        const binomialN = document.getElementById("binomial-n");
        const binomialP = document.getElementById("binomial-p");
        const binomialNValue = document.getElementById("binomial-n-value");
        const binomialPValue = document.getElementById("binomial-p-value");

        if (binomialN && binomialP) {
          binomialN.addEventListener("input", function () {
            binomialNValue.textContent = this.value;
            if (currentDistribution === "binomial") {
              updateChart();
            }
          });

          binomialP.addEventListener("input", function () {
            binomialPValue.textContent = this.value;
            if (currentDistribution === "binomial") {
              updateChart();
            }
          });
        }

        // 指数分布参数
        const exponentialLambda = document.getElementById("exponential-lambda");
        const exponentialLambdaValue = document.getElementById(
          "exponential-lambda-value"
        );

        if (exponentialLambda) {
          exponentialLambda.addEventListener("input", function () {
            exponentialLambdaValue.textContent = this.value;
            if (currentDistribution === "exponential") {
              updateChart();
            }
          });
        }
      }

      // 更新图表
      function updateChart() {
        const data = generateDistributionData(currentDistribution);
        distributionsChart.data.datasets[0].data = data.data;
        distributionsChart.update();
      }

      // 辅助函数，在全局作用域中定义以便updateDistributionChart使用
      function generateDistributionData(type) {
        const labels = Array.from({ length: 100 }, (_, i) => i / 10 - 5); // 从-5到5

        let data;
        switch (type) {
          case "normal":
            // 正态分布 - 使用用户设置的参数
            var mean;
            mean = parseFloat(
              document.getElementById("normal-mean")?.value || 0
            );
            var std;
            std = parseFloat(document.getElementById("normal-std")?.value || 1);

            data = labels.map((x) => {
              const z = (x - mean) / std;
              return Math.exp(-0.5 * z * z) / (std * Math.sqrt(2 * Math.PI));
            });
            break;

          case "poisson":
            // 泊松分布 - 使用用户设置的λ
            var lambda;
            lambda = parseFloat(
              document.getElementById("poisson-lambda")?.value || 3
            );
            data = labels.map((x) => {
              if (x < 0 || x !== Math.floor(x)) return 0;
              let factorial = 1;
              for (let i = 1; i <= x; i++) factorial *= i;
              return (Math.exp(-lambda) * Math.pow(lambda, x)) / factorial;
            });
            break;

          case "binomial":
            // 二项分布 - 使用用户设置的n和p
            var n;
            n = parseInt(document.getElementById("binomial-n")?.value || 10);
            var p;
            p = parseFloat(document.getElementById("binomial-p")?.value || 0.5);

            data = labels.map((k) => {
              if (k < 0 || k > n || k !== Math.floor(k)) return 0;
              // 计算组合数 C(n,k)
              let comb = 1;
              for (let i = 1; i <= k; i++) {
                comb = (comb * (n - k + i)) / i;
              }
              return comb * Math.pow(p, k) * Math.pow(1 - p, n - k);
            });
            break;

          case "exponential":
            // 指数分布 - 使用用户设置的λ
            var lambdaExp;
            lambdaExp = parseFloat(
              document.getElementById("exponential-lambda")?.value || 1
            );
            data = labels.map((x) =>
              x >= 0 ? lambdaExp * Math.exp(-lambdaExp * x) : 0
            );
            break;
        }

        return { labels, data };
      }

      // 相关性分析图表
      let correlationChart;
      function initCorrelationChart(r = 0.8) {
        const ctx = document
          .getElementById("correlation-chart")
          .getContext("2d");

        // 生成具有指定相关系数的随机数据
        const generateCorrelatedData = (r, n = 200) => {
          var x = Array.from({ length: n }, () => Math.random() * 100);
          var y = [];

          // 使用相关系数生成y值
          for (let i = 0; i < n; i++) {
            const z = Math.random() * 100;
            // 根据相关系数调整y值
            y.push(r * x[i] + Math.sqrt(1 - r * r) * z);
          }

          // 标准化数据
          const xMean = x.reduce((a, b) => a + b, 0) / n;
          const yMean = y.reduce((a, b) => a + b, 0) / n;
          const xStd = Math.sqrt(
            x.reduce((a, b) => a + Math.pow(b - xMean, 2), 0) / n
          );
          const yStd = Math.sqrt(
            y.reduce((a, b) => a + Math.pow(b - yMean, 2), 0) / n
          );

          const normalizedData = x.map((xi, i) => ({
            x: ((xi - xMean) / xStd) * 10 + 50, // 标准化到均值50，标准差10
            y: ((y[i] - yMean) / yStd) * 10 + 50,
          }));

          return normalizedData;
        };

        const data = generateCorrelatedData(r);

        if (correlationChart) {
          correlationChart.destroy();
        }

        correlationChart = new Chart(ctx, {
          type: "scatter",
          data: {
            datasets: [
              {
                label: "数据点",
                data: data,
                backgroundColor: "rgba(0, 243, 255, 0.6)",
                pointRadius: 4,
                pointHoverRadius: 6,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                min: 20,
                max: 80,
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
              x: {
                min: 20,
                max: 80,
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
            plugins: {
              legend: {
                labels: {
                  color: "rgba(255, 255, 255, 0.7)",
                },
              },
            },
          },
        });
      }

      // 高尔顿板（豆子机）
      let galtonChart;
      function simulateBinomialCounts(rows, balls) {
        const bins = new Array(rows + 1).fill(0);
        for (let i = 0; i < balls; i++) {
          let rights = 0;
          for (let r = 0; r < rows; r++) {
            if (Math.random() < 0.5) rights++;
          }
          bins[rights]++;
        }
        return bins;
      }

      function computeNormalApproxExpected(rows, balls) {
        const mu = rows / 2;
        const sigma = Math.sqrt(rows) / 2; // p=0.5 -> Var = rows/4
        const bins = new Array(rows + 1).fill(0);
        const sqrt2pi = Math.sqrt(2 * Math.PI);
        for (let k = 0; k <= rows; k++) {
          const z = (k - mu) / sigma;
          const pdf = Math.exp(-0.5 * z * z) / (sigma * sqrt2pi);
          bins[k] = balls * pdf; // 近似每个整数点的质量（宽度≈1）
        }
        return bins;
      }

      function initGaltonChart(rows = 10, balls = 1000, showTheory = true) {
        const ctx = document.getElementById("galton-chart")?.getContext("2d");
        if (!ctx) return;

        const counts = simulateBinomialCounts(rows, balls);
        const labels = Array.from({ length: rows + 1 }, (_, i) => `${i}`);

        if (galtonChart) galtonChart.destroy();
        const datasets = [
          {
            label: "落入桶的数量",
            data: counts,
            backgroundColor: "rgba(0, 243, 255, 0.2)",
            borderColor: "rgba(0, 243, 255, 1)",
            borderWidth: 1,
            type: "bar",
          },
        ];

        if (showTheory) {
          const theory = computeNormalApproxExpected(rows, balls);
          datasets.push({
            label: "理论近似（正态）",
            data: theory,
            borderColor: "rgba(0, 255, 102, 1)",
            backgroundColor: "rgba(0, 255, 102, 0.0)",
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.3,
            type: "line",
          });
        }

        galtonChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels,
            datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                ticks: { color: "rgba(255, 255, 255, 0.7)" },
              },
              x: {
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                ticks: { color: "rgba(255, 255, 255, 0.7)" },
              },
            },
            plugins: {
              legend: { labels: { color: "rgba(255, 255, 255, 0.7)" } },
            },
          },
        });
      }

      // Galton动画
      let galtonAnimRunning = false;
      function drawGaltonBoard(rows) {
        const canvas = document.getElementById("galton-anim");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        const width = canvas.clientWidth || 600;
        const height = canvas.clientHeight || 192;
        canvas.width = width;
        canvas.height = height;

        ctx.clearRect(0, 0, width, height);
        // 背景
        ctx.fillStyle = "rgba(255,255,255,0.03)";
        ctx.fillRect(0, 0, width, height);

        const marginX = 20;
        const top = 20;
        const bottom = height - 20;
        const rowSpacing = (bottom - top) / (rows + 1);
        // 统一的水平间距，使底层占满可用宽度，并保持每一行居中
        const sX = (width - 2 * marginX) / rows; // 底层有 rows 个间距

        // 画钉子（居中三角阵）
        ctx.fillStyle = "rgba(0, 243, 255, 0.6)";
        for (let r = 0; r < rows; r++) {
          const n = r + 1; // 该行钉子数
          const rowSpan = (n - 1) * sX; // 该行横向跨度
          const left = (width - rowSpan) / 2; // 该行居中起点
          const y = top + r * rowSpacing;
          for (let c = 0; c <= r; c++) {
            const x = left + c * sX;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      function startGaltonAnimation(
        rows,
        balls,
        speed = 1.0,
        showTheory = true
      ) {
        // 初始化图表为零，并绘制板
        const zeroCounts = new Array(rows + 1).fill(0);
        const ctxChart = document
          .getElementById("galton-chart")
          ?.getContext("2d");
        if (!ctxChart) return;
        if (galtonChart) galtonChart.destroy();
        const labels = Array.from({ length: rows + 1 }, (_, i) => `${i}`);
        const datasets = [
          {
            label: "落入桶的数量",
            data: zeroCounts.slice(),
            backgroundColor: "rgba(0, 243, 255, 0.2)",
            borderColor: "rgba(0, 243, 255, 1)",
            borderWidth: 1,
            type: "bar",
          },
        ];
        if (showTheory) {
          const theory = computeNormalApproxExpected(rows, balls);
          datasets.push({
            label: "理论近似（正态）",
            data: theory,
            borderColor: "rgba(0, 255, 102, 1)",
            backgroundColor: "rgba(0, 255, 102, 0.0)",
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.3,
            type: "line",
          });
        }
        galtonChart = new Chart(ctxChart, {
          type: "bar",
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                ticks: { color: "rgba(255, 255, 255, 0.7)" },
              },
              x: {
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                ticks: { color: "rgba(255, 255, 255, 0.7)" },
              },
            },
            plugins: {
              legend: { labels: { color: "rgba(255, 255, 255, 0.7)" } },
            },
          },
        });

        drawGaltonBoard(rows);
        galtonAnimRunning = true;
        const canvas = document.getElementById("galton-anim");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        const marginX = 20;
        const top = 20;
        const bottom = height - 20;
        const rowSpacing = (bottom - top) / (rows + 1);
        const sX = (width - 2 * marginX) / rows;

        const stepDelay = Math.max(30, Math.floor(200 / speed));
        let processed = 0;

        function dropNext() {
          if (!galtonAnimRunning) return;
          if (processed >= balls) return;

          // 随机生成路径
          let x = width / 2; // 顶部只有一个钉子，正中开始
          let y = top - 5;
          const path = [];
          let rights = 0;
          for (let r = 0; r < rows; r++) {
            const goRight = Math.random() < 0.5;
            rights += goRight ? 1 : 0;
            x += (goRight ? 1 : -1) * (sX / 2);
            y += rowSpacing;
            path.push({ x, y });
          }
          const binIndex = rights;

          // 动画：逐步绘制小球
          let i = 0;
          function step() {
            if (!galtonAnimRunning) return;
            if (i >= path.length) {
              // 到达底部：更新计数与图表
              zeroCounts[binIndex]++;
              if (
                galtonChart &&
                galtonChart.data &&
                galtonChart.data.datasets[0]
              ) {
                galtonChart.data.datasets[0].data = zeroCounts;
                galtonChart.update();
              }
              processed++;
              setTimeout(dropNext, Math.max(10, stepDelay / 2));
              return;
            }
            // 重绘背景与当前球
            drawGaltonBoard(rows);
            ctx.beginPath();
            ctx.fillStyle = "rgba(191, 0, 255, 0.95)";
            ctx.arc(path[i].x, path[i].y, 5, 0, Math.PI * 2);
            ctx.fill();
            i++;
            setTimeout(step, stepDelay);
          }
          step();
        }

        dropNext();
      }

      // 蒲丰投针公式渲染
      function renderBuffonFormulas() {
        const pEl = document.getElementById("buffon-formula-p");
        const piEl = document.getElementById("buffon-formula-pi");
        const specialEl = document.getElementById("buffon-formula-special");
        if (!pEl || !piEl || !specialEl) return;

        const latexP =
          "\\displaystyle p = \\frac{2L}{\\pi d} \\quad (L \\le d)";
        const latexPi = "\\displaystyle \\hat{\\pi} = \\frac{2 L N}{d X}";
        const latexSpecial =
          "\\text{本示例取 } L=d \\Rightarrow \\hat{\\pi} = \\frac{2N}{X}";

        if (window.katex && window.katex.render) {
          try {
            katex.render(latexP, pEl, { throwOnError: false });
            katex.render(latexPi, piEl, { throwOnError: false });
            katex.render(latexSpecial, specialEl, { throwOnError: false });
          } catch (e) {
            pEl.textContent = "p = 2L/(π d) (L ≤ d)";
            piEl.textContent = "π̂ = 2 L N / (d X)";
            specialEl.textContent = "本示例取 L = d ⇒ π̂ = 2N / X";
          }
        } else {
          pEl.textContent = "p = 2L/(π d) (L ≤ d)";
          piEl.textContent = "π̂ = 2 L N / (d X)";
          specialEl.textContent = "本示例取 L = d ⇒ π̂ = 2N / X";
        }
      }

      // 蒲丰投针（估算π）
      function buffonSimulate(trials = 1000) {
        const canvas = document.getElementById("buffon-canvas");
        if (!canvas) return;
        const ctx = setCanvasSize(canvas);
        const container = canvas.parentElement || canvas;
        const rect = container.getBoundingClientRect();
        const width = Math.floor(rect.width || canvas.clientWidth || 400);
        const height = Math.floor(rect.height || canvas.clientHeight || 200);

        // 几何参数：针长L与线距D。设L=D，概率P=2/π。
        const spacing = 20; // 像素间距
        const L = spacing; // 针长度 = 线距
        const D = spacing;

        // 背景与横线
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = "rgba(255,255,255,0.03)";
        ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = "rgba(255, 140, 0, 0.6)";
        ctx.lineWidth = 1;
        for (let y = 0; y < height; y += spacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }

        let hits = 0;
        // 为性能考虑，最多绘制200根针，其余仅统计不绘制
        const drawCount = Math.min(trials, 200);
        for (let i = 0; i < trials; i++) {
          // 在画布内随机放置针中心与角度（角度0..π）
          const cx = Math.random() * width;
          const cy = Math.random() * height;
          const theta = Math.random() * Math.PI;

          // 最近的线到中心的距离
          const distToNearestLine = Math.min(cy % D, D - (cy % D));

          // 交叉条件：y0 <= (L/2) * sin(theta)
          if (distToNearestLine <= (L / 2) * Math.sin(theta)) hits++;

          if (i < drawCount) {
            const dx = (L / 2) * Math.cos(theta);
            const dy = (L / 2) * Math.sin(theta);
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
            ctx.lineWidth = 2;
            ctx.moveTo(cx - dx, cy - dy);
            ctx.lineTo(cx + dx, cy + dy);
            ctx.stroke();

            // 高亮交叉的针
            if (distToNearestLine <= (L / 2) * Math.sin(theta)) {
              ctx.beginPath();
              ctx.strokeStyle = "rgba(255, 140, 0, 0.9)";
              ctx.lineWidth = 2.5;
              ctx.moveTo(cx - dx, cy - dy);
              ctx.lineTo(cx + dx, cy + dy);
              ctx.stroke();
            }
          }
        }

        const piEstimate = (2 * L * trials) / (D * Math.max(hits, 1));
        const error = Math.abs((piEstimate - Math.PI) / Math.PI) * 100;

        const piEl = document.getElementById("buffon-pi");
        const errEl = document.getElementById("buffon-error");
        if (piEl) piEl.textContent = piEstimate.toFixed(6);
        if (errEl) errEl.textContent = error.toFixed(4) + "%";
      }

      // 生日悖论
      let birthdayChart;
      function birthdayExact(n) {
        const days = 365;
        if (n <= 1) return 0;
        let pNoShare = 1;
        for (let i = 0; i < n; i++) {
          pNoShare *= (days - i) / days;
        }
        return 1 - pNoShare;
      }

      function birthdaySimulate(n, trials) {
        const days = 365;
        let countShare = 0;
        for (let t = 0; t < trials; t++) {
          const seen = new Set();
          let hasShare = false;
          for (let i = 0; i < n; i++) {
            const b = Math.floor(Math.random() * days);
            if (seen.has(b)) {
              hasShare = true;
              break;
            }
            seen.add(b);
          }
          if (hasShare) countShare++;
        }
        return countShare / trials;
      }

      function initBirthdayChart(exact = 0.5, estimate = 0.5) {
        const ctx = document.getElementById("birthday-chart")?.getContext("2d");
        if (!ctx) return;
        if (birthdayChart) birthdayChart.destroy();
        birthdayChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["精确", "模拟"],
            datasets: [
              {
                label: "至少两人同生日的概率",
                data: [exact, estimate],
                backgroundColor: [
                  "rgba(191, 0, 255, 0.6)",
                  "rgba(191, 0, 255, 0.3)",
                ],
                borderColor: "rgba(191, 0, 255, 1)",
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                max: 1,
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                ticks: {
                  color: "rgba(255, 255, 255, 0.7)",
                  callback: (v) => v.toFixed(1),
                },
              },
              x: {
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                ticks: { color: "rgba(255, 255, 255, 0.7)" },
              },
            },
            plugins: {
              legend: { labels: { color: "rgba(255, 255, 255, 0.7)" } },
            },
          },
        });
      }

      function updateBirthdayChart(exact, estimate) {
        if (!birthdayChart) return;
        birthdayChart.data.datasets[0].data = [exact, estimate];
        birthdayChart.update();
      }

      // 生日悖论 · 15×25表格日历动画
      const BIRTHDAY_COLS = 15;
      const BIRTHDAY_ROWS = 25;
      let birthdayGridCanvas, birthdayGridCtx;
      let birthdayCellW = 0,
        birthdayCellH = 0;
      let birthdayGridMap = [];
      let birthdayCurrentCounts = new Array(365).fill(0);
      let birthdayCurrentGroupPeopleAdded = 0;
      let birthdayCompletedGroups = 0;
      let birthdayTrialSuccesses = 0;
      let birthdayAnimRunning = false;
      let birthdayDeferredClear = false; // 下一组首人到来时再清空网格
      let birthdayAnimTimer = null;
      let birthdayAnimDelay = 100; // ms per person

      function computeBirthdayGridMap() {
        birthdayGridMap = new Array(365);
        let d = 0;
        for (let r = 0; r < BIRTHDAY_ROWS; r++) {
          for (let c = 0; c < BIRTHDAY_COLS; c++) {
            if (d < 365) birthdayGridMap[d] = { r, c };
            d++;
          }
        }
      }

      function initBirthdayGrid() {
        birthdayGridCanvas = document.getElementById("birthday-grid");
        if (!birthdayGridCanvas) return;
        const rect = birthdayGridCanvas.getBoundingClientRect();
        const width = Math.floor(rect.width);
        const height = Math.floor(rect.height);
        birthdayGridCanvas.width = width > 0 ? width : 600;
        birthdayGridCanvas.height = height > 0 ? height : 256;
        birthdayGridCtx = birthdayGridCanvas.getContext("2d");
        birthdayCellW = Math.floor(birthdayGridCanvas.width / BIRTHDAY_COLS);
        birthdayCellH = Math.floor(birthdayGridCanvas.height / BIRTHDAY_ROWS);
        computeBirthdayGridMap();
        drawBirthdayGridBase();
        drawBirthdayGridCounts(birthdayCurrentCounts);
      }

      function drawBirthdayGridBase() {
        if (!birthdayGridCtx) return;
        const ctx = birthdayGridCtx;
        ctx.clearRect(
          0,
          0,
          birthdayGridCanvas.width,
          birthdayGridCanvas.height
        );
        // 绘制网格背景
        for (let r = 0; r < BIRTHDAY_ROWS; r++) {
          for (let c = 0; c < BIRTHDAY_COLS; c++) {
            const x = c * birthdayCellW;
            const y = r * birthdayCellH;
            const idx = r * BIRTHDAY_COLS + c;
            // 最后10格为空（超过365天）
            if (idx >= 365) {
              ctx.fillStyle = "rgba(120, 120, 120, 0.15)";
              ctx.fillRect(x, y, birthdayCellW - 1, birthdayCellH - 1);
              ctx.strokeStyle = "rgba(200, 200, 200, 0.1)";
              ctx.strokeRect(
                x + 0.5,
                y + 0.5,
                birthdayCellW - 1,
                birthdayCellH - 1
              );
            } else {
              ctx.fillStyle = "rgba(255, 255, 255, 0.05)";
              ctx.fillRect(x, y, birthdayCellW - 1, birthdayCellH - 1);
              ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
              ctx.strokeRect(
                x + 0.5,
                y + 0.5,
                birthdayCellW - 1,
                birthdayCellH - 1
              );
            }
          }
        }
      }

      function drawBirthdayGridCounts(counts) {
        if (!birthdayGridCtx) return;
        const ctx = birthdayGridCtx;
        // 覆盖填色（在基础网格上着色）
        for (let d = 0; d < 365; d++) {
          const { r, c } = birthdayGridMap[d];
          const x = c * birthdayCellW;
          const y = r * birthdayCellH;
          const k = counts[d] || 0;
          if (k > 0) {
            const alpha = Math.min(0.15 + 0.25 * k, 0.95);
            const color = `rgba(191, 0, 255, ${alpha})`;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, birthdayCellW - 1, birthdayCellH - 1);
          } else {
            // 透明覆盖以保留基础网格外观
            ctx.fillStyle = "rgba(0,0,0,0)";
          }
        }
        // 可选：高亮重复
        for (let d = 0; d < 365; d++) {
          if ((counts[d] || 0) >= 2) {
            const { r, c } = birthdayGridMap[d];
            const x = c * birthdayCellW;
            const y = r * birthdayCellH;
            ctx.strokeStyle = "rgba(255, 140, 0, 0.9)";
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 1, y + 1, birthdayCellW - 3, birthdayCellH - 3);
          }
        }
      }

      function updateBirthdayStatus(n, trials) {
        const progEl = document.getElementById("birthday-progress");
        const compEl = document.getElementById("birthday-completed");
        const succEl = document.getElementById("birthday-success");
        if (progEl)
          progEl.textContent = `${birthdayCurrentGroupPeopleAdded} / ${n}`;
        if (compEl) compEl.textContent = `${birthdayCompletedGroups}`;
        if (succEl) succEl.textContent = `${birthdayTrialSuccesses}`;
        const estimateEl = document.getElementById("birthday-estimate");
        if (estimateEl && birthdayCompletedGroups > 0) {
          const estimate = birthdayTrialSuccesses / birthdayCompletedGroups;
          estimateEl.textContent = estimate.toFixed(6);
        }
      }

      function resetBirthdayGroupVisual() {
        birthdayCurrentCounts = new Array(365).fill(0);
        birthdayCurrentGroupPeopleAdded = 0;
        drawBirthdayGridBase();
        drawBirthdayGridCounts(birthdayCurrentCounts);
      }

      function finishBirthdayGroup(n, trials) {
        let hasShare = false;
        for (let d = 0; d < 365; d++) {
          if (birthdayCurrentCounts[d] >= 2) {
            hasShare = true;
            break;
          }
        }
        if (hasShare) birthdayTrialSuccesses++;
        birthdayCompletedGroups++;
        const exact = birthdayExact(n);
        const estimate =
          birthdayTrialSuccesses / Math.max(birthdayCompletedGroups, 1);
        updateBirthdayChart(exact, estimate);
        updateBirthdayStatus(n, trials);
        // 不立即清空：等下一组首人到来再清空
        birthdayCurrentGroupPeopleAdded = 0;
        birthdayDeferredClear = true;
      }

      function stepAddPerson(n, trials) {
        if (birthdayCurrentGroupPeopleAdded >= n) return;
        // 如果上一组刚结束，则在本组首人到来前清空网格
        if (birthdayDeferredClear) {
          birthdayCurrentCounts = new Array(365).fill(0);
          drawBirthdayGridBase();
          drawBirthdayGridCounts(birthdayCurrentCounts);
          birthdayDeferredClear = false;
        }
        const day = Math.floor(Math.random() * 365);
        birthdayCurrentCounts[day] += 1;
        birthdayCurrentGroupPeopleAdded += 1;
        drawBirthdayGridBase();
        drawBirthdayGridCounts(birthdayCurrentCounts);
        updateBirthdayStatus(n, trials);
        if (birthdayCurrentGroupPeopleAdded >= n) {
          finishBirthdayGroup(n, trials);
        }
      }

      function playBirthdayAnimation(n, trials) {
        if (birthdayAnimRunning) return;
        birthdayAnimRunning = true;
        if (birthdayAnimTimer) clearInterval(birthdayAnimTimer);
        birthdayAnimTimer = setInterval(() => {
          // 如果所有组已完成，则停止
          if (birthdayCompletedGroups >= trials) {
            clearInterval(birthdayAnimTimer);
            birthdayAnimTimer = null;
            birthdayAnimRunning = false;
            return;
          }
          stepAddPerson(n, trials);
        }, birthdayAnimDelay);
      }

      function stopBirthdayAnimation() {
        birthdayAnimRunning = false;
        if (birthdayAnimTimer) {
          clearInterval(birthdayAnimTimer);
          birthdayAnimTimer = null;
        }
      }

      function fillCurrentGroupFast(n, trials) {
        const remaining = Math.max(0, n - birthdayCurrentGroupPeopleAdded);
        for (let i = 0; i < remaining; i++) {
          const day = Math.floor(Math.random() * 365);
          birthdayCurrentCounts[day] += 1;
        }
        // 显示当前组最终着色，但不立即清空
        drawBirthdayGridBase();
        drawBirthdayGridCounts(birthdayCurrentCounts);
        birthdayCurrentGroupPeopleAdded = n;
        updateBirthdayStatus(n, trials);
        finishBirthdayGroup(n, trials);
        // 自动按照一组一组播放动画（继续到下一组）
        playBirthdayAnimation(n, trials);
      }

      function runAllGroupsFast(n, trials) {
        stopBirthdayAnimation();
        while (birthdayCompletedGroups < trials) {
          // 填充一个组（统计用，不在网格上逐格呈现）
          const counts = new Array(365).fill(0);
          for (let i = 0; i < n; i++) {
            const day = Math.floor(Math.random() * 365);
            counts[day] += 1;
          }
          let hasShare = false;
          for (let d = 0; d < 365; d++) {
            if (counts[d] >= 2) {
              hasShare = true;
              break;
            }
          }
          if (hasShare) birthdayTrialSuccesses++;
          birthdayCompletedGroups++;
        }
        // 更新估计与图表
        const exact = birthdayExact(n);
        const estimate =
          birthdayTrialSuccesses / Math.max(birthdayCompletedGroups, 1);
        updateBirthdayChart(exact, estimate);
        const estimateEl = document.getElementById("birthday-estimate");
        if (estimateEl) estimateEl.textContent = estimate.toFixed(6);
        updateBirthdayStatus(n, trials);
        // 不立即清空：保留当前组颜色，等待下一组首人到来再清空
        birthdayCurrentGroupPeopleAdded = 0;
        birthdayDeferredClear = true;
      }

      // 二维随机游走
      function runRandomWalk(steps = 1000, stepLen = 3) {
        const canvas = document.getElementById("walk-canvas");
        if (!canvas) return;
        const ctx = setCanvasSize(canvas);
        const container = canvas.parentElement || canvas;
        const rect = container.getBoundingClientRect();
        const width = Math.floor(rect.width || canvas.clientWidth || 400);
        const height = Math.floor(rect.height || canvas.clientHeight || 200);

        // 生成路径
        const points = [{ x: 0, y: 0 }];
        let x = 0,
          y = 0;
        for (let i = 0; i < steps; i++) {
          const theta = Math.random() * 2 * Math.PI;
          x += stepLen * Math.cos(theta);
          y += stepLen * Math.sin(theta);
          points.push({ x, y });
        }

        // 尺度变换以适配画布
        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        for (const p of points) {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        }
        const margin = 10;
        const spanX = maxX - minX || 1;
        const spanY = maxY - minY || 1;
        const scaleX = (width - 2 * margin) / spanX;
        const scaleY = (height - 2 * margin) / spanY;
        const scale = Math.min(scaleX, scaleY);

        // 清空并绘制路径
        ctx.clearRect(0, 0, width, height);
        ctx.strokeStyle = "rgba(0, 255, 102, 0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < points.length; i++) {
          const px = (points[i].x - minX) * scale + margin;
          const py = (points[i].y - minY) * scale + margin;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // 起点与终点标记
        try {
          const start = points[0];
          const end = points[points.length - 1];
          const sx = (start.x - minX) * scale + margin;
          const sy = (start.y - minY) * scale + margin;
          const ex = (end.x - minX) * scale + margin;
          const ey = (end.y - minY) * scale + margin;

          // 起点
          ctx.fillStyle = "rgba(0, 200, 255, 0.95)";
          ctx.beginPath();
          ctx.arc(sx, sy, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "12px sans-serif";
          ctx.fillText("起点", sx + 6, sy - 6);

          // 终点
          ctx.fillStyle = "rgba(255, 80, 80, 0.95)";
          ctx.beginPath();
          ctx.arc(ex, ey, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "12px sans-serif";
          ctx.fillText("终点", ex + 6, ey - 6);
        } catch (e) {
          // 标记绘制失败不影响主体渲染
        }

        // 更新仪表（静态绘制时展示最终结果）
        try {
          walkAnimPoints = points;
          walkAnimStepsTotal = steps;
          walkAnimIndex = steps;
          updateWalkDashboard(steps);
        } catch (e) {
          // 仪表未加载也不影响静态绘制
        }
      }

      // 二维随机游走动画逻辑
      let walkAnimPoints = [];
      let walkAnimIndex = 0;
      let walkAnimTimer = null;
      let walkAnimRunning = false;
      let walkAnimDelay = 100;
      let walkAnimScale = null;
      let walkAnimStepsTotal = 0;

      function generateWalkPoints(steps, stepLen) {
        const points = [{ x: 0, y: 0 }];
        let x = 0,
          y = 0;
        for (let i = 0; i < steps; i++) {
          const theta = Math.random() * 2 * Math.PI;
          x += stepLen * Math.cos(theta);
          y += stepLen * Math.sin(theta);
          points.push({ x, y });
        }
        return points;
      }

      function computeWalkScale(points, width, height) {
        let minX = Infinity,
          maxX = -Infinity,
          minY = Infinity,
          maxY = -Infinity;
        for (const p of points) {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        }
        const margin = 10;
        const spanX = maxX - minX || 1;
        const spanY = maxY - minY || 1;
        const scaleX = (width - 2 * margin) / spanX;
        const scaleY = (height - 2 * margin) / spanY;
        const scale = Math.min(scaleX, scaleY);
        return { minX, minY, scale, margin };
      }

      function drawWalkTo(index) {
        const canvas = document.getElementById("walk-canvas");
        if (!canvas) return;
        const ctx = setCanvasSize(canvas);
        const container = canvas.parentElement || canvas;
        const rect = container.getBoundingClientRect();
        const width = Math.floor(rect.width || canvas.clientWidth || 400);
        const height = Math.floor(rect.height || canvas.clientHeight || 200);

        if (!walkAnimScale) {
          walkAnimScale = computeWalkScale(walkAnimPoints, width, height);
        }
        const { minX, minY, scale, margin } = walkAnimScale;

        ctx.clearRect(0, 0, width, height);
        ctx.strokeStyle = "rgba(0, 255, 102, 0.9)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const upTo = Math.min(index, walkAnimPoints.length - 1);
        for (let i = 0; i <= upTo; i++) {
          const px = (walkAnimPoints[i].x - minX) * scale + margin;
          const py = (walkAnimPoints[i].y - minY) * scale + margin;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();

        // 当前点
        const cp = walkAnimPoints[upTo] || { x: 0, y: 0 };
        const cx = (cp.x - minX) * scale + margin;
        const cy = (cp.y - minY) * scale + margin;
        ctx.fillStyle = "rgba(255, 153, 0, 0.9)";
        ctx.beginPath();
        ctx.arc(cx, cy, 3, 0, Math.PI * 2);
        ctx.fill();

        // 起点与终点标记
        try {
          const start = walkAnimPoints[0] || { x: 0, y: 0 };
          const end = walkAnimPoints[walkAnimPoints.length - 1] || { x: 0, y: 0 };
          const sx = (start.x - minX) * scale + margin;
          const sy = (start.y - minY) * scale + margin;
          const ex = (end.x - minX) * scale + margin;
          const ey = (end.y - minY) * scale + margin;

          // 起点
          ctx.fillStyle = "rgba(0, 200, 255, 0.95)";
          ctx.beginPath();
          ctx.arc(sx, sy, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "12px sans-serif";
          ctx.fillText("起点", sx + 6, sy - 6);

          // 终点（动画进行中也预先显示目标点）
          ctx.fillStyle = "rgba(255, 80, 80, 0.95)";
          ctx.beginPath();
          ctx.arc(ex, ey, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.font = "12px sans-serif";
          ctx.fillText("终点", ex + 6, ey - 6);
        } catch (e) {
          // 标记绘制失败不影响主体渲染
        }

        updateWalkDashboard(upTo);
      }

      function updateWalkDashboard(idx) {
        const total = walkAnimStepsTotal || 0;
        const progressEl = document.getElementById("walk-progress");
        if (progressEl) progressEl.textContent = `${idx} / ${total}`;
        const progressBar = document.getElementById("walk-progress-bar");
        if (progressBar)
          progressBar.style.width =
            total > 0 ? `${(idx / total) * 100}%` : "0%";

        const pt = walkAnimPoints[idx] || { x: 0, y: 0 };
        const R = Math.sqrt(pt.x * pt.x + pt.y * pt.y);
        const Rn = idx > 0 ? R / Math.sqrt(idx) : 0;
        const rEl = document.getElementById("walk-R");
        if (rEl) rEl.textContent = R.toFixed(2);
        const rnEl = document.getElementById("walk-Rn");
        if (rnEl) rnEl.textContent = Rn.toFixed(2);
        const posEl = document.getElementById("walk-pos");
        if (posEl)
          posEl.textContent = `(${pt.x.toFixed(2)}, ${pt.y.toFixed(2)})`;
      }

      function startWalkAnimation(steps, stepLen) {
        walkAnimPoints = generateWalkPoints(steps, stepLen);
        walkAnimStepsTotal = steps;
        walkAnimIndex = 0;
        walkAnimScale = null;
        const speedSlider = document.getElementById("walk-speed");
        const speed = speedSlider ? parseFloat(speedSlider.value) : 1.0;
        walkAnimDelay = Math.max(10, Math.floor(100 / speed));
        if (walkAnimTimer) {
          clearInterval(walkAnimTimer);
          walkAnimTimer = null;
        }
        walkAnimRunning = true;
        drawWalkTo(walkAnimIndex);
        walkAnimTimer = setInterval(() => {
          if (!walkAnimRunning) return;
          if (walkAnimIndex >= walkAnimStepsTotal) {
            pauseWalkAnimation();
            return;
          }
          walkAnimIndex++;
          drawWalkTo(walkAnimIndex);
        }, walkAnimDelay);
      }

      function pauseWalkAnimation() {
        walkAnimRunning = false;
        if (walkAnimTimer) {
          clearInterval(walkAnimTimer);
          walkAnimTimer = null;
        }
      }

      function resumeWalkAnimation() {
        if (walkAnimRunning) return;
        walkAnimRunning = true;
        if (walkAnimTimer) {
          clearInterval(walkAnimTimer);
          walkAnimTimer = null;
        }
        const speedSlider = document.getElementById("walk-speed");
        const speed = speedSlider ? parseFloat(speedSlider.value) : 1.0;
        walkAnimDelay = Math.max(10, Math.floor(100 / speed));
        walkAnimTimer = setInterval(() => {
          if (!walkAnimRunning) return;
          if (walkAnimIndex >= walkAnimStepsTotal) {
            pauseWalkAnimation();
            return;
          }
          walkAnimIndex++;
          drawWalkTo(walkAnimIndex);
        }, walkAnimDelay);
      }

      function stepWalkOnce(steps, stepLen) {
        if (
          !walkAnimPoints ||
          walkAnimPoints.length === 0 ||
          walkAnimIndex >= walkAnimStepsTotal
        ) {
          startWalkAnimation(steps, stepLen);
          pauseWalkAnimation();
        }
        walkAnimIndex = Math.min(walkAnimIndex + 1, walkAnimStepsTotal);
        drawWalkTo(walkAnimIndex);
      }

      function resetWalkAnimation() {
        pauseWalkAnimation();
        walkAnimPoints = [];
        walkAnimIndex = 0;
        walkAnimStepsTotal = 0;
        walkAnimScale = null;
        const canvas = document.getElementById("walk-canvas");
        if (canvas) {
          const ctx = setCanvasSize(canvas);
          const container = canvas.parentElement || canvas;
          const rect = container.getBoundingClientRect();
          const width = Math.floor(rect.width || canvas.clientWidth || 400);
          const height = Math.floor(rect.height || canvas.clientHeight || 200);
          ctx.clearRect(0, 0, width, height);
        }
        updateWalkDashboard(0);
      }

      // 初始化所有图表和事件监听
      // 随机变量相关函数
      // 随机变量相关变量已移至 random_variables.html

      // initDiscreteRvChart函数已移至 random_variables.html

      // initContinuousRvChart函数已移至 random_variables.html

      // initRvFeaturesChart函数已移至 random_variables.html

      // rollTwoDice函数已移至 random_variables.html

      // generateContinuousSamples函数已移至 random_variables.html

      // updateRvFeatures函数已移至 random_variables.html

      // initRvParamEvents函数已移至 random_variables.html
      // ===== 新增：PCA降维投影、相关矩阵热图、KDE对比、Treemap交互 =====

      // ---------- 工具函数 ----------
      function randn() {
        const u = Math.random();
        const v = Math.random();
        return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }

      function setCanvasSize(canvas) {
        // 以父容器尺寸为准，避免canvas自身宽高属性污染导致的异常尺寸
        const container = canvas.parentElement || canvas;
        const rect = container.getBoundingClientRect();
        // 限制DPR、尺寸上限，防止极端场景下出现超大画布
        const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
        const cssW = Math.max(1, Math.floor(rect.width || canvas.clientWidth || 600));
        const cssH = Math.max(1, Math.floor(rect.height || canvas.clientHeight || 280));
        const MAX_DIM = 4096;
        // 同步CSS像素尺寸，确保布局正常
        canvas.style.width = cssW + "px";
        canvas.style.height = cssH + "px";
        // 设置像素尺寸（设备像素），并进行上限裁剪
        canvas.width = Math.min(MAX_DIM, Math.max(1, Math.floor(cssW * dpr)));
        canvas.height = Math.min(MAX_DIM, Math.max(1, Math.floor(cssH * dpr)));
        const ctx = canvas.getContext("2d");
        // 以CSS像素为绘制坐标系
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        return ctx;
      }

      // ---------- PCA 降维投影 ----------
      let pcaChart = null;
      let pcaPoints = [];

      function generatePCAData(n, angleDeg, noise) {
        const angle = (angleDeg * Math.PI) / 180;
        const ca = Math.cos(angle), sa = Math.sin(angle);
        const pts = [];
        for (let i = 0; i < n; i++) {
          const x0 = randn() * 2 + noise * randn();
          const y0 = randn() * 0.7 + noise * randn();
          const x = ca * x0 - sa * y0;
          const y = sa * x0 + ca * y0;
          pts.push({ x, y });
        }
        return pts;
      }

      function covariance2D(points) {
        const n = points.length;
        let mx = 0, my = 0;
        for (const p of points) { mx += p.x; my += p.y; }
        mx /= n; my /= n;
        let vx = 0, vy = 0, cxy = 0;
        for (const p of points) {
          const dx = p.x - mx, dy = p.y - my;
          vx += dx * dx; vy += dy * dy; cxy += dx * dy;
        }
        vx /= Math.max(1, n - 1); vy /= Math.max(1, n - 1); cxy /= Math.max(1, n - 1);
        return { mx, my, vx, vy, cxy };
      }

      function eigen2x2(vx, vy, cxy) {
        const tr = vx + vy;
        const det = vx * vy - cxy * cxy;
        const disc = Math.sqrt(Math.max(0, (tr * tr) / 4 - det));
        const l1 = tr / 2 + disc;
        const l2 = tr / 2 - disc;
        function vecFor(lambda) {
          let a = cxy, b = lambda - vx;
          if (Math.abs(a) < 1e-8 && Math.abs(b) < 1e-8) { a = 1; b = 0; }
          const norm = Math.hypot(a, b) || 1;
          return { x: a / norm, y: b / norm };
        }
        const v1 = vecFor(l1);
        const v2 = vecFor(l2);
        return { l1, l2, v1, v2 };
      }

      function initPCAChart() {
        const ctx = document.getElementById("pca-chart").getContext("2d");
        pcaChart = new Chart(ctx, {
          type: "scatter",
          data: { datasets: [] },
          options: {
            animation: false,
            scales: {
              x: { grid: { color: "rgba(100,100,100,0.2)" }, ticks: { color: "#AAA" } },
              y: { grid: { color: "rgba(100,100,100,0.2)" }, ticks: { color: "#AAA" } },
            },
            plugins: { legend: { display: false } },
            elements: { point: { radius: 2 } },
          },
        });
      }

      function updatePCA() {
        if (!pcaChart) initPCAChart();
        const { mx, my, vx, vy, cxy } = covariance2D(pcaPoints);
        const { l1, l2, v1, v2 } = eigen2x2(vx, vy, cxy);
        const showAxes = document.getElementById("pca-show-axes").checked;
        const datasets = [];
        datasets.push({
          label: "points",
          data: pcaPoints,
          backgroundColor: "rgba(0, 255, 255, 0.6)",
          borderColor: "rgba(0,255,255,0.3)",
          showLine: false,
          pointRadius: 2,
        });
        if (showAxes) {
          const s1 = 2 * Math.sqrt(Math.max(0, l1));
          const s2 = 2 * Math.sqrt(Math.max(0, l2));
          datasets.push({
            label: "PC1",
            type: "line",
            data: [
              { x: mx - s1 * v1.x, y: my - s1 * v1.y },
              { x: mx + s1 * v1.x, y: my + s1 * v1.y },
            ],
            borderColor: "rgba(0, 200, 255, 1)",
            backgroundColor: "rgba(0, 200, 255, 0.2)",
            pointRadius: 0,
            tension: 0,
          });
          datasets.push({
            label: "PC2",
            type: "line",
            data: [
              { x: mx - s2 * v2.x, y: my - s2 * v2.y },
              { x: mx + s2 * v2.x, y: my + s2 * v2.y },
            ],
            borderColor: "rgba(255, 0, 200, 1)",
            backgroundColor: "rgba(255, 0, 200, 0.2)",
            pointRadius: 0,
            tension: 0,
          });
        }
        pcaChart.data.datasets = datasets;
        pcaChart.update();
      }

      function regeneratePCA() {
        const n = parseInt(document.getElementById("pca-samples").value, 10);
        const angle = parseFloat(document.getElementById("pca-angle").value);
        const noise = parseFloat(document.getElementById("pca-noise").value);
        pcaPoints = generatePCAData(n, angle, noise);
        updatePCA();
      }

      // ---------- 相关矩阵热图 ----------
      let heatMatrix = [];
      let heatOrder = [];

      function generateLatentCorr(dim, samples = 500, latent = 3) {
        const Z = Array.from({ length: samples }, () => Array.from({ length: latent }, () => randn()));
        const B = Array.from({ length: latent }, () => Array.from({ length: dim }, () => Math.random() * 2 - 1));
        const noiseScale = 0.5;
        const X = Array.from({ length: samples }, () => Array(dim).fill(0));
        for (let i = 0; i < samples; i++) {
          for (let j = 0; j < dim; j++) {
            let val = 0;
            for (let k = 0; k < latent; k++) val += Z[i][k] * B[k][j];
            val += noiseScale * randn();
            X[i][j] = val;
          }
        }
        const means = Array(dim).fill(0);
        for (let j = 0; j < dim; j++) {
          for (let i = 0; i < samples; i++) means[j] += X[i][j];
          means[j] /= samples;
        }
        const stds = Array(dim).fill(0);
        for (let j = 0; j < dim; j++) {
          for (let i = 0; i < samples; i++) stds[j] += Math.pow(X[i][j] - means[j], 2);
          stds[j] = Math.sqrt(stds[j] / Math.max(1, samples - 1)) || 1;
        }
        for (let j = 0; j < dim; j++) {
          for (let i = 0; i < samples; i++) X[i][j] = (X[i][j] - means[j]) / stds[j];
        }
        const C = Array.from({ length: dim }, () => Array(dim).fill(0));
        for (let a = 0; a < dim; a++) {
          for (let b = a; b < dim; b++) {
            let s = 0;
            for (let i = 0; i < samples; i++) s += X[i][a] * X[i][b];
            const r = s / Math.max(1, samples - 1);
            C[a][b] = r; C[b][a] = r;
          }
          C[a][a] = 1;
        }
        return C;
      }

      function heatColor(v) {
        const t = (v + 1) / 2; // [0,1]
        const hue = 280 * (1 - t) + 160 * t;
        const s = 80;
        const l = 50 + 10 * Math.sin(t * Math.PI);
        return `hsl(${hue}, ${s}%, ${l}%)`;
      }

      function drawHeatmapCanvas(matrix) {
        const canvas = document.getElementById("heatmap-canvas");
        const ctx = setCanvasSize(canvas);
        const n = matrix.length;
        const rect = canvas.getBoundingClientRect();
        const size = Math.min(rect.width, rect.height);
        const cell = size / n;
        ctx.clearRect(0, 0, rect.width, rect.height);
        ctx.save();
        ctx.translate((rect.width - size) / 2, (rect.height - size) / 2);
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            const v = matrix[heatOrder[i]][heatOrder[j]];
            ctx.fillStyle = heatColor(v);
            ctx.fillRect(j * cell, i * cell, cell, cell);
          }
        }
        ctx.strokeStyle = "rgba(100,100,100,0.4)";
        for (let k = 0; k <= n; k++) {
          ctx.beginPath(); ctx.moveTo(0, k * cell); ctx.lineTo(n * cell, k * cell); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(k * cell, 0); ctx.lineTo(k * cell, n * cell); ctx.stroke();
        }
        ctx.restore();
      }

      function clusterOrder(matrix) {
        const n = matrix.length;
        const scores = Array.from({ length: n }, (_, i) => ({ i, s: matrix[i].reduce((a, b, j) => a + Math.abs(b) - (i === j ? 1 : 0), 0) }));
        scores.sort((a, b) => b.s - a.s);
        return scores.map((o) => o.i);
      }

      function setupHeatmap() {
        const dim = parseInt(document.getElementById("heat-dim").value, 10);
        heatMatrix = generateLatentCorr(dim);
        heatOrder = Array.from({ length: dim }, (_, i) => i);
        drawHeatmapCanvas(heatMatrix);
      }

      function bindHeatmapTooltip() {
        const canvas = document.getElementById("heatmap-canvas");
        const tooltip = document.getElementById("heatmap-tooltip");
        canvas.addEventListener("mousemove", (e) => {
          const rect = canvas.getBoundingClientRect();
          const n = heatOrder.length;
          const size = Math.min(rect.width, rect.height);
          const offsetX = (rect.width - size) / 2;
          const offsetY = (rect.height - size) / 2;
          const x = e.clientX - rect.left - offsetX;
          const y = e.clientY - rect.top - offsetY;
          if (x < 0 || y < 0 || x > size || y > size) {
            tooltip.classList.add("hidden");
            return;
          }
          const cell = size / n;
          const j = Math.floor(x / cell);
          const i = Math.floor(y / cell);
          const vi = heatOrder[i];
          const vj = heatOrder[j];
          const val = heatMatrix[vi][vj];
          tooltip.textContent = `变量 ${vi + 1} vs ${vj + 1}: ${val.toFixed(2)}`;
          tooltip.style.left = `${e.clientX - rect.left + 12}px`;
          tooltip.style.top = `${e.clientY - rect.top + 12}px`;
          tooltip.classList.remove("hidden");
        });
        canvas.addEventListener("mouseleave", () => tooltip.classList.add("hidden"));
      }

      // ---------- KDE 与直方图 ----------
      let kdeChart = null;
      let kdeSamples = [];
      let kdeTimer = null;
      let kdeDist = "normal";

      function initKDEChart() {
        const canvas = document.getElementById("kde-chart");
        if (!canvas) return;
        setCanvasSize(canvas);
        kdeChart = true; // 标记已初始化（使用Canvas绘制而非Chart.js）
      }

      function sampleOne(dist) {
        if (dist === "normal") return randn();
        if (dist === "uniform") return Math.random() * 2 - 1;
        if (dist === "exponential") { const lambda = 1; return -Math.log(1 - Math.random()) / lambda; }
        return 0;
      }

      function computeHistogram(samples, bins = 30) {
        if (samples.length === 0) return { centers: [], density: [] };
        const min = Math.min(...samples);
        const max = Math.max(...samples);
        const rangePad = (max - min) * 0.05 || 0.5;
        const a = min - rangePad, b = max + rangePad;
        const width = (b - a) / bins;
        const counts = Array(bins).fill(0);
        for (const x of samples) { let idx = Math.floor((x - a) / width); if (idx < 0) idx = 0; if (idx >= bins) idx = bins - 1; counts[idx] += 1; }
        const n = samples.length;
        const density = counts.map((c) => c / (n * width));
        const centers = Array.from({ length: bins }, (_, i) => a + i * width + width / 2);
        return { centers, density };
      }

      function computeKDE(samples, h, grid = 120) {
        if (samples.length === 0) return { xs: [], ys: [] };
        const min = Math.min(...samples);
        const max = Math.max(...samples);
        const pad = (max - min) * 0.2 + 1e-6;
        const a = min - pad, b = max + pad;
        const xs = Array.from({ length: grid }, (_, i) => a + (i / (grid - 1)) * (b - a));
        const norm = 1 / (Math.sqrt(2 * Math.PI) * h * samples.length);
        const ys = xs.map((x) => {
          let s = 0; for (const xi of samples) { const u = (x - xi) / h; s += Math.exp(-0.5 * u * u); }
          return s * norm;
        });
        return { xs, ys };
      }

      function drawKDECanvas(centers, density, xs, ys) {
        const canvas = document.getElementById("kde-chart");
        if (!canvas) return;
        const ctx = setCanvasSize(canvas);
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
        const margin = 48;
        const w = rect.width - margin * 2;
        const h = rect.height - margin * 2;
        ctx.save();
        ctx.translate(margin, margin);

        const xsAll = [...(centers || []), ...(xs || [])];
        const ysAll = [...(density || []), ...(ys || [])];
        const xMin = xsAll.length ? Math.min(...xsAll) : -1;
        const xMax = xsAll.length ? Math.max(...xsAll) : 1;
        const yMax = ysAll.length ? Math.max(...ysAll) : 1;
        const xScale = (x) => ((x - xMin) / (xMax - xMin || 1)) * w;
        const yScale = (y) => h - (y / (yMax || 1)) * h;

        // 网格
        ctx.strokeStyle = "rgba(120,120,120,0.25)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const yy = (i / 5) * h; ctx.beginPath(); ctx.moveTo(0, yy); ctx.lineTo(w, yy); ctx.stroke();
        }
        for (let i = 0; i <= 10; i++) {
          const xx = (i / 10) * w; ctx.beginPath(); ctx.moveTo(xx, 0); ctx.lineTo(xx, h); ctx.stroke();
        }

        // 直方图条形
        if (centers && centers.length > 0) {
          const binWidth = centers.length > 1 ? (centers[1] - centers[0]) : 0.1;
          const barW = w * (binWidth / (xMax - xMin || 1));
          for (let i = 0; i < centers.length; i++) {
            const x = xScale(centers[i]) - barW / 2;
            const y = yScale(density[i] || 0);
            const grad = ctx.createLinearGradient(x, y, x, h);
            grad.addColorStop(0, "rgba(255,140,0,0.8)");
            grad.addColorStop(1, "rgba(255,140,0,0.15)");
            ctx.fillStyle = grad;
            ctx.fillRect(x, y, Math.max(1, barW), h - y);
          }
        }

        // KDE 曲线
        if (xs && xs.length > 0) {
          ctx.lineWidth = 2.5;
          ctx.strokeStyle = "rgba(255,220,0,0.95)";
          ctx.shadowColor = "rgba(255,220,0,0.6)";
          ctx.shadowBlur = 12;
          ctx.beginPath();
          for (let i = 0; i < xs.length; i++) {
            const X = xScale(xs[i]);
            const Y = yScale(ys[i] || 0);
            if (i === 0) ctx.moveTo(X, Y); else ctx.lineTo(X, Y);
          }
          ctx.stroke();
          ctx.shadowBlur = 0;
        }

        // 轴线
        ctx.strokeStyle = "rgba(200,200,200,0.9)";
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(0, h); ctx.lineTo(w, h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, h); ctx.stroke();

        ctx.restore();
      }

      function updateKDE() {
        if (!kdeChart) initKDEChart();
        const h = parseFloat(document.getElementById("kde-bandwidth").value);
        const { centers, density } = computeHistogram(kdeSamples);
        const { xs, ys } = computeKDE(kdeSamples, h);
        drawKDECanvas(centers, density, xs, ys);
        const nTarget = parseInt(document.getElementById("kde-samples").value, 10);
        if (kdeSamples.length >= nTarget && kdeTimer) { clearInterval(kdeTimer); kdeTimer = null; }
      }

      function startKDEStream() {
        const nTarget = parseInt(document.getElementById("kde-samples").value, 10);
        if (kdeTimer) return;
        kdeTimer = setInterval(() => {
          for (let i = 0; i < 100 && kdeSamples.length < nTarget; i++) kdeSamples.push(sampleOne(kdeDist));
          updateKDE();
          if (kdeSamples.length >= nTarget) { clearInterval(kdeTimer); kdeTimer = null; }
        }, 120);
      }
      function stopKDEStream() { if (kdeTimer) { clearInterval(kdeTimer); kdeTimer = null; } }
      function resetKDE() { kdeSamples = []; stopKDEStream(); updateKDE(); }

      // ---------- Treemap 比例树图 ----------
      let treemapRects = [];
      let treemapData = [];

      function randomWeights(n) {
        const w = Array.from({ length: n }, () => Math.random() + 0.1);
        const s = w.reduce((a, b) => a + b, 0);
        return w.map((x) => x / s);
      }
      function treemapPalette(i) {
        const hues = [165, 195, 220, 260, 300, 20, 40, 80, 130, 160, 200, 240];
        const hue = hues[i % hues.length];
        return `hsla(${hue}, 85%, 55%, 0.75)`;
      }
      function layoutSliceDice(x, y, w, h, weights, horizontal) {
        const rects = [];
        if (horizontal) { let acc = x; for (const p of weights) { const rw = w * p; rects.push({ x: acc, y, w: rw, h }); acc += rw; } }
        else { let acc = y; for (const p of weights) { const rh = h * p; rects.push({ x, y: acc, w, h: rh }); acc += rh; } }
        return rects;
      }
      function drawTreemap() {
        const canvas = document.getElementById("treemap-canvas");
        const ctx = setCanvasSize(canvas);
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
        const weights = treemapData.map((d) => d.weight);
        const rects = layoutSliceDice(10, 10, rect.width - 20, rect.height - 20, weights, true);
        treemapRects = rects.map((r, i) => ({ ...r, idx: i }));
        ctx.save(); ctx.shadowBlur = 18; ctx.shadowColor = "rgba(0,255,200,0.4)";
        for (let i = 0; i < rects.length; i++) {
          const r = rects[i];
          ctx.fillStyle = treemapPalette(i);
          ctx.fillRect(r.x, r.y, r.w, r.h);
          ctx.strokeStyle = "rgba(255,255,255,0.25)"; ctx.lineWidth = 2; ctx.strokeRect(r.x, r.y, r.w, r.h);
          ctx.fillStyle = "rgba(245,245,245,0.9)"; ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
          const label = `C${i + 1}: ${(weights[i] * 100).toFixed(1)}%`;
          ctx.fillText(label, r.x + 8, r.y + 18);
        }
        ctx.restore();
      }
      function randomizeTreemap() {
        const n = parseInt(document.getElementById("treemap-cats").value, 10);
        const w = randomWeights(n);
        treemapData = Array.from({ length: n }, (_, i) => ({ name: `C${i + 1}`, weight: w[i] }));
        drawTreemap();
      }
      function bindTreemapHover() {
        const canvas = document.getElementById("treemap-canvas");
        canvas.addEventListener("mousemove", (e) => {
          const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left; const y = e.clientY - rect.top;
          const hit = treemapRects.find((r) => x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h);
          drawTreemap(); if (!hit) return;
          const ctx = canvas.getContext("2d"); ctx.save(); ctx.strokeStyle = "rgba(255,255,255,0.9)"; ctx.lineWidth = 3.5; ctx.strokeRect(hit.x, hit.y, hit.w, hit.h); ctx.restore();
        });
        canvas.addEventListener("mouseleave", drawTreemap);
      }

      function bindNewVisualizationEvents() {
        // PCA
        const pcaSamples = document.getElementById("pca-samples");
        const pcaAngle = document.getElementById("pca-angle");
        const pcaNoise = document.getElementById("pca-noise");
        document.getElementById("pca-samples-value").textContent = pcaSamples.value;
        document.getElementById("pca-angle-value").textContent = pcaAngle.value;
        document.getElementById("pca-noise-value").textContent = pcaNoise.value;
        pcaSamples.addEventListener("input", () => { document.getElementById("pca-samples-value").textContent = pcaSamples.value; regeneratePCA(); });
        pcaAngle.addEventListener("input", () => { document.getElementById("pca-angle-value").textContent = pcaAngle.value; regeneratePCA(); });
        pcaNoise.addEventListener("input", () => { document.getElementById("pca-noise-value").textContent = pcaNoise.value; regeneratePCA(); });
        document.getElementById("pca-generate").addEventListener("click", regeneratePCA);
        document.getElementById("pca-show-axes").addEventListener("change", updatePCA);

        // Heatmap
        const heatDim = document.getElementById("heat-dim");
        document.getElementById("heat-dim-value").textContent = heatDim.value;
        heatDim.addEventListener("input", () => { document.getElementById("heat-dim-value").textContent = heatDim.value; setupHeatmap(); });
        document.getElementById("heat-generate").addEventListener("click", setupHeatmap);
        document.getElementById("heat-cluster").addEventListener("click", () => { heatOrder = clusterOrder(heatMatrix); drawHeatmapCanvas(heatMatrix); });
        bindHeatmapTooltip();

        // KDE
        document.getElementById("kde-samples-value").textContent = document.getElementById("kde-samples").value;
        document.getElementById("kde-bandwidth-value").textContent = document.getElementById("kde-bandwidth").value;
        document.getElementById("kde-samples").addEventListener("input", () => {
          document.getElementById("kde-samples-value").textContent = document.getElementById("kde-samples").value;
        });
        document.getElementById("kde-bandwidth").addEventListener("input", () => {
          document.getElementById("kde-bandwidth-value").textContent = document.getElementById("kde-bandwidth").value; updateKDE();
        });
        document.querySelectorAll(".kde-dist-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            document.querySelectorAll(".kde-dist-btn").forEach((b) => b.classList.remove("active", "bg-neon-orange/20", "text-neon-orange"));
            btn.classList.add("active", "bg-neon-orange/20", "text-neon-orange");
            kdeDist = btn.dataset.dist;
            resetKDE();
          });
        });
        document.getElementById("kde-stream").addEventListener("click", () => { startKDEStream(); });
        document.getElementById("kde-stop").addEventListener("click", () => { stopKDEStream(); });
        document.getElementById("kde-reset").addEventListener("click", () => { resetKDE(); });

        // 响应式：窗口尺寸变化时重绘Canvas可视化
        window.addEventListener("resize", () => {
          try { updatePCA(); } catch (e) {}
          try { drawHeatmapCanvas(heatMatrix); } catch (e) {}
          try { drawTreemap(); } catch (e) {}
          try { updateKDE(); } catch (e) {}
        });

        // Treemap
        document.getElementById("treemap-cats").addEventListener("input", () => {
          document.getElementById("treemap-cats-value").textContent = document.getElementById("treemap-cats").value; randomizeTreemap();
        });
        document.getElementById("treemap-randomize").addEventListener("click", randomizeTreemap);
        document.getElementById("treemap-mode").addEventListener("change", drawTreemap);
        bindTreemapHover();
      }

      function initNewVisualizations() {
        try { regeneratePCA(); } catch (e) {}
        try { setupHeatmap(); } catch (e) {}
        try { resetKDE(); } catch (e) {}
        try { randomizeTreemap(); } catch (e) {}
      }

      document.addEventListener("DOMContentLoaded", () => {
        // 创建粒子背景
        createParticles();

        // 随机变量相关功能已移至 random_variables.html

        // 初始化图表 - 确保Chart.js已加载
        if (typeof Chart !== "undefined") {
          initDiceChart();
          initNormalChart();
          initMonteCarloChart();
          initDistributionsChart();
          initCorrelationChart();
        } else {
          console.error("Chart.js未加载，请检查网络连接");
        }

        // 初始化分布参数事件监听器
        initDistributionParamEvents();

        // 绑定并初始化新增可视化组件
        bindNewVisualizationEvents();
        initNewVisualizations();

        // 初始化URL点击处理
        if (typeof URLClickHandler !== "undefined") {
          const clickHandler = new URLClickHandler();
          clickHandler.init();
        }

        // 掷骰子模拟器事件
        const diceTrialsSlider = document.getElementById("dice-trials");
        const diceTrialsValue = document.getElementById("dice-trials-value");
        const rollDiceBtn = document.getElementById("roll-dice");

        diceTrialsSlider.addEventListener("input", () => {
          diceTrialsValue.textContent = diceTrialsSlider.value;
        });

        rollDiceBtn.addEventListener("click", () => {
          const trials = parseInt(diceTrialsSlider.value);
          rollDice(trials);
        });

        // 正态分布模拟器事件
        const normalMeanSlider = document.getElementById("normal-sim-mean");
        const normalMeanValue = document.getElementById(
          "normal-sim-mean-value"
        );
        const normalStdSlider = document.getElementById("normal-sim-std");
        const normalStdValue = document.getElementById("normal-sim-std-value");
        const generateNormalBtn = document.getElementById("generate-normal");

        normalMeanSlider.addEventListener("input", () => {
          normalMeanValue.textContent = normalMeanSlider.value;
        });

        normalStdSlider.addEventListener("input", () => {
          normalStdValue.textContent = normalStdSlider.value;
        });

        generateNormalBtn.addEventListener("click", () => {
          const mean = parseFloat(normalMeanSlider.value);
          const std = parseFloat(normalStdSlider.value);
          initNormalChart(mean, std);
        });

        // 蒙特卡洛模拟事件
        const monteCarloSamplesSlider = document.getElementById(
          "monte-carlo-samples"
        );
        const monteCarloSamplesValue = document.getElementById(
          "monte-carlo-samples-value"
        );
        const calculatePiBtn = document.getElementById("calculate-pi");

        monteCarloSamplesSlider.addEventListener("input", () => {
          monteCarloSamplesValue.textContent = monteCarloSamplesSlider.value;
        });

        calculatePiBtn.addEventListener("click", () => {
          const samples = parseInt(monteCarloSamplesSlider.value);
          calculatePi(samples);
        });

        // 高尔顿板事件
        const galtonRowsSlider = document.getElementById("galton-rows");
        const galtonRowsValue = document.getElementById("galton-rows-value");
        const galtonBallsSlider = document.getElementById("galton-balls");
        const galtonBallsValue = document.getElementById("galton-balls-value");
        const runGaltonBtn = document.getElementById("run-galton");
        const galtonAnimEnable = document.getElementById("galton-anim-enable");
        const galtonSpeedSlider = document.getElementById("galton-speed");
        const galtonSpeedValue = document.getElementById("galton-speed-value");
        const galtonShowTheory = document.getElementById("galton-show-theory");

        if (galtonRowsSlider && galtonRowsValue) {
          galtonRowsSlider.addEventListener("input", () => {
            galtonRowsValue.textContent = galtonRowsSlider.value;
          });
        }
        if (galtonBallsSlider && galtonBallsValue) {
          galtonBallsSlider.addEventListener("input", () => {
            galtonBallsValue.textContent = galtonBallsSlider.value;
          });
        }
        if (galtonSpeedSlider && galtonSpeedValue) {
          galtonSpeedSlider.addEventListener("input", () => {
            galtonSpeedValue.textContent = `${parseFloat(
              galtonSpeedSlider.value
            ).toFixed(1)}x`;
          });
        }
        if (runGaltonBtn) {
          runGaltonBtn.addEventListener("click", () => {
            const rows = parseInt(galtonRowsSlider.value);
            const balls = parseInt(galtonBallsSlider.value);
            const showTheory = !!galtonShowTheory?.checked;
            const speed = parseFloat(galtonSpeedSlider?.value || 1);
            if (galtonAnimEnable?.checked) {
              galtonAnimRunning = true;
              startGaltonAnimation(rows, balls, speed, showTheory);
            } else {
              galtonAnimRunning = false;
              initGaltonChart(rows, balls, showTheory);
              drawGaltonBoard(rows);
            }
          });
        }
        if (galtonAnimEnable) {
          galtonAnimEnable.addEventListener("change", () => {
            // 切换为关闭动画时，立即停止当前动画
            if (!galtonAnimEnable.checked) {
              galtonAnimRunning = false;
              const rows = parseInt(galtonRowsSlider.value);
              drawGaltonBoard(rows);
            }
          });
        }
        if (galtonShowTheory) {
          galtonShowTheory.addEventListener("change", () => {
            const rows = parseInt(galtonRowsSlider.value);
            const balls = parseInt(galtonBallsSlider.value);
            const showTheory = !!galtonShowTheory.checked;
            if (galtonAnimEnable?.checked) {
              // 重启动画并刷新曲线
              galtonAnimRunning = false;
              setTimeout(
                () =>
                  startGaltonAnimation(
                    rows,
                    balls,
                    parseFloat(galtonSpeedSlider?.value || 1),
                    showTheory
                  ),
                50
              );
            } else {
              initGaltonChart(rows, balls, showTheory);
            }
          });
        }

        // 蒲丰投针事件
        const buffonNeedlesSlider = document.getElementById("buffon-needles");
        const buffonNeedlesValue = document.getElementById(
          "buffon-needles-value"
        );
        const buffonThrowBtn = document.getElementById("buffon-throw");

        if (buffonNeedlesSlider && buffonNeedlesValue) {
          buffonNeedlesSlider.addEventListener("input", () => {
            buffonNeedlesValue.textContent = buffonNeedlesSlider.value;
          });
        }
        if (buffonThrowBtn) {
          buffonThrowBtn.addEventListener("click", () => {
            const trials = parseInt(buffonNeedlesSlider.value);
            buffonSimulate(trials);
          });
        }
        // 渲染蒲丰投针公式显示
        renderBuffonFormulas();

        // 初始设置蒲丰投针画布尺寸，并在窗口变化时自适应填充父容器
        const buffonCanvasEl = document.getElementById("buffon-canvas");
        if (buffonCanvasEl) {
          setCanvasSize(buffonCanvasEl);
          const handleBuffonResize = () => {
            setCanvasSize(buffonCanvasEl);
            const trials = parseInt(buffonNeedlesSlider?.value || 2000);
            buffonSimulate(trials);
          };
          window.addEventListener("resize", handleBuffonResize);
        }

        // 生日悖论事件
        const birthdayGroupSlider = document.getElementById("birthday-group");
        const birthdayGroupValue = document.getElementById(
          "birthday-group-value"
        );
        const birthdayTrialsSlider = document.getElementById("birthday-trials");
        const birthdayTrialsValue = document.getElementById(
          "birthday-trials-value"
        );
        const birthdayCalcBtn = document.getElementById("birthday-calc");
        const birthdaySimBtn = document.getElementById("birthday-sim");
        const birthdayExactEl = document.getElementById("birthday-exact");
        const birthdayEstimateEl = document.getElementById("birthday-estimate");

        if (birthdayGroupSlider && birthdayGroupValue) {
          birthdayGroupSlider.addEventListener("input", () => {
            birthdayGroupValue.textContent = birthdayGroupSlider.value;
            const n = parseInt(birthdayGroupSlider.value);
            const exact = birthdayExact(n);
            if (birthdayExactEl) birthdayExactEl.textContent = exact.toFixed(6);
            updateBirthdayChart(
              exact,
              birthdayChart?.data.datasets[0].data[1] || exact
            );
            // 更新进度显示中的分母
            updateBirthdayStatus(n, parseInt(birthdayTrialsSlider.value));
          });
        }
        if (birthdayTrialsSlider && birthdayTrialsValue) {
          birthdayTrialsSlider.addEventListener("input", () => {
            birthdayTrialsValue.textContent = birthdayTrialsSlider.value;
            updateBirthdayStatus(
              parseInt(birthdayGroupSlider.value),
              parseInt(birthdayTrialsSlider.value)
            );
          });
        }
        if (birthdayCalcBtn) {
          birthdayCalcBtn.addEventListener("click", () => {
            const n = parseInt(birthdayGroupSlider.value);
            const exact = birthdayExact(n);
            if (birthdayExactEl) birthdayExactEl.textContent = exact.toFixed(6);
            const currentEstimate =
              birthdayChart?.data.datasets[0].data[1] || exact;
            updateBirthdayChart(exact, currentEstimate);
          });
        }
        if (birthdaySimBtn) {
          birthdaySimBtn.addEventListener("click", () => {
            const n = parseInt(birthdayGroupSlider.value);
            const trials = parseInt(birthdayTrialsSlider.value);
            const estimate = birthdaySimulate(n, trials);
            if (birthdayEstimateEl)
              birthdayEstimateEl.textContent = estimate.toFixed(6);
            const exact = birthdayExact(n);
            updateBirthdayChart(exact, estimate);
          });
        }

        // 生日悖论动画控制
        const birthdayAnimPlayBtn =
          document.getElementById("birthday-anim-play");
        const birthdayAnimStepBtn =
          document.getElementById("birthday-anim-step");
        const birthdayFillBtn = document.getElementById("birthday-fill-group");
        const birthdayFastAllBtn = document.getElementById("birthday-fast-all");
        const birthdayResetBtn = document.getElementById("birthday-reset");
        if (document.getElementById("birthday-grid")) {
          initBirthdayGrid();
          // 初始化状态文本
          updateBirthdayStatus(
            parseInt(birthdayGroupSlider.value),
            parseInt(birthdayTrialsSlider.value)
          );
        }
        if (birthdayAnimPlayBtn) {
          birthdayAnimPlayBtn.addEventListener("click", () => {
            const n = parseInt(birthdayGroupSlider.value);
            const trials = parseInt(birthdayTrialsSlider.value);
            playBirthdayAnimation(n, trials);
          });
        }
        if (birthdayAnimStepBtn) {
          birthdayAnimStepBtn.addEventListener("click", () => {
            const n = parseInt(birthdayGroupSlider.value);
            const trials = parseInt(birthdayTrialsSlider.value);
            stopBirthdayAnimation();
            stepAddPerson(n, trials);
          });
        }
        if (birthdayFillBtn) {
          birthdayFillBtn.addEventListener("click", () => {
            const n = parseInt(birthdayGroupSlider.value);
            const trials = parseInt(birthdayTrialsSlider.value);
            stopBirthdayAnimation();
            fillCurrentGroupFast(n, trials);
          });
        }
        if (birthdayFastAllBtn) {
          birthdayFastAllBtn.addEventListener("click", () => {
            const n = parseInt(birthdayGroupSlider.value);
            const trials = parseInt(birthdayTrialsSlider.value);
            runAllGroupsFast(n, trials);
          });
        }
        if (birthdayResetBtn) {
          birthdayResetBtn.addEventListener("click", () => {
            stopBirthdayAnimation();
            birthdayCurrentCounts = new Array(365).fill(0);
            birthdayCurrentGroupPeopleAdded = 0;
            birthdayCompletedGroups = 0;
            birthdayTrialSuccesses = 0;
            drawBirthdayGridBase();
            drawBirthdayGridCounts(birthdayCurrentCounts);
            const estimateEl = document.getElementById("birthday-estimate");
            if (estimateEl) estimateEl.textContent = (0).toFixed(6);
            const n = parseInt(birthdayGroupSlider.value);
            updateBirthdayChart(birthdayExact(n), 0);
            updateBirthdayStatus(n, parseInt(birthdayTrialsSlider.value));
          });
        }

        // 二维随机游走事件
        const walkStepsSlider = document.getElementById("walk-steps");
        const walkStepsValue = document.getElementById("walk-steps-value");
        const walkStepLenSlider = document.getElementById("walk-step-length");
        const walkStepLenValue = document.getElementById(
          "walk-step-length-value"
        );
        const runWalkBtn = document.getElementById("run-walk");
        const walkAnimEnable = document.getElementById("walk-anim-enable");
        const walkSpeedSlider = document.getElementById("walk-speed");
        const walkSpeedValue = document.getElementById("walk-speed-value");
        const walkPlayBtn = document.getElementById("walk-play");
        const walkPauseBtn = document.getElementById("walk-pause");
        const walkStepBtn = document.getElementById("walk-step");
        const walkResetBtn = document.getElementById("walk-reset");

        if (walkStepsSlider && walkStepsValue) {
          walkStepsSlider.addEventListener("input", () => {
            walkStepsValue.textContent = walkStepsSlider.value;
          });
        }
        if (walkStepLenSlider && walkStepLenValue) {
          walkStepLenSlider.addEventListener("input", () => {
            walkStepLenValue.textContent = walkStepLenSlider.value;
          });
        }
        if (walkSpeedSlider && walkSpeedValue) {
          walkSpeedSlider.addEventListener("input", () => {
            const speed = parseFloat(walkSpeedSlider.value);
            walkSpeedValue.textContent = `${speed.toFixed(1)}x`;
            if (walkAnimRunning) {
              pauseWalkAnimation();
              resumeWalkAnimation();
            }
          });
        }
        if (runWalkBtn) {
          runWalkBtn.addEventListener("click", () => {
            const steps = parseInt(walkStepsSlider.value);
            const stepLen = parseFloat(walkStepLenSlider.value);
            if (walkAnimEnable && walkAnimEnable.checked) {
              startWalkAnimation(steps, stepLen);
            } else {
              runRandomWalk(steps, stepLen);
            }
          });
        }
        if (walkPlayBtn) {
          walkPlayBtn.addEventListener("click", () => {
            const steps = parseInt(walkStepsSlider.value);
            const stepLen = parseFloat(walkStepLenSlider.value);
            if (
              !walkAnimPoints ||
              walkAnimPoints.length === 0 ||
              walkAnimIndex >= walkAnimStepsTotal
            ) {
              startWalkAnimation(steps, stepLen);
            } else {
              resumeWalkAnimation();
            }
          });
        }
        if (walkPauseBtn) {
          walkPauseBtn.addEventListener("click", () => {
            pauseWalkAnimation();
          });
        }
        if (walkStepBtn) {
          walkStepBtn.addEventListener("click", () => {
            const steps = parseInt(walkStepsSlider.value);
            const stepLen = parseFloat(walkStepLenSlider.value);
            pauseWalkAnimation();
            stepWalkOnce(steps, stepLen);
          });
        }
        if (walkResetBtn) {
          walkResetBtn.addEventListener("click", () => {
            resetWalkAnimation();
          });
        }

        // 初始设置画布尺寸，并在窗口变化时自适应填充父容器
        const walkCanvasEl = document.getElementById("walk-canvas");
        if (walkCanvasEl) {
          setCanvasSize(walkCanvasEl);
          const handleWalkResize = () => {
            setCanvasSize(walkCanvasEl);
            // 尺度缓存失效，按新尺寸重算并重绘当前进度
            walkAnimScale = null;
            if (walkAnimPoints && walkAnimPoints.length > 0) {
              drawWalkTo(walkAnimIndex || 0);
            } else {
              // 若尚未生成路径，仅清空以匹配新尺寸
              const container = walkCanvasEl.parentElement || walkCanvasEl;
              const rect = container.getBoundingClientRect();
              const width = Math.floor(rect.width || walkCanvasEl.clientWidth || 400);
              const height = Math.floor(rect.height || walkCanvasEl.clientHeight || 200);
              const ctx = walkCanvasEl.getContext("2d");
              ctx.clearRect(0, 0, width, height);
            }
          };
          window.addEventListener("resize", handleWalkResize);
        }

        // 分布比较事件
        const distributionBtns = document.querySelectorAll(".distribution-btn");
        distributionBtns.forEach((btn) => {
          btn.addEventListener("click", () => {
            // 更新按钮样式
            distributionBtns.forEach((b) => {
              b.classList.remove("active");
              b.classList.remove("bg-neon-green/20", "text-neon-green");
              b.classList.remove("bg-neon-blue/20", "text-neon-blue");
              b.classList.remove("bg-neon-purple/20", "text-neon-purple");
              b.classList.remove("bg-orange-500/20", "text-orange-500");
              b.classList.add("bg-gray-800", "text-gray-300");
            });

            // 获取分布类型
            const distribution = btn.getAttribute("data-distribution");
            btn.classList.add("active");
            btn.classList.remove("bg-gray-800", "text-gray-300");

            // 根据分布类型设置按钮颜色
            switch (distribution) {
              case "normal":
                btn.classList.add("bg-neon-green/20", "text-neon-green");
                break;
              case "poisson":
                btn.classList.add("bg-neon-blue/20", "text-neon-blue");
                break;
              case "binomial":
                btn.classList.add("bg-neon-purple/20", "text-neon-purple");
                break;
              case "exponential":
                btn.classList.add("bg-orange-500/20", "text-orange-500");
                break;
            }

            // 更新图表
            updateDistributionChart(distribution);
          });
        });

        // 相关性分析事件
        const correlationCoeffSlider =
          document.getElementById("correlation-coeff");
        const correlationCoeffValue = document.getElementById(
          "correlation-coeff-value"
        );

        correlationCoeffSlider.addEventListener("input", () => {
          const r = parseFloat(correlationCoeffSlider.value);
          correlationCoeffValue.textContent = r.toFixed(1);
          initCorrelationChart(r);
        });

        // 初始模拟
        rollDice(1000);
        calculatePi(1000);

        // 初始化生日悖论图表与默认值
        const defaultN = parseInt(
          document.getElementById("birthday-group")?.value || 23
        );
        const exactDefault = birthdayExact(defaultN);
        if (document.getElementById("birthday-exact")) {
          document.getElementById("birthday-exact").textContent =
            exactDefault.toFixed(6);
        }
        if (typeof Chart !== "undefined" && typeof initBirthdayChart === "function") {
          initBirthdayChart(exactDefault, exactDefault);
        }

        // 可选：初始化默认展示（轻量）
        if (document.getElementById("galton-chart")) {
          const rows = parseInt(
            document.getElementById("galton-rows")?.value || 10
          );
          const balls = parseInt(
            document.getElementById("galton-balls")?.value || 1000
          );
          const showTheory =
            !!document.getElementById("galton-show-theory")?.checked;
          initGaltonChart(rows, balls, showTheory);
        }
        drawGaltonBoard(
          parseInt(document.getElementById("galton-rows")?.value || 10)
        );
        if (document.getElementById("buffon-canvas")) {
          const trials = parseInt(
            document.getElementById("buffon-needles")?.value || 2000
          );
          buffonSimulate(trials);
        }
        if (document.getElementById("walk-canvas")) {
          const steps = parseInt(
            document.getElementById("walk-steps")?.value || 1000
          );
          const stepLen = parseInt(
            document.getElementById("walk-step-length")?.value || 3
          );
          runRandomWalk(steps, stepLen);
        }
      });
    </script>

    <!-- 工具箱组件 -->
    <script src="/static/js/toolbox.js"></script>

    <!-- LaTeX和Markdown渲染测试 -->
    <script>
      // 测试LaTeX和Markdown渲染功能
      function testLatexRendering() {
        console.log("开始测试LaTeX渲染功能");

        // 创建测试容器
        const testContainer = document.createElement("div");
        testContainer.id = "latex-test-container";
        testContainer.style.cssText =
          "position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 8px; z-index: 9999; max-width: 400px;";

        // 测试内容
        const testContent = `
          <h3>LaTeX渲染测试</h3>
          <p>行内公式: $E = mc^2$</p>
          <p>块级公式:</p>
          $$\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}$$
          <p>概率密度函数:</p>
          $$f(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$
          
          <h4>Markdown表格测试</h4>
          | 分布 | 均值 | 方差 |
          |------|------|------|
          | 正态分布 | μ | σ² |
          | 泊松分布 | λ | λ |
          
          <button onclick="closeTest()" style="margin-top: 10px; padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;">关闭测试</button>
        `;

        testContainer.innerHTML = testContent;
        document.body.appendChild(testContainer);

        // 使用全局渲染函数
        setTimeout(() => {
          if (window.renderLatexInElement) {
            console.log("使用全局LaTeX渲染函数");
            const success = window.renderLatexInElement(testContainer);
            if (success) {
              console.log("LaTeX渲染完成");
            } else {
              console.warn("LaTeX渲染失败或无内容");
            }
          } else {
            console.warn("全局LaTeX渲染函数未找到");
          }
        }, 100);
      }

      function closeTest() {
        const testContainer = document.getElementById("latex-test-container");
        if (testContainer) {
          testContainer.remove();
        }
      }

      // 聊天记录测试函数
      function testChatHistory() {
        console.log("开始测试聊天记录重复问题");

        if (window.probabilityToolbox) {
          // 模拟添加一些测试消息
          const testMessages = [
            { role: "user", content: "测试消息1：什么是正态分布？" },
            {
              role: "assistant",
              content: "正态分布是一种连续概率分布，具有钟形曲线特征。",
            },
            { role: "user", content: "测试消息2：如何计算标准差？" },
            {
              role: "assistant",
              content:
                "标准差 $\\sigma = \\sqrt{\\frac{\\sum(x_i - \\mu)^2}{n}}$",
            },
          ];

          // 清空现有聊天记录
          window.probabilityToolbox.clearChat();

          // 添加测试消息
          testMessages.forEach((msg) => {
            window.probabilityToolbox.addMessageToChat(msg.role, msg.content);
          });

          console.log(
            "当前聊天历史长度:",
            window.probabilityToolbox.chatHistory.length
          );

          // 模拟多次切换工具（这应该不会导致消息重复）
          setTimeout(() => {
            console.log(
              "第一次切换后聊天历史长度:",
              window.probabilityToolbox.chatHistory.length
            );
            window.probabilityToolbox.displayChatHistory();

            setTimeout(() => {
              console.log(
                "第二次切换后聊天历史长度:",
                window.probabilityToolbox.chatHistory.length
              );
              window.probabilityToolbox.displayChatHistory();

              setTimeout(() => {
                console.log(
                  "第三次切换后聊天历史长度:",
                  window.probabilityToolbox.chatHistory.length
                );

                // 检查DOM中的消息数量
                const chatMessages = document.getElementById("chat-messages");
                if (chatMessages) {
                  const messageCount =
                    chatMessages.querySelectorAll(".message").length;
                  console.log("DOM中的消息数量:", messageCount);
                  console.log("预期消息数量:", testMessages.length);

                  if (messageCount === testMessages.length) {
                    console.log("✅ 测试通过：聊天记录没有重复");
                    alert("✅ 测试通过：聊天记录没有重复");
                  } else {
                    console.log("❌ 测试失败：聊天记录出现重复");
                    alert("❌ 测试失败：聊天记录出现重复");
                  }
                }
              }, 500);
            }, 500);
          }, 500);
        } else {
          console.error("工具箱未初始化");
        }
      }
    </script>
  </body>
</html>
