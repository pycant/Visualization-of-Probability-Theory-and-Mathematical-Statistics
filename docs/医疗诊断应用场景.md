# 医疗诊断中的概率统计
> VSCode + Jupyter 内核运行，Markdown Preview Enhanced 秒变网页

---

## 0. 医疗前置知识 5 分钟速通（非概率部分）
> 本节 **零公式**，只看图 & 类比，把“医疗”变“常识”

| 概念 | 一句话类比 | 交互速览 |
|---|---|---|
| **敏感性** | 安检报警：真带危险品时响铃概率 | <details><summary>🛂 敏感滑杆</summary><input type="range" min="60" max="100" value="90" oninput="this.nextElementSibling.innerText='敏感性='+this.value+'%'">敏感性=90%</details> |
| **特异性** | 安检误报：没危险品却响铃概率 | <details><summary>🔕 特异按钮</summary><button onclick="alert('特异性低→大量误检，医疗资源浪费！')">点我弹出误检</button></details> |
| **ROC 曲线** | 高考分数线：分数越低，录取越多，但滥竽充数增加 | <details><summary>📈 ROC 开关</summary><label><input type="checkbox" onchange="document.getElementById('roc').innerText=this.checked?'曲线下方':'对角线'">显示 AUC</label> <span id="roc">对角线</span></details> |
| **交叉验证** | 模拟考：k 次月考取平均，防止偏题 | <details><summary>🔄 交叉按钮</summary><button onclick="this.innerText=['k=3','k=5','k=10'][Math.floor(Math.random()*3)]">选折</button></details> |
| **双盲试验** | 盲盒试吃：患者和医生都不知道吃的是药还是糖 | <details><summary>🍬 双盲滑杆</summary><input type="range" min="0" max="1" value="1" step="1" oninput="this.nextElementSibling.innerText=this.value==1?'双盲':'开放'">双盲</label> <span id="blind">双盲</span></details> |

---

## 1. 示例展示（Example Showcase）

**目标：** 30 秒看懂「敏感性 vs 特异性」谁更靠谱**

**核心交互：** 「乳腺癌筛查」双模型对决

功能：
1. 输入任意年龄 → 实时显示「敏感性概率」+「特异性概率」
2. 一键「模拟 10 万人」→ 看两种概率随样本逼近真相
3. 揭示真相：点击「真实标签」→ 显示命中次数 vs ROC 曲线
4. 小总结：敏感 = 抓病人，特异 = 抓好人

💡 小提示：把年龄拖到 70 岁，敏感性飙到 95%——这就是年龄的力量！

---

## 2. 理论探索（Theoretical Exploration）

**标题：** 3 步拆解医疗诊断中的概率——从试验到 ROC

---

### 知识点 1/3：敏感性 & 特异性 —— 二分类基石

<details>
<summary>📖 专业名词速查（点击展开）</summary>

- **敏感性（TPR）**：TP/(TP+FN)，真阳性率
- **特异性（TNR）**：TN/(TN+FP)，真阴性率
- **混淆矩阵**：TP/TN/FP/FN 四象限
</details>

#### ① 逐步推导（点击展开）
<details>
<summary>🔍 逐步推导（点击展开）</summary>

步骤 1：写混淆矩阵  
|        | 真实阳 | 真实阴 |
|--------|--------|--------|
| 预测阳 | TP     | FP     |
| 预测阴 | FN     | TN     |

步骤 2：定义指标  
TPR = TP / (TP+FN)  
TNR = TN / (TN+FP)

步骤 3：求 95% 置信区间  
TPR ± 1.96√(TPR(1-TPR)/n_pos)
</details>

#### ② 趣味性可视化
- 滑块调阈值 → 实时画 TPR vs TNR，看权衡曲线
- 点击「加速到阈值=0.1」→ 峰值变针尖，肉眼验证「敏感性↑特异性↓」

#### ③ 代码（Jupyter 内核直接跑）
```python
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve

# 模拟数据
rng = np.random.default_rng(42)
n = 10000
age = rng.integers(30, 80, n)
prob = 1 / (1 + np.exp(-0.1*(age-50)))        # 逻辑回归概率
y_true = rng.binomial(1, prob)
y_score = prob + rng.normal(0, 0.1, n)
fpr, tpr, thr = roc_curve(y_true, y_score)

plt.figure(figsize=(4,4))
plt.plot(fpr, tpr, color='#FF6B6B', label='ROC')
plt.plot([0,1], [0,1], 'k--', label='随机')
plt.xlabel('1-特异性'); plt.ylabel('敏感性'); plt.title('ROC 曲线'); plt.legend(); plt.show()
```

---

### 知识点 2/3：ROC & AUC —— 模型比较利器

<details>
<summary>📖 专业名词速查（点击展开）</summary>

- **AUC**：曲线下面积，1=完美，0.5=随机
- **Youden 指数**：TPR - FPR，最大处为最优阈值
- **PR 曲线**：Precision vs Recall，适合不平衡数据
</details>

#### ① 逐步推导（点击展开）
<details>
<summary>🔍 逐步推导（点击展开）</summary>

步骤 1：写 TPR & FPR  
TPR = TP/(TP+FN), FPR = FP/(FP+TN)

步骤 2：积分求 AUC  
AUC = ∫₀¹ TPR(FPR) dFPR

步骤 3：置信区间  
SE = √(AUC(1-AUC) + (n_pos-1)(Q1-AUC²) + (n_neg-1)(Q2-AUC²)) / (n_pos n_neg)  
Q1 = AUC/(2-AUC), Q2 = 2AUC²/(1+AUC)
</details>

#### ② 趣味性可视化
- 滑块调类别权重 → 实时看 AUC 变化
- 点击「重复 1000 次」→ 画 AUC 分布，看 95% CI

#### ③ 代码（Jupyter 内核直接跑）
```python
from sklearn.metrics import roc_auc_score
import scipy.stats as st

auc = roc_auc_score(y_true, y_score)
n1, n2 = y_true.sum(), (1-y_true).sum()
Q1 = auc/(2-auc)
Q2 = 2*auc**2/(1+auc)
se = np.sqrt(auc*(1-auc) + (n1-1)*(Q1-auc**2) + (n2-1)*(Q2-auc**2)) / (n1*n2)
ci = st.norm.interval(0.95, loc=auc, scale=se)
print(f'AUC = {auc:.3f}, 95% CI = [{ci[0]:.3f}, {ci[1]:.3f}]')
```

---

### 知识点 3/3：临床试验与假设检验 —— p 值必须可信

<details>
<summary>📖 专业名词速查（点击展开）</summary>

- **p 值**：原假设成立时，观察到或更极端结果的概率
- **显著性水平 α**：通常 0.05，p < α 拒绝原假设
- **功效**：1-β，正确检出差异的概率
</details>

#### ① 逐步推导（点击展开）
<details>
<summary>🔍 逐步推导（点击展开）</summary>

步骤 1：写假设  
H₀: μ_treatment = μ_control  
H₁: μ_treatment ≠ μ_control

步骤 2：计算 t 统计量  
t = (x̄₁ - x̄₂) / √(s₁²/n₁ + s₂²/n₂)

步骤 3：求 p 值  
p = 2(1 - T_{df}(|t|))
</details>

#### ② 趣味性可视化
- 滑块调样本量 → 实时看功效曲线，看 n↑功效↑
- 点击「加速到 n=1000」→ 峰值变针尖，肉眼验证「功效→1」

#### ③ 代码（Jupyter 内核直接跑）
```python
from scipy.stats import ttest_ind

# 模拟两组
n1, n2 = 100, 100
rng = np.random.default_rng(42)
ctrl = rng.normal(50, 10, n1)
treat = rng.normal(53, 10, n2)   # 真实差 3
t, p = ttest_ind(treat, ctrl)
print(f't = {t:.2f}, p = {p:.3f}')
if p < 0.05:
    print('✅ 拒绝 H₀，药物有效')
else:
    print('❌ 无法拒绝 H₀')
```

---

## 3. 实践应用（Practical Applications）

> 每个应用 =「分步引导 + 核心知识点 + 小测试」  
> 必须逐步点击「已完成」才能解锁下一步；全部完成后弹出「知识点考察」。

---

### 应用一：乳腺癌筛查仪表盘 —— 敏感性·特异性·ROC

#### 第①步：上传数据
功能：
1. 拖拽 CSV（年龄+真实标签+模型分数）→ 自动计算混淆矩阵
2. 核心知识点卡片：「敏感性=抓病人，特异性=抓好人」
3. 点击「我已了解」→ 解锁第②步

#### 第②步：选择阈值
功能：
1. 滑块调阈值 ∈[0,1] → 实时更新 TPR/TNR
2. 实时显示「Youden 指数」圆点
3. 点击「阈值已选定」→ 解锁第③步

#### 第③步：计算 ROC
功能：
1. 点击「计算 ROC」→ 进度条跑完，保存 AUC
2. 实时显示「AUC」「95% CI」
3. 点击「计算完成」→ 解锁第④步

#### 第④步：对比真实
功能：
1. 输入真实年龄 → 实时显示敏感性 vs 特异性
2. 点击「真实标签」→ 显示命中 vs 未命中
3. 对比两种模型 AUC
4. 点击「测试完成」→ 弹出「知识点考察」

<!-- === 应用通关网关=== -->
<div class="app-gate" data-app="1">
  <button class="exam-btn">开始知识点考察（3 题）</button>
  <div class="exam-paper" style="display:none;">
    <ol>
      <li>单选：敏感性计算公式？
        <br/><label><input type="radio" name="q1" value="A"> A. TN/(TN+FP)</label>
        <br/><label><input type="radio" name="q1" value="B"> B. TP/(TP+FN)</label>
        <br/><label><input type="radio" name="q1" value="C"> C. TP/(TP+FP)</label>
      </li>
      <li>判断：AUC=1 表示完美诊断。（√）</li>
      <li>单选：p < 0.05 表示？
        <br/><label><input type="radio" name="q3" value="A"> A. 原假设成立</label>
        <br/><label><input type="radio" name="q3" value="B"> B. 拒绝原假设</label>
        <br/><label><input type="radio" name="q3" value="C"> C. 功效不足</label>
      </li>
    </ol>
  <button class="submit-exam">提交</button>
  <div class="exam-result" style="display:none;"></div>
</div>
</div>

<script>
/* ========= 应用通关逻辑 ========= */
document.querySelector('.exam-btn').addEventListener('click',e=>{
  document.querySelector('.exam-paper').style.display='block';
});
document.querySelector('.submit-exam').addEventListener('click',e=>{
  const ans=['B','√','B'];
  let score=0;
  ans.forEach((a,i)=>{
    const user=document.querySelector(`input[name="q${i+1}"]:checked`)?.value;
    if(user===a) score++;
  });
  const pass=score>=2;
  document.querySelector('.exam-result').innerHTML=
    `${pass?'✅ 通关':'❌ 未通关'} 得分：${score}/3  
     <button onclick="location.reload()">${pass?'进入下一应用':'重考'}</button>`;
  document.querySelector('.exam-result').style.display='block';
});
</script>

---

## 4. 章节练习（Chapter Exercises）

**Level 3 分析与设计**  
功能：  
1. 设计一个「估算 90% 功效所需样本量」的方案，说明如何选 α、β、效应大小  
2. 如果数据不平衡（阳性<5%），给出两条提升 AUC 稳健性的策略（提示：重采样、代价敏感）  

---

### 1. 估算样本量方案（点击展开）
<details>
<summary>🎯 实验设计（点击展开）</summary>

#### ① 理论关系  
功效 = 1-β，双侧检验：  
n = 2(z_{1-α/2} + z_{1-β})² σ² / δ²  

#### ② 参数选择  
- α=0.05, β=0.10 (90% 功效)  
- 效应大小 δ=3 分，σ=10 分  

#### ③ 代码
```python
from scipy.stats import norm
alpha, beta = 0.05, 0.10
delta, sigma = 3, 10
z_a = norm.ppf(1-alpha/2)
z_b = norm.ppf(1-beta)
n_per_group = 2 * (z_a + z_b)**2 * sigma**2 / delta**2
print(f'每组需 {int(np.ceil(n_per_group))} 例')
```
</details>

---

### 2. 不平衡数据 AUC 提升策略（点击展开）
<details>
<summary>📊 策略详情（点击展开）</summary>

| 策略 | 核心思想 | 公式/代码 |
|---|---|---|
| **SMOTE 重采样** | 合成少数类样本，平衡分布 | from imblearn.over_sampling import SMOTE |
| **代价敏感学习** | 误分类权重↑，FP 罚分↓ | scale_pos_weight = n_neg/n_pos |
| **阈值移动** | 最优阈值≠0.5，选 Youden 最大 | thr* = argmax(TPR-TFR) |

```python
# 代价敏感示例
from sklearn.ensemble import RandomForestClassifier
clf = RandomForestClassifier(class_weight='balanced')
clf.fit(X, y)
```
</details>

---

## 5. 网页内容设计概要（UI/UX）

- **顶部：** 标题「医疗诊断中的概率统计」+ 一句 slogan「用概率守护生命」
- **左侧：** 固定导航栏，直接链接到【速通】【示例】【理论】【应用】【练习】
- **布局：**  
  - 【速通】部分：5 张折叠卡片，首屏 60%，右侧留空给「听诊器猫🐱」GIF  
  - 【示例】部分：双滑杆占 70%，按钮悬浮底部，不打断动画  
  - 【理论】部分：3 张可折叠卡片，每卡右侧留 15% 给「AI 助手」与「解锁按钮」  
  - 【应用】部分：分步卡片，必须点击「已完成」才能解锁；完成后弹出「知识点考察」  
  - 【练习】部分：Level3 默认折叠，答题后展开解析与回链
- **视觉：** 主色 #FF6B6B（生命红），辅助灰 #E0E0E0，所有轨迹默认半透明 0.6

---

## 6. 附：完整 Level3 答题代码（Jupyter 一键运行）

```python
# 样本量估算
from scipy.stats import norm
alpha, beta = 0.05, 0.10
delta, sigma = 3, 10
z_a = norm.ppf(1-alpha/2)
z_b = norm.ppf(1-beta)
n_per_group = 2 * (z_a + z_b)**2 * sigma**2 / delta**2
print(f'每组需 {int(np.ceil(n_per_group))} 例')

# 代价敏感 AUC
from sklearn.ensemble import RandomForestClassifier
clf = RandomForestClassifier(class_weight='balanced')
clf.fit(X, y)          # X,y 已定义
auc_bal = roc_auc_score(y, clf.predict_proba(X)[:,1])
print(f'代价敏感 AUC = {auc_bal:.3f}')
```
```