
### **应用一：【军事分析】寻找遗失的炮弹 - 交互与技术设计**

#### **1. 初始条件与参数设置**

为了让用户理解参数的影响，应提供调整选项：

*   **真实炮弹位置 (μ_x, μ_y):** 系统内部随机生成，但初始对用户隐藏。可在演示成功后“揭示真相”。
*   **声纳精度 (测量误差标准差 σ):** 用户可滑动调整（例如：0.5 km 到 5.0 km）。这模拟了不同品质的声纳设备。
*   **置信水平 (1-α):** 下拉菜单选择（90%, 95%, 99%）。
*   **样本量 (n):** 通过“投放1个”/“投放10个”按钮控制。

#### **2. 交互效果与流程**

1.  **初始化:** 页面加载后，显示一片蓝色网格表示的海域，中心为 `(0,0)`。右侧是参数面板和数据面板。
2.  **单次投放:**
    *   用户点击“投放1个浮标”。
    *   **动画:** 一艘小船图标从随机位置驶入画面，投下一个浮标图标。浮标入水处生成一个探测点 `(x_i, y_i)`。
    *   **计算:** 系统根据预设的 `(μ_x, μ_y)` 和用户设定的 `σ`，按 `(x_i, y_i) ~ N(μ_x, σ²)`, `N(μ_y, σ²)` 生成该点的坐标。
    *   **可视化:** 新点被添加到散点图上。点估计 `(X̄, Ȳ)` 立刻更新，一个十字准心移动到新位置。置信矩形根据新的 `n`, `S_x`, `S_y` 和选择的置信水平动态重新计算并绘制。
3.  **批量投放:**
    *   用户点击“投放10个浮标”，快速生成10个数据点。
    *   **动画:** 可以快速连续播放10次投放动画，或用一个进度条表示计算过程。
    *   **可视化:** 散点图密集更新。用户将清晰看到点估计 `(X̄, Ȳ)` 快速收敛至一个稳定点，同时置信矩形迅速缩小。
4.  **揭示真相:**
    *   提供一个“显示真实位置”按钮。
    *   点击后，一个醒目的（如红色X）标记出现在地图上，代表真实的 `(μ_x, μ_y)`。
    *   **教学时刻:** 用户可立即检查真实位置是否落在最终的置信矩形内（95%的情况下应该会）。UI可以给出“预测成功！”或“遗憾，本次预测未覆盖真实点（这本身就是5%的小概率事件）”的反馈。

#### **3. 技术设计说明**

*   **前端:** HTML5, CSS3, JavaScript (ES6+)
*   **可视化库:** **Chart.js** 或 **D3.js**。Chart.js更简单，适合基础散点图和矩形；D3.js更强大，可以定制更复杂的海地图和动画。
*   **逻辑实现:**
    *   **数据生成:** 使用 `Box-Muller变换` 或库函数（如 `random.nextGaussian()`）生成正态分布随机数。
    *   **统计计算:**
        ```javascript
        // 假设 pointsX 和 pointsY 是存储所有样本点的数组
        const n = pointsX.length;
        const meanX = pointsX.reduce((a, b) => a + b, 0) / n;
        const meanY = pointsY.reduce((a, b) => a + b, 0) / n;

        const stdX = Math.sqrt(pointsX.reduce((sq, x) => sq + Math.pow(x - meanX, 2), 0) / (n - 1));
        const stdY = Math.sqrt(pointsY.reduce((sq, y) => sq + Math.pow(y - meanY, 2), 0) / (n - 1));

        // 获取t分布临界值（需预定义t值表或使用近似公式/库）
        const tCritical = getTCriticalValue(confidenceLevel, n - 1);

        const marginOfErrorX = tCritical * (stdX / Math.sqrt(n));
        const marginOfErrorY = tCritical * (stdY / Math.sqrt(n));

        const confidenceIntervalX = [meanX - marginOfErrorX, meanX + marginOfErrorX];
        const confidenceIntervalY = [meanY - marginOfErrorY, meanY + marginOfErrorY];
        ```
    *   **绘图:** 根据 `confidenceIntervalX` 和 `confidenceIntervalY` 的值，在Canvas或SVG上绘制矩形。

---

### **应用二：【游戏策略】《我的世界》末地之门定位法 - 交互与技术设计**

#### **1. 初始条件与参数设置**

此示例更为复杂，需结合论文中的先验概率。

*   **真实末地之门位置 (μ_x, μ_z):** 系统在预定义的“世界”中随机生成一个位置（符合强hold环分布）。
*   **玩家测量水平 (σ):** 核心参数。提供预设选项：
    *   “新手” (σ = 0.3°)
    *   “熟练” (σ = 0.1°，论文推荐值)
    *   “专家” (σ = 0.03°)
    *   “机器” (σ = 0.01°)
    *   也可提供滑动条自定义。
*   **玩家位置 (P_x, P_z):** 可固定在地图中心，或允许用户在小范围内移动，增加趣味性。
*   **先验分布 (P(s_i = g_k)):** 这是算法的核心。**无需用户设置，但需系统实现**。
    *   **简化实现:** 按照论文，强hold只生成在特定半径的环上。我们可以预先计算好一个二维数组，表示每个区块 `(chunkX, chunkZ)` 成为强hold的先验概率。这个概率在环上较高，环外为0。
    *   **高级实现（可选）：** 模拟论文中描述的“ snapping ”过程，动态生成先验图。

#### **2. 交互效果与流程**

1.  **初始化:** 显示一个《我的世界》风格的网格地图（以区块为单位）。地图上根据先验概率，用极淡的颜色暗示强hold可能出现的环状区域。
2.  **单次投掷:**
    *   用户点击“投掷末影之眼”。
    *   **动画:** 播放末影之眼从玩家位置飞出的动画。眼睛飞至屏幕边缘后，在其**真实位置 `(μ_x, μ_z)`** 附近（根据 `σ` 正态分布随机偏移）生成一个落点 `(x_i, z_i)`。
    *   **计算:** 系统根据所有投掷数据 `α_n` 和每个网格点 `g_k` 相对于每次投掷时玩家的角度 `γ_{n,g_k}`，使用贝叶斯公式更新后验概率分布 `P(s_i = g_k | α)`。
    *   **可视化:**
        *   所有历史落点以末影之眼图标形式显示。
        *   后验概率分布用**热力图**覆盖在地图上。颜色越暖（红/黄），概率越高。
        *   当前最可能的点估计（后验概率最大的区块）用一个**信标光柱**动画标记。
3.  **概率显示:**
    *   鼠标悬停在任何区块上，Tooltip显示该区块承载末地之门的计算后概率（例如“15.7%”）。
    *   数据面板显示“当前最佳预测区块”的坐标和概率。
4.  **揭示真相:**
    *   点击“显示末地之门”按钮，真实位置以**下界传送门**的图标显示。
    *   对比热力图的最热点，验证预测的成功与否。

#### **3. 技术设计说明**

*   **前端:** HTML5, CSS3, JavaScript (ES6+)
*   **可视化库:** **D3.js** 几乎是必须的，用于绘制热力图和处理地图交互。
*   **逻辑实现（简化版）:**
    1.  **预处理:**
        *   定义一个有限的地图世界（如 ±2000 区块）。
        *   根据游戏规则，定义强hold环的半径 `a_k, b_k` 和数量 `n_k`。
        *   计算一个先验概率矩阵 `prior[k]`，环上的区块概率均匀分布，环外概率为0。
    2.  **投掷处理:**
        ```javascript
        // 假设 throws 是存储所有投掷角度（α_n）和玩家当时位置（P_n）的数组
        function updatePosterior(throws) {
          // 初始化后验概率，等于先验概率
          let posterior = [...prior];

          // 对地图上的每个候选区块 g_k
          for (let chunk of allChunks) {
            let likelihood = 1.0;
            // 计算当前投掷数据下，该区块的似然
            for (let t of throws) {
              let trueAngle = calculateAngle(t.playerPos, chunk); // 计算真实角度γ
              let measuredAngle = t.measuredAngle; // 这是用户投掷记录的角度α_n
              // 计算单个测量的似然 (正态分布PDF)
              likelihood *= (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow(measuredAngle - trueAngle, 2) / (2 * sigma * sigma));
            }
            // 根据贝叶斯定理更新后验（未归一化）
            posterior[chunk.index] = prior[chunk.index] * likelihood;
          }

          // 归一化后验概率，使其总和为1
          const sum = posterior.reduce((a, b) => a + b, 0);
          posterior = posterior.map(p => p / sum);

          return posterior;
        }
        ```
    3.  **性能优化:** 计算整个地图的后验概率非常耗时。必须将计算限制在强hold环附近的有效区域内，而非整个地图。可以使用 Web Worker 在后台线程进行密集计算，防止页面卡顿。

### **总结**

这两个实例的设计从简单的频率学派置信区间到复杂的贝叶斯统计，形成了完美的梯度。

*   **炮弹搜寻** 展示了**经典统计推断**的核心思想，实现相对简单，交互直观。
*   **末地定位** 展示了**现代贝叶斯方法**的强大能力，它结合先验知识（游戏生成规则）和观测数据，提供更精确、更直观（概率形式）的推断结果，虽然实现复杂度更高。

将它们并置，可以让初学者清晰地感受到统计学的发展脉络和不同思想流派的应用场景与优势。请根据您的项目进度和团队技术储备，决定是先实现“炮弹”实例，还是直接挑战更精彩的“末地”实例。