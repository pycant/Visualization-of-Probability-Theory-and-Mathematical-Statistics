# 宇宙学中的概率统计
> VSCode + Jupyter 内核运行，Markdown Preview Enhanced 秒变网页

---

## 0. 宇宙学前置知识 5 分钟速通（非概率部分）
> 本节 **零公式**，只看图 & 类比，把“宇宙”变“常识”

| 概念 | 一句话类比 | 交互速览 |
|---|---|---|
| **暗物质** | 微信步数：看不见，但排行榜总靠前 | <details><summary>🌌 暗物质滑杆</summary><input type="range" min="10" max="50" value="27" oninput="this.nextElementSibling.innerText='Ω_dm = '+this.value+'%'">Ω_dm = 27%</details> |
| **宇宙膨胀** | 葡萄干面包：烤箱一热，葡萄越来越远 | <details><summary>🍞 膨胀按钮</summary><button onclick="alert('哈勃定律：离我越远，跑越快！')">点我弹出哈勃流</button></details> |
| **CMB** | 宇宙 baby 照：38 万岁时的自拍，温度涨落≈10⁻⁵ | <details><summary>📸 CMB 开关</summary><label><input type="checkbox" onchange="document.getElementById('cmb').innerText=this.checked?'温度涨落开启':'均匀宇宙'">显示涨落</label> <span id="cmb">均匀宇宙</span></details> |
| **结构形成** | 彩票摇号：小涨落放大→大奖（星系） | <details><summary>🎰 结构按钮</summary><button onclick="this.innerText=['均匀','小星系','大星系团'][Math.floor(Math.random()*3)]">摇号</button></details> |
| **暗能量** | 加班工资：越晚越给钱，推动膨胀加速 | <details><summary>💸 暗能量滑杆</summary><input type="range" min="60" max="80" value="68" oninput="this.nextElementSibling.innerText='Ω_Λ = '+this.value+'%'">Ω_Λ = 68%</details> |

---

## 1. 示例展示（Example Showcase）

**目标：** 30 秒看懂「高斯随机场 vs 泊松分布」谁更靠谱**

**核心交互：** 「暗物质粒子」双模型对决

功能：
1. 输入任意 3D 坐标 (x,y,z) → 实时显示「高斯密度涨落」+「泊松粒子数」
2. 一键「生成 1000 粒子」→ 看两种概率随样本逼近真相
3. 揭示真相：点击「真实模拟」→ 显示功率谱 vs 概率校准图
4. 小总结：高斯 = 连续场，泊松 = 离散计数

💡 小提示：把「尺度」拖到 100 Mpc，高斯方差飙升——这就是结构种子！

---

## 2. 理论探索（Theoretical Exploration）

**标题：** 3 步拆解宇宙学中的概率——从随机场到功率谱

---

### 知识点 1/3：高斯随机场与密度涨落

<details>
<summary>📖 专业名词速查（点击展开）</summary>

- **δ(x) = (ρ(x)-ρ̄)/ρ̄**：密度对比场，均值 0
- **功率谱 P(k)**：涨落振幅随波数 k 的分布
- **高斯性**：δ(x) 服从多元正态，完全由 P(k) 决定
</details>

#### ① 逐步推导（点击展开）
<details>
<summary>🔍 逐步推导（点击展开）</summary>

步骤 1：写傅里叶展开  
δ(x) = Σ δ_k e^{i k·x}

步骤 2：定义功率谱  
<δ_k δ_k'* > = (2π)³ P(k) δ_D(k-k')

步骤 3：生成实现  
δ_k ∼ N(0, P(k)) → 逆 FFT 得 δ(x)
</details>

#### ② 趣味性可视化
- 滑块调 n 侧 → 实时画 δ(x) 地图，看峰值随 n 变密
- 点击「加速到 n=512」→ 肉眼验证「高斯性」

#### ③ 代码（Jupyter 内核直接跑）
```python
import numpy as np
import matplotlib.pyplot as plt

n = 128
L = 200  # Mpc
k = np.fft.fftfreq(n, d=L/n) * 2*np.pi
kgrid = np.sqrt(k[:,None]**2 + k[None,:]**2)
P = lambda k: 1e4 * k**(-3) * np.exp(-k/10)  # 近似 ΛCDM

# 生成高斯随机场
rng = np.random.default_rng(42)
delta_k = rng.normal(0, 1, (n, n)) * np.sqrt(P(kgrid) / (L/n)**2)
delta = np.fft.ifft2(delta_k).real

plt.figure(figsize=(4,4))
plt.imshow(delta, cmap='RdBu', origin='lower')
plt.colorbar(label='δ(x)'); plt.title('高斯密度涨落'); plt.show()
```

---

### 知识点 2/3：泊松分布与粒子采样

<details>
<summary>📖 专业名词速查（点击展开）</summary>

- **泊松过程**：单位体积期望粒子数 λ
- **离散采样**：按 δ(x) 调制 λ(x) = λ̄ (1+δ(x))
- **shot noise**：泊松散粒噪声，功率谱 + 1/λ̄
</details>

#### ① 逐步推导（点击展开）
<details>
<summary>🔍 逐步推导（点击展开）</summary>

步骤 1：写期望粒子数  
N_cell = λ̄ V_cell (1+δ(x))

步骤 2：采样粒子数  
N ∼ Poisson(N_cell)

步骤 3：功率谱估计  
P̂(k) = |δ_k|^2 / V - 1/λ̄
</details>

#### ② 趣味性可视化
- 滑块调 λ̄ → 实时看粒子地图，shot noise 随 λ̄ 降低
- 点击「无限密度」→ 泊松→高斯极限

#### ③ 代码（Jupyter 内核直接跑）
```python
from scipy.stats import poisson

lambda_bar = 0.5  # Mpc⁻³
dV = (L/n)**3
lambda_cell = lambda_bar * (1 + delta) * dV
N_map = poisson.rvs(lambda_cell, random_state=42)

plt.figure(figsize=(4,4))
plt.imshow(N_map, cmap='viridis', origin='lower')
plt.colorbar(label='粒子数'); plt.title('泊松采样'); plt.show()
```

---

### 知识点 3/3：功率谱估计与误差棒

<details>
<summary>📖 专业名词速查（点击展开）</summary>

- **Band power**：k -bin 内平均 P(k)
- **Cosmic variance**：样本方差，~ 1/f_sky
- **Shot noise**：泊松噪声，~ 1/λ̄
</details>

#### ① 逐步推导（点击展开）
<details>
<summary>🔍 逐步推导（点击展开）</summary>

步骤 1：bin 平均  
P_b = Σ_{k∈bin} P̂(k) / N_modes

步骤 2：误差棒  
σ_b = √(2/(2l+1)/f_sky) (P_b + 1/λ̄)
</details>

#### ② 趣味性可视化
- 一键「重复 100 次」→ 实时画功率谱+误差带
- 点击「导出 CSV」→ 自己算 χ² 拟合

#### ③ 代码（Jupyter 内核直接跑）
```python
# 功率谱估计
delta_flat = delta.flatten()
k_flat = kgrid.flatten()
k_bins = np.logspace(-1, 1, 15)
kb_cen = 0.5*(k_bins[1:]+k_bins[:-1])
P_k, _, _ = stats.binned_statistic(k_flat, np.abs(np.fft.fft2(delta))**2/(L/n)**2, statistic='mean', bins=k_bins)
sigma_p = np.sqrt(2/(2*kb_cen+1)) * (P_k + 1/lambda_bar)

plt.figure(figsize=(6,4])
plt.errorbar(kb_cen, P_k, yerr=sigma_p, fmt='o', color='#FF6B6B', label='P(k)')
plt.loglog(); plt.xlabel('k [Mpc⁻¹]'); plt.ylabel('P(k)'); plt.title('功率谱+误差'); plt.show()
```

---

## 3. 实践应用（Practical Applications）

> 每个应用 =「分步引导 + 核心知识点 + 小测试」  
> 必须逐步点击「已完成」才能解锁下一步；全部完成后弹出「知识点考察」。

---

### 应用一：宇宙结构生成器 —— 高斯+泊松双模型

#### 第①步：进入宇宙
功能：
1. 动画：CMB 地图闪烁「结构？」→ 用户犹豫
2. 核心知识点卡片：「高斯 = 连续场，泊松 = 离散粒子」
3. 点击「我已了解」→ 解锁第②步

#### 第②步：选择模型
功能：
1. 单选按钮：「仅高斯」「高斯+泊松」「仅泊松」
2. 实时显示「shot noise」滑杆（仅泊松可见）
3. 点击「模型已选定」→ 解锁第③步

#### 第③步：生成结构
功能：
1. 点击「生成 1000 粒子」→ 进度条跑完，地图保存
2. 实时显示「功率谱」「粒子数」
3. 点击「生成完成」→ 解锁第④步

#### 第④步：对比真实
功能：
1. 输入 SDSS 数据路径 → 实时显示观测功率谱
2. 点击「真实测量」→ 画 χ² 拟合
3. 对比两种模型 χ²/dof
4. 点击「测试完成」→ 弹出「知识点考察」

<!-- === 应用通关网关=== -->
<div class="app-gate" data-app="1">
  <button class="exam-btn">开始知识点考察（3 题）</button>
  <div class="exam-paper" style="display:none;">
    <ol>
      <li>单选：高斯随机场完全由什么决定？
        <br/><label><input type="radio" name="q1" value="A"> A. 相位</label>
        <br/><label><input type="radio" name="q1" value="B"> B. 功率谱 P(k)</label>
        <br/><label><input type="radio" name="q1" value="C"> C. 粒子数</label>
      </li>
      <li>判断：泊松 shot noise 随密度增加而减小。（√）</li>
      <li>单选：Cosmic variance 与什么成反比？
        <br/><label><input type="radio" name="q3" value="A"> A. f_sky</label>
        <br/><label><input type="radio" name="q3" value="B"> B. λ̄</label>
        <br/><label><input type="radio" name="q3" value="C"> C. k</label>
      </li>
    </ol>
  <button class="submit-exam">提交</button>
  <div class="exam-result" style="display:none;"></div>
</div>
</div>

<script>
/* ========= 应用通关逻辑 ========= */
document.querySelector('.exam-btn').addEventListener('click',e=>{
  document.querySelector('.exam-paper').style.display='block';
});
document.querySelector('.submit-exam').addEventListener('click',e=>{
  const ans=['B','√','A'];
  let score=0;
  ans.forEach((a,i)=>{
    const user=document.querySelector(`input[name="q${i+1}"]:checked`)?.value;
    if(user===a) score++;
  });
  const pass=score>=2;
  document.querySelector('.exam-result').innerHTML=
    `${pass?'✅ 通关':'❌ 未通关'} 得分：${score}/3  
     <button onclick="location.reload()">${pass?'进入下一应用':'重考'}</button>`;
  document.querySelector('.exam-result').style.display='block';
});
</script>

---

## 4. 章节练习（Chapter Exercises）

**Level 3 分析与设计**  
功能：  
1. 设计一个「估算暗物质功率谱振幅 A_s」的抽样方案，说明如何选 k 范围、如何控制 cosmic variance  
2. 如果观测仅覆盖 10% 天区，给出两条矫正 f_sky 的策略（提示：主成分分析、权重矩阵）  

---

### 1. 估算 A_s 抽样方案（点击展开）
<details>
<summary>🎯 实验设计（点击展开）</summary>

#### ① 理论关系  
ΛCDM 标量谱：P(k) = A_s (k/k_pivot)^{n_s-1}  
取 k_pivot = 0.05 Mpc⁻¹，n_s ≈ 0.965  

#### ② k 范围选择  
- 线性区 0.01 ≤ k ≤ 0.2 Mpc⁻¹，避免非线性污染  
- 需 N_modes ≳ 100 ⇒ Δk ≈ 0.001 Mpc⁻¹  

#### ③ Cosmic variance 控制  
- 增大 sky coverage 至 70%  
- 采用交叉相关（CMB×透镜）压制方差  

#### ④ 代码
```python
k_lin = np.logspace(-2, -0.7, 50)
A_s_true = 2.1e-9
n_s = 0.965
P_true = A_s_true * (k_lin/0.05)**(n_s-1)
# 模拟观测
f_sky = 0.7
N_modes = 2 * (2*np.arange(1, 51)+1) * f_sky
sigma_P = P_true * np.sqrt(2/N_modes)
P_obs = P_true + rng.normal(0, sigma_P)
plt.errorbar(k_lin, P_obs, yerr=sigma_P, fmt='o'); plt.loglog(); plt.show()
```
</details>

---

### 2. f_sky 矫正策略（点击展开）
<details>
<summary>📊 策略详情（点击展开）</summary>

| 策略 | 核心思想 | 公式/代码 |
|---|---|---|
| **主成分分析 (PCA)** | 压缩模式，降维去噪 | C_ℓ = ∑_i λ_i e_i e_i^T |
| **权重矩阵 (Wiener)** | 信噪比加权 | P̂_w = (F^T N^{-1} F)^{-1} F^T N^{-1} d |
| **Mode mixing 矫正** | 伪谐波耦合矩阵 | M_{ℓℓ'} = ∫ dΩ Y_ℓ Y_ℓ' f_sky |

```python
# Wiener 滤波示例
Signal = P_true
Noise  = sigma_P**2
Wiener = Signal / (Signal + Noise)
P_wiener = Wiener * P_obs
print(f'Wiener 后误差下降 {(1-np.mean(Wiener))*100:.1f}%')
```
</details>

---

## 5. 网页内容设计概要（UI/UX）

- **顶部：** 标题「宇宙学中的概率统计」+ 一句 slogan「用概率看懂宇宙」
- **左侧：** 固定导航栏，直接链接到【速通】【示例】【理论】【应用】【练习】
- **布局：**  
  - 【速通】部分：5 张折叠卡片，首屏 60%，右侧留空给「银河猫🐱」GIF  
  - 【示例】部分：3D 滑杆占 70%，按钮悬浮底部，不打断动画  
  - 【理论】部分：3 张可折叠卡片，每卡右侧留 15% 给「AI 助手」与「解锁按钮」  
  - 【应用】部分：分步卡片，必须点击「已完成」才能解锁；完成后弹出「知识点考察」  
  - 【练习】部分：Level3 默认折叠，答题后展开解析与回链
- **视觉：** 主色 #4ECDC4（银河青），辅助灰 #E0E0E0，所有轨迹默认半透明 0.6

---

## 6. 附：完整 Level3 答题代码（Jupyter 一键运行）

```python
# A_s 估算
k_lin = np.logspace(-2, -0.7, 50)
A_s_true = 2.1e-9
n_s = 0.965
P_true = A_s_true * (k_lin/0.05)**(n_s-1)
f_sky = 0.7
N_modes = 2 * (2*np.arange(1, 51)+1) * f_sky
sigma_P = P_true * np.sqrt(2/N_modes)
P_obs = P_true + rng.normal(0, sigma_P)

# Wiener 滤波
Signal = P_true
Noise  = sigma_P**2
Wiener = Signal / (Signal + Noise)
P_wiener = Wiener * P_obs
print(f'Wiener 后误差下降 {(1-np.mean(Wiener))*100:.1f}%')
```
```