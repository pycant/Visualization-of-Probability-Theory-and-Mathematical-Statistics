<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>等高线修复测试</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
        }
        
        #bg-noise {
            width: 100%;
            height: 400px;
            border: 1px solid #444;
            border-radius: 4px;
        }
        
        .controls {
            margin: 20px 0;
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        label {
            display: inline-block;
            width: 150px;
            margin-right: 10px;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        .status {
            margin: 10px 0;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        .info {
            color: #00f3ff;
        }
        
        .warning {
            color: #ffc107;
        }
        
        .error {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>第三章背景等高线修复测试</h1>
        
        <div class="test-section">
            <h2>修复前后对比</h2>
            <p>修复内容：</p>
            <ul>
                <li>改进了marching squares算法的线段连接逻辑</li>
                <li>添加了等高线平滑处理</li>
                <li>优化了噪声生成参数（多层噪声叠加）</li>
                <li>调整了等高线阈值和渲染参数</li>
                <li>减少了等高线数量，提高了视觉质量</li>
            </ul>
        </div>
        
        <div class="test-section">
            <h2>背景等高线效果</h2>
            <canvas id="bg-noise"></canvas>
            
            <div class="controls">
                <div class="control-group">
                    <label>动画速度:</label>
                    <input type="range" id="speed-slider" min="0.1" max="2" step="0.1" value="1">
                    <span id="speed-value">1.0</span>
                </div>
                
                <div class="control-group">
                    <label>噪声缩放:</label>
                    <input type="range" id="scale-slider" min="0.005" max="0.03" step="0.001" value="0.015">
                    <span id="scale-value">0.015</span>
                </div>
                
                <div class="control-group">
                    <label>等高线数量:</label>
                    <input type="range" id="levels-slider" min="4" max="16" step="1" value="8">
                    <span id="levels-value">8</span>
                </div>
                
                <div class="control-group">
                    <button id="toggle-animation">暂停动画</button>
                    <button id="reset-params">重置参数</button>
                </div>
            </div>
            
            <div class="status">
                <div class="info">状态: <span id="status-text">正在初始化...</span></div>
                <div class="info">渲染器: <span id="renderer-type">检测中...</span></div>
                <div class="info">性能: <span id="performance-info">监控中...</span></div>
            </div>
        </div>
    </div>

    <!-- 加载必要的库 -->
    <script src="static/js/lib/noise2d.js"></script>
    <script src="static/js/lib/d3-contour-lite.js"></script>
    
    <script>
        // 简化的测试版本，只包含背景等高线相关功能
        class ContourTester {
            constructor() {
                this.bgCanvas = document.getElementById('bg-noise');
                this.bgCtx = this.bgCanvas.getContext('2d');
                this.bgNoise = window.Noise2D.create({ seed: 1337 });
                this.bgConfig = { cols: 150, rows: 90, scale: 0.015 };
                this.animationSpeed = 1.0;
                this.isAnimating = true;
                this.bgTime = 0;
                this.bgLastRAF = 0;
                this.bgMinDt = 1000 / 30;
                
                this.setupCanvas();
                this.setupControls();
                this.startAnimation();
            }
            
            setupCanvas() {
                const rect = this.bgCanvas.getBoundingClientRect();
                this.bgCanvas.width = rect.width;
                this.bgCanvas.height = rect.height;
                
                document.getElementById('status-text').textContent = '画布已初始化';
                document.getElementById('renderer-type').textContent = 
                    typeof d3 !== 'undefined' && d3.contours ? 'D3 Contours (改进版)' : 'Fallback Renderer (改进版)';
            }
            
            setupControls() {
                const speedSlider = document.getElementById('speed-slider');
                const scaleSlider = document.getElementById('scale-slider');
                const levelsSlider = document.getElementById('levels-slider');
                const toggleBtn = document.getElementById('toggle-animation');
                const resetBtn = document.getElementById('reset-params');
                
                speedSlider.addEventListener('input', (e) => {
                    this.animationSpeed = parseFloat(e.target.value);
                    document.getElementById('speed-value').textContent = this.animationSpeed.toFixed(1);
                });
                
                scaleSlider.addEventListener('input', (e) => {
                    this.bgConfig.scale = parseFloat(e.target.value);
                    document.getElementById('scale-value').textContent = this.bgConfig.scale.toFixed(3);
                });
                
                levelsSlider.addEventListener('input', (e) => {
                    this.contourLevels = parseInt(e.target.value);
                    document.getElementById('levels-value').textContent = this.contourLevels;
                });
                
                toggleBtn.addEventListener('click', () => {
                    this.isAnimating = !this.isAnimating;
                    toggleBtn.textContent = this.isAnimating ? '暂停动画' : '继续动画';
                    if (this.isAnimating) {
                        this.startAnimation();
                    }
                });
                
                resetBtn.addEventListener('click', () => {
                    this.bgConfig.scale = 0.015;
                    this.animationSpeed = 1.0;
                    this.contourLevels = 8;
                    
                    speedSlider.value = 1.0;
                    scaleSlider.value = 0.015;
                    levelsSlider.value = 8;
                    
                    document.getElementById('speed-value').textContent = '1.0';
                    document.getElementById('scale-value').textContent = '0.015';
                    document.getElementById('levels-value').textContent = '8';
                });
                
                this.contourLevels = 8;
            }
            
            startAnimation() {
                if (!this.isAnimating) return;
                
                const draw = (now) => {
                    if (!this.isAnimating) return;
                    
                    if (this.bgLastRAF && now - this.bgLastRAF < this.bgMinDt) {
                        requestAnimationFrame(draw);
                        return;
                    }
                    
                    const dt = this.bgLastRAF ? now - this.bgLastRAF : this.bgMinDt;
                    this.bgLastRAF = now;
                    
                    this.renderContours(now);
                    
                    // 更新性能信息
                    document.getElementById('performance-info').textContent = 
                        `${dt.toFixed(1)}ms (${(1000/dt).toFixed(1)} FPS)`;
                    
                    requestAnimationFrame(draw);
                };
                
                requestAnimationFrame(draw);
                document.getElementById('status-text').textContent = '动画运行中';
            }
            
            renderContours(now) {
                const { cols: baseW, rows: baseH, scale } = this.bgConfig;
                const values = new Float32Array(baseW * baseH);
                
                // 生成改进的多层噪声
                const t = now * 0.00005 * this.animationSpeed;
                let k = 0;
                for (let y = 0; y < baseH; y++) {
                    for (let x = 0; x < baseW; x++) {
                        const v1 = this.bgNoise.noise2(x * scale, y * scale + t);
                        const v2 = this.bgNoise.noise2(x * scale * 2, y * scale * 2 + t * 0.5) * 0.5;
                        const v3 = this.bgNoise.noise2(x * scale * 4, y * scale * 4 + t * 0.25) * 0.25;
                        const combined = v1 + v2 + v3;
                        values[k++] = Math.max(0, Math.min(1, (combined + 1) * 0.4 + 0.1));
                    }
                }
                
                // 生成改进的等高线阈值
                const thresholds = Array.from(
                    { length: this.contourLevels },
                    (_, i) => 0.2 + i * (0.65 / (this.contourLevels - 1))
                );
                
                let sets;
                if (typeof d3 !== 'undefined' && d3.contours) {
                    const gen = d3.contours().size([baseW, baseH]).thresholds(thresholds);
                    sets = gen(values);
                } else {
                    sets = this.generateFallbackContours(values, baseW, baseH, thresholds);
                }
                
                // 渲染等高线
                const W = this.bgCanvas.width;
                const H = this.bgCanvas.height;
                
                this.bgCtx.clearRect(0, 0, W, H);
                this.bgCtx.globalAlpha = 0.8;
                this.bgCtx.lineJoin = 'round';
                this.bgCtx.lineCap = 'round';
                this.bgCtx.shadowBlur = 2;
                this.bgCtx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                
                const palette = ['#00f3ff', '#bf00ff', '#00ff66', '#ffc107', '#ff6b6b'];
                const minV = thresholds[0];
                const maxV = thresholds[thresholds.length - 1];
                
                sets.forEach((contour, idx) => {
                    const v = contour.value || minV;
                    const tval = Math.max(0, Math.min(1, (v - minV) / Math.max(1e-6, maxV - minV)));
                    const hex = this.mixHexColors(palette, tval);
                    const alpha = 0.4 + 0.4 * tval;
                    
                    this.bgCtx.strokeStyle = this.rgbaFromHex(hex, alpha);
                    this.bgCtx.lineWidth = 1.5 + idx * 0.3;
                    
                    const polylines = this.normalizeContourCoordinates(contour.coordinates);
                    polylines.forEach((ring) => {
                        if (ring.length < 3) return;
                        
                        this.bgCtx.beginPath();
                        for (let p = 0; p < ring.length; p++) {
                            const gx = ring[p][0];
                            const gy = ring[p][1];
                            const x = (gx / (baseW - 1)) * W;
                            const y = (gy / (baseH - 1)) * H;
                            if (p === 0) this.bgCtx.moveTo(x, y);
                            else this.bgCtx.lineTo(x, y);
                        }
                        
                        const fx = (ring[0][0] / (baseW - 1)) * W;
                        const fy = (ring[0][1] / (baseH - 1)) * H;
                        const lx = (ring[ring.length - 1][0] / (baseW - 1)) * W;
                        const ly = (ring[ring.length - 1][1] / (baseH - 1)) * H;
                        const dx = fx - lx;
                        const dy = fy - ly;
                        const closed = dx * dx + dy * dy < 2.0;
                        if (closed) this.bgCtx.closePath();
                        
                        this.bgCtx.stroke();
                    });
                });
            }
            
            // 复制必要的辅助函数
            mixHexColors(palette, t) {
                const n = palette.length;
                const scaled = t * (n - 1);
                const i = Math.floor(scaled);
                const f = scaled - i;
                
                if (i >= n - 1) return palette[n - 1];
                if (i < 0) return palette[0];
                
                const c1 = this.hexToRgb(palette[i]);
                const c2 = this.hexToRgb(palette[i + 1]);
                
                const r = Math.round(c1.r + f * (c2.r - c1.r));
                const g = Math.round(c1.g + f * (c2.g - c1.g));
                const b = Math.round(c1.b + f * (c2.b - c1.b));
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            rgbaFromHex(hex, alpha) {
                const rgb = this.hexToRgb(hex);
                return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
            }
            
            normalizeContourCoordinates(coordinates) {
                const polylines = [];
                coordinates.forEach((multi) => {
                    multi.forEach((ring) => polylines.push(ring));
                });
                return polylines;
            }
            
            // Fallback contour generation (simplified version)
            generateFallbackContours(values, baseW, baseH, thresholds) {
                const sets = [];
                for (let ti = 0; ti < thresholds.length; ti++) {
                    const t = thresholds[ti];
                    const coords = [];
                    for (let y = 0; y < baseH - 1; y++) {
                        for (let x = 0; x < baseW - 1; x++) {
                            const i00 = y * baseW + x;
                            const i10 = y * baseW + (x + 1);
                            const i01 = (y + 1) * baseW + x;
                            const i11 = (y + 1) * baseW + (x + 1);
                            const v00 = values[i00];
                            const v10 = values[i10];
                            const v01 = values[i01];
                            const v11 = values[i11];
                            const e = [];
                            if (v00 < t !== v10 < t) {
                                const r = (t - v00) / Math.max(1e-6, v10 - v00);
                                e.push([x + r, y]);
                            }
                            if (v10 < t !== v11 < t) {
                                const r = (t - v10) / Math.max(1e-6, v11 - v10);
                                e.push([x + 1, y + r]);
                            }
                            if (v01 < t !== v11 < t) {
                                const r = (t - v01) / Math.max(1e-6, v11 - v01);
                                e.push([x + r, y + 1]);
                            }
                            if (v00 < t !== v01 < t) {
                                const r = (t - v00) / Math.max(1e-6, v01 - v00);
                                e.push([x, y + r]);
                            }
                            if (e.length === 2) {
                                coords.push([e]);
                            }
                        }
                    }
                    sets.push({ value: t, coordinates: coords });
                }
                return sets;
            }
        }
        
        // 初始化测试器
        window.addEventListener('load', () => {
            new ContourTester();
        });
    </script>
</body>
</html>